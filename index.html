<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Why join the navy if you can be a pirate?">
<meta property="og:type" content="website">
<meta property="og:title" content="Cherry Blessing">
<meta property="og:url" content="https://blessingsoft.com/index.html">
<meta property="og:site_name" content="Cherry Blessing">
<meta property="og:description" content="Why join the navy if you can be a pirate?">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cherry Blessing">
<meta name="twitter:description" content="Why join the navy if you can be a pirate?">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blessingsoft.com/"/>





  <title>Cherry Blessing</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cherry Blessing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">A monad is a monoid in the category of endofunctors</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/12/group-theory-and-category-theory/" itemprop="url">Group Theory and Category Theory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T22:53:27+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想理解函数式编程中的一些高大上的概念，比如 Functor, Monad 等，必须要先理解范畴论。</p>
<h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><blockquote>
<p>群，是一种代数结构，由一个集合（G）以及一个二元运算符（·）所组成。<a href="https://zh.wikipedia.org/wiki/群" target="_blank" rel="external">wikipedia</a></p>
</blockquote>
<p>一个群必须满足一些称为 <em>群公理</em> 的条件，也就是 <strong>封闭性</strong>、<strong>结合律</strong>、<strong>单位元</strong> 和 <strong>逆元</strong>。如整数配备上加法运算就形成一个群。</p>
<ul>
<li>封闭性（Closure）：对于任意 a,b∈G，a·b∈G。</li>
<li>结合律（Associativity）：对于任意 a,b,c∈G，(a·b)·c == a·(b·c)。</li>
<li>单位元（Identity）：G 中存在一个元素 e，使得任意 a∈G，a·e == e·a == a。</li>
<li>逆元：对于任意 a∈G，存在 b∈G，使得 a·b == b·a == e。</li>
</ul>
<p>群并不要求这个二元运算符（·）具体做什么，它只要求这个二元运算符存在，所以很多数学结构都是群。比如我们可以把整数当作一个群，把 <code>+</code> 作为二元运算符。</p>
<ul>
<li>封闭性：对于任意两个整数 a,b，a+b 依然是一个整数。</li>
<li>结合律：对于任意整数 a,b,c，(a+b)+c == a+(b+c)。</li>
<li>单位元：存在元素 0，使得 a+0 == 0+a == a。</li>
<li>逆元：对于任意整数 a，当 b=-a 时，a+b == b+a == e。</li>
</ul>
<p>所以我们可以说 (整数, +) 是一个群。如果把 <code>*</code> 当作二元运算符，把 <code>1</code> 作为单位元的时候，整数就形成了另一个群。</p>
<p>除了整数，还有很多数学结构是群。</p>
<h3 id="Semigroup"><a href="#Semigroup" class="headerlink" title="Semigroup"></a>Semigroup</h3><p>满足封闭性和结合律的群，称为半群（semigroup）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;&gt;: <span class="type">AdditionPrecedence</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> lhs + rhs</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Array, rhs: Array)</span></span> -&gt; <span class="type">Array</span> &#123;</div><div class="line">        <span class="keyword">return</span> lhs + rhs</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 折叠 fold</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;S: Semigroup&gt;<span class="params">(<span class="number">_</span> xs: [S], <span class="number">_</span> initial: S)</span></span> -&gt; <span class="type">S</span> &#123;</div><div class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(initial, &lt;&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>半群的结合律特性使得我们可以进行并行运算，<code>1 &lt;&gt; 2 &lt;&gt; 3 &lt;&gt; 4</code>。</p>
<h3 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h3><p>在抽象代数中，有一类简单的抽象结构被称为 Monoid（幺半群）。许多数学结构都是幺半群，因为成为幺半群的要求非常低。</p>
<p>存在单位元的半群，称为含幺半群，或者幺半群，或者单群，或者独异点（monoid）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Monoid</span>: <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Monoid</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e = <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Monoid</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Array</span> &#123;</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;M: Monoid&gt;<span class="params">(<span class="number">_</span> xs: [M])</span></span> -&gt; <span class="type">M</span> &#123;</div><div class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(<span class="type">M</span>.e, &lt;&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>concat</code> 是对 Monoid 的一种应用，它可以利用 Monoid 的定义（ 二元操作 <code>&lt;&gt;</code> 和 单位元 <code>e</code> ）进行折叠操作。</p>
<h2 id="Category-Theory"><a href="#Category-Theory" class="headerlink" title="Category Theory"></a>Category Theory</h2><blockquote>
<p>范畴论是数学的一门学科，以抽象的方法来处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。<a href="https://zh.wikipedia.org/wiki/范畴论" target="_blank" rel="external">范畴论</a></p>
</blockquote>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>一个范畴 C 包括：</p>
<ul>
<li>一个由对象（object）组成的类 ob(C)。（注：这里把“物件”成为“对象“更有助于从计算机的角度理解</li>
<li>对象间态射（morphism，-&gt;）组成的类 hom(C)：每个态射 f 都只有一个「源对象」a 以及一个「目标对象」b（其中 a,b 都在 ob(C) 内），称之为 <strong>从 a 到 b 的态射</strong>，记为 f: a-&gt;b。（注：identity 态射即自己映射到自己的特殊态射，f: a-&gt;a，简单记为 id[a]）</li>
<li>一个二元运算符（·），用于态射组合，如 h=g·f。</li>
</ul>
<p>满足公理：</p>
<ul>
<li>结合律：f: a-&gt;b, g: b-&gt;c, h: c-&gt;d，h·(g·f) = (h·g)·f。</li>
<li>单位元：id[a]·f = id[b]·f = f。</li>
<li>封闭性：f: a-&gt;b, g: b-&gt;c, h: a-&gt;c, h = f·g。</li>
</ul>
<p>范畴举例：</p>
<ul>
<li>范畴 C 有 Int 类型和 String 类型对象。</li>
<li>存在态射 f: Int-&gt;String。</li>
</ul>
<p>划重点：幺半群可以视为一类特殊的范畴。幺半群运算满足的公理同于范畴中 <strong>从一个对象到自身的态射</strong>。换言之：<br>幺半群实质上是只有单个对象的范畴。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><blockquote>
<p>在范畴论中，函子是范畴间的一类映射。函子也可以解释为小范畴为成员的范畴内的态射。 <a href="https://zh.wikipedia.org/wiki/函子" target="_blank" rel="external">wikipedia</a></p>
</blockquote>
<p>在当代数学中，函子被用来描述各种范畴间的关系。对范畴论者来说，函子则是个特别类型的函数。</p>
<p>设 C 和 D 为范畴，从 C 至 D 的函子为一映射 F:</p>
<ul>
<li>将每个对象 x∈C 映射至一对象 F(x)∈D 上。</li>
<li>将每个态射 f: x-&gt;y∈C 映射至一态射 F(f): F(x)-&gt;F(y)∈D 上，</li>
</ul>
<p>使之满足：</p>
<ul>
<li>对任何对象 x∈C，恒有 F(id[x]) = id[F(x)]。</li>
<li>对任何态射 f: x-&gt;y, g: y-&gt;z，恒有 F(f·g) = F(f)·F(g)。</li>
</ul>
<p>换言之，函子会保持单位态射与态射的复合。<br>一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
<h4 id="可以把范畴当作一组类型的集合"><a href="#可以把范畴当作一组类型的集合" class="headerlink" title="可以把范畴当作一组类型的集合"></a>可以把范畴当作一组类型的集合</h4><p>如范畴 C 有 Int 类型和 String 类型对象，以及 Int -&gt; String 的态射；范畴 D 有 Array<int> 类型和 Array<string> 类型对象，以及 Array<int> -&gt; Array<string> 的态射。两个范畴之间的映射 F：</string></int></string></int></p>
<ul>
<li>Int 映射至 Array<int> 上，String 映射至 Array<string> 上。</string></int></li>
<li>态射 Int -&gt; String 映射至 Array<int> -&gt; Array<string> 上。</string></int></li>
</ul>
<p>翻译成代码：C: Int, String, f: Int -&gt; String, D: Array<int>, Array<string>, f: Array<int> -&gt; Array<string>。</string></int></string></int></p>
<ul>
<li>x: Int -&gt; F(x): Array<int>，String -&gt; F(x): Array<string></string></int></li>
<li>f: (Int -&gt; String) -&gt; F(f): (Array<int> -&gt; Array<string>)</string></int></li>
</ul>
<p>范畴是不涉及具体类型的，所以用泛型表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tmap</span>&lt;T&gt;<span class="params">(x: T)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">T</span>&gt;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmap</span>&lt;A, B&gt;<span class="params">(f: A -&gt; B)</span></span> -&gt; (<span class="type">F</span>&lt;<span class="type">A</span>&gt; -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;)</div></pre></td></tr></table></figure>
<p>简化一下变成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将 tmap 和 fmap 合并</span></div><div class="line"><span class="comment">// 由于 fmap 实际上是 (F&lt;A&gt;, A -&gt; B) -&gt; F&lt;B&gt; 的 curry 版本，</span></div><div class="line"><span class="comment">// 所以两者是等价的。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;, f: A -&gt; B)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</div></pre></td></tr></table></figure>
<p>在来看看 Swift 中的 <code>Array</code> 和 <code>Optional</code>。如果把 Swift 中所有的类型 <code>A, B</code> 当作对象，以及 Swift 中所有的函数当作态射 <code>A -&gt; B</code>，那么这些类型和函数就组成一个范畴 A。把 Array 类型当作对象 <code>Array&lt;A&gt;, Array&lt;B&gt;</code>，Array 上所有的函数当作态射 <code>Array&lt;A&gt; -&gt; Array&lt;B&gt;</code>，那么也组成一个范畴 B。而 A 到 B 之间的函子是 Array，因为函子 Array 能将任意类型 <code>T</code> 转换为 <code>Array&lt;T&gt;</code>。<code>Optional</code> 同理。</p>
<p>很多库对 <code>Functor</code> 的支持直接在类型构造器（Type Constructor）的定义中实现 <code>map</code> 方法，比如 Swift 中的 <code>Array</code> 和 <code>Optional</code> 就是需要一个泛型作为参数来构建具体类型的类型构造器，它在定义中实现了 <code>map</code> 方法。这些类型构造器相当于同时具备了类型和函数的映射。在 Haskell 里把这个行为称为 <code>Lift</code>，相当于把类型和函数放到容器里面。所以一个带有 <code>map</code> 方法的类型构造器就是一个函子。</p>
<p>范畴与高阶类型：如果忽略范畴中的态射，范畴其实就是对特定类型的抽象，即高阶类型（类型构造器）。对于范畴 D，它的所有类型都是 Array<t> 的特定类型。而对于范畴 C，可以看作是一个 Identity 类型的构造器（id[T] = T）。</t></p>
<p>注意⚠️：函子不是容器，函子不是容器，函子不是容器。</p>
<p>如 <code>typealias Parser&lt;A&gt; = (String) -&gt; (A, String)?</code> 我们可以实现 <code>func map&lt;A, B&gt;(x: Parser&lt;A&gt;, f: (A) -&gt; B) -&gt; Parser&lt;B&gt;</code> 函数，所以我们可以说 <code>Parser&lt;A&gt;</code> 是一个函子，但它不是容器。</p>
<h3 id="Endofunctor"><a href="#Endofunctor" class="headerlink" title="Endofunctor"></a>Endofunctor</h3><p>A functor that maps a category to itself。一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
<p>先看自函数的概念：将一个类型映射到自身类型，如 Int -&gt; Int。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</div></pre></td></tr></table></figure>
<p>单位函数（Identity Function）的概念：什么都不做，传入什么就返回什么。属于自函数的特例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">id</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x &#125;</div></pre></td></tr></table></figure>
<p><strong>自函子不是单位函子（Identity Functor）</strong>。还是上面的范畴 C，为了区分自函子和单位函子，多加一种态射 g: String-&gt;Int，那么：</p>
<p>自函子：对于函子 F，对于 F[Int] 结果是 String，F[String] 结果是 Int，对于 F[f: Int -&gt; String] 结果是 g: String -&gt; Int。那么这个函子就是自函子。</p>
<p>单位函子（Identity Functor）：对于函子 F，对于 F[Int] 结果还是 Int，对于 F[String] 结果还是 String，对于 F[f: Int -&gt; String] 结果还是 f: Int -&gt; String，对于 F[g: String -&gt; Int] 结果还是 g: String -&gt; Int。那么这个函子就是单位函子。 </p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>虽然在 Haskell 中 Monad 是 Applicative 的一种，但是 Applicative 的出现却在 Monad 之后。</p>
<p><code>func pure&lt;T&gt;(x: T) -&gt; F&lt;T&gt;</code></p>
<p>未完待续</p>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><blockquote>
<p>A monad is a monoid in the category of endofunctors – Philip Wadler</p>
</blockquote>
<p>（自函子说穿了就是把一个范畴映射到自身的函子，自函子范畴说穿了就是从小范畴映射到自身的函子所构成的以自函子为对象以自然变换为态射 的范畴，幺半群说穿了就是只有单个对象的范畴，给定了一个幺半群则可构造出一个仅有单个对象的小范畴使其态射由幺半群的元素给出而合成由幺半群的运算给 出，而单子说穿了就是自函子范畴上的这样一个幺半群。（这都不理解么亲连这种最基本的概念都不理解还学什么编程！）</p>
<p>未完待续</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/28/parser-combinator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/28/parser-combinator/" itemprop="url">Parser Combinator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T16:50:04+08:00">
                2017-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</p>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>将一个数据流解析成结构化的数据的工具，我们称为解析器。比如我们需要将用户输入的表达式字符串解析成 AST，我们就可以使用解析器来达到我们的目的。</p>
<p><code>4 + 3</code> 就是一个表达式语句，它由字符 <code>4</code> <code>空格</code> <code>+</code> <code>空格</code> 和 <code>3</code> 组成。我们可以将这个表达式解析成一种 <em>表达式树</em> (AST 的一种)。</p>
<p>所以我们的解析器简单的用一个函数来描述就是：<br><code>func parser(_ string: String) -&gt; AST</code></p>
<p>我们不是用正则表达式来解析输入的表达式字符串，为了得到表达式树里面的节点，我们需要一步步的解析，每次解析得到不同的节点。所以我们需要将解析器的定义变成解析成功的话，会返回结果值和剩下的字符串。</p>
<p><code>func parser(_ string: String) -&gt; (AST, String)</code></p>
<p>表达式树的节点都是一些 <code>4</code> <code>+</code> 这种不同类型的数据，所以为了表示解析 <code>4</code> 成功和解析 <code>+</code> 成功，我们的返回值可以定义为泛型。并且表达出解析失败的情况，我们可以使用可选值。最终解析器函数就变成了：</p>
<p><code>func parser&lt;T&gt;(_ string: String) -&gt; (T, String)?</code></p>
<p>所以解析第一个数字 4 的解析器函数为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">String</span>)? &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = string.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="type">Optional</span>.some((<span class="number">4</span>, <span class="type">String</span>(string.characters.<span class="built_in">dropFirst</span>())))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Combinator"><a href="#Combinator" class="headerlink" title="Combinator"></a>Combinator</h2><blockquote>
<p>One of the distinguishing features of functional programming is the widespread use of combinators to construct programs. <em>A combinator is a function which builds program fragments from program fragments</em>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. – John Hughes</p>
</blockquote>
<p>其实 Combinator 很容易理解，就像字面意思那样 —— 组合子。首先定义一系列原子操作，然后定义组合的规则，然后根据组合的规则把这些原子操作组合起来。</p>
<h2 id="Parser-Combinator"><a href="#Parser-Combinator" class="headerlink" title="Parser Combinator"></a>Parser Combinator</h2><p>回到开头的话：<em>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</em> 所以我们需要重新定义一下我们的解析器，把它变成一个解析组合子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">let</span> parse: (<span class="type">String</span>) -&gt; (<span class="type">A</span>, <span class="type">String</span>)?</div><div class="line">    <span class="comment">// (input) -&gt; (result, remaining)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个解析字符串的解析器，我们把这个函数放到一个结构体 <code>Parser</code> 中，作为一个 <code>parse</code> 变量。当然我们也可以用类型别名 <code>typealias Parser&lt;Result&gt; = (String) -&gt; (Result, String)?</code>。</p>
<p>当然解析组合子不仅仅能解析字符串，所以可以用泛型来把它变得更通用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">let</span> parse: (<span class="type">I</span>) -&gt; (<span class="type">O</span>, <span class="type">I</span>)?</div><div class="line">    <span class="comment">// (input) -&gt; (output, remaining input)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以解析数字字符 <code>4</code> 的解析器就变成了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">character4</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="string">"4"</span>, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以根据 <code>func character4() -&gt; Parser&lt;Character&gt;</code> 很容易得到一个能够解析任何字符的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">character</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == character <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 的区别，很容易又得到能够解析任何数字的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">digit</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, <span class="string">"0"</span>...<span class="string">"9"</span> ~= head <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 相同和不同，我们可以进一步抽象，把相同部分进行封装，把不同部分作为参数，得到新的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">satisfy</span><span class="params">(<span class="number">_</span> condition: @escaping <span class="params">(Character)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, condition(head) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.charcters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以解析数字：</p>
<p><code>(satisfy { &quot;0&quot;...&quot;9&quot; ~= $0 }).parse(&quot;1abc&quot;)</code></p>
<p>解析空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSpace</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">String</span>(character).trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines).isEmpty</div><div class="line">&#125;</div><div class="line">(satisfy(isSpace)).parse(<span class="string">" abc"</span>)</div></pre></td></tr></table></figure>
<p>所以我们只需要给 <code>satisfy</code> 函数传入一个是否属于 X 的函数，就可以得到一个能够解析 x 的解析器。</p>
<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>最基本的 <code>character</code> 有了，<code>digit</code> 有了，当我们需要解析一个字符串 <code>alex</code> 的时候，我们只需要把 <code>alex</code> 看成 <code>a</code> <code>l</code> <code>e</code> <code>x</code> 4 个字符，然后不断的用 <code>character</code> 进行解析，最后把每一步返回的结果合并起来就行了。考虑到解析一个字符串是一个基本功能，为了不用每次写重复的代码，把它封装成用来解析 <code>string</code> 的解析器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> parsers = str.characters.<span class="built_in">map</span> &#123; character($<span class="number">0</span>) &#125;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">for</span> parser <span class="keyword">in</span> parsers &#123;</div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = parser.parse(stream) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">            &#125;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="type">String</span>(results), stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察 parse 函数类型 <code>(String) -&gt; (A, String)</code>，解析成功的返回值是解析结果和 <strong>剩余</strong> 的字符串，所以解析 <code>alex</code> 的时候：</p>
<ol>
<li>“alex”: ‘a’ -&gt; (‘a’, “lex”)</li>
<li>“lex”: ‘l’ -&gt; (‘l’, “ex”)</li>
<li>“ex”: ‘e’ -&gt; (‘e’, “x”)</li>
<li>“x”: ‘x’ -&gt; (‘x’, “”)</li>
<li>Parser&lt;”alex”&gt;</li>
</ol>
<p>可以看到这几步做的事情除了参数不一样，内部逻辑是一样的，而且很容易看出是一个递归的过程，<strong>每次解析成功就 <code>吃掉</code> 第一个字符</strong>（留意这句话），然后解析剩下的字符串。</p>
<p>所以我们写一个递归的版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 0. 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 1. 先解析第一个字符</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = character(head).parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. 然后解析剩下的所有</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder2) = string1(<span class="type">String</span>(tail)).parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. 返回("结果", "剩余的字符串")</span></div><div class="line">        <span class="keyword">return</span> (str, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncons</span>&lt;C: Collection&gt;<span class="params">(<span class="number">_</span> xs: C)</span></span> -&gt; (<span class="type">C</span>.<span class="type">Iterator</span>.<span class="type">Element</span>, <span class="type">C</span>.<span class="type">SubSequence</span>)? &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = xs.first <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (head, xs.suffix(from: xs.index(after: xs.startIndex)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察 1 和 2，在这两步中，我们都没有使用解析的 <strong>结果</strong>，这两步实现的仅仅是 <strong>每次解析成功就 <code>吃掉</code> 结果</strong>！最后在第 3 步一次将结果返回。也就是说我们 1 和 2 这两本并不关心结果，只关心这些要解析道字符存在就行了。</p>
<p>我们把解析成功吃掉结果这一步封装一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只保留右边的解析器的结果 result2，没有 result1</span></div><div class="line">        <span class="keyword">return</span> (result2, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>discarding</code> 函数会 <strong>吃掉</strong> 左边第一个参数 <code>x</code> 的解析结果，返回值中只保留右边 <code>y</code> 的解析结果。用 <code>discarding</code> 函数重写一下上面的 <code>string</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 1 吃掉 character(head) 的结果</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder) = discarding(character(head), string2(<span class="type">String</span>(tail))).parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2 返回 ("结果", "剩余的字符串")</span></div><div class="line">        <span class="keyword">return</span> (str, remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次改版的 <code>string</code> 里面第 1 步中的解析结果还是被忽略了，所以是否可以继续用 <code>discarding</code> 来简化？但是 <code>discarding</code> 函数需要两个解析器，但函数内只有 <code>discarding</code> 返回的一个解析器，所以没办法继续简化了？</p>
<p>仔细看 <code>string</code> 函数体的第一行 <code>return Parser {}</code> 就是一个解析器，能否把这个解析器利用上呢？<code>discarding</code> 是在 <code>Parser {}</code> 里面的，所以只要能想办法把它展平，那么就能再次利用上 <code>discarding</code>，而且展平后的解析器需要做为 <code>string</code> 函数的返回值，所以它肯定是做为 <code>discarding</code> 的右边的参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> lhs = <span class="type">Parser</span> &#123;&#125;</div><div class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;&#125;</div><div class="line">    <span class="keyword">return</span> discarding(x, y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据第 2 步的 <code>return (str, remainder)</code> 可以知道，最终的返回结果是 <code>(输入的，lhs 吃剩的)</code>，所以很容易得到 <code>let rhs = Parser&lt;String&gt; { (str, $0) }</code>。所以可以推出 lhs 要做的只是负责吃掉一部分。也就是上面的第 1 步所做的。所以：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">        <span class="keyword">return</span> (<span class="string">""</span>, input)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2 吃掉</span></div><div class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</div><div class="line">    <span class="comment">// 3 结果和剩下的</span></div><div class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</div><div class="line">    <span class="comment">// 4 返回</span></div><div class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的返回值是 <code>Parser</code>，由于外面没有 Parser {} ，展开后 1 那里需要返回一个 <code>Parser</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">        <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (<span class="string">""</span>, $<span class="number">0</span>) &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>明眼人可以看到 1 和 3 只有 <code>&quot;&quot;</code> 和 <code>str</code> 不一样，剩下的一模一样，虽然代码不长，但我们还是把它相同部分封装成一个函数，然后把不同的部分做为参赛。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">        <span class="keyword">return</span> pure(<span class="string">""</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    <span class="keyword">let</span> rhs = pure(str)</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pure</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: A)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123; (x, $<span class="number">0</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以封装一个简洁的 <code>string</code> 解析器，花了很多功夫，但抛开性能，它比迭代的版本更简洁易懂。</p>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>根据 <code>func character(_ character: Character) -&gt; Parser&lt;Character&gt;</code> 的定义，假如我们调用 <code>character(&quot;4&quot;)</code>，那么返回的是一个 <code>Parser&lt;Character&gt;</code> 类型的解析器，这个解析器调用 <code>parse</code> 方法，返回的结果是 <code>Character</code> 类型的值。假如我们不想要 <code>Character</code> 类型的值，而是想要 <code>Int</code> 类型的值，那么我们需要将 <code>Parser&lt;Character&gt;</code> 转换为 <code>Parser&lt;Int&gt;</code> 解析器。甚至我们希望有一个方法，可以将任意 <code>Parser&lt;A&gt;</code> 转换为 <code>Parser&lt;B&gt;</code> 解析器。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><p>回忆 Swift 中 Optional 类型中的 map 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt; = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> b: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = a.<span class="built_in">map</span> &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</div></pre></td></tr></table></figure>
<p>它将一个 <code>Optional&lt;Int&gt;</code> 转换为 <code>Optional&lt;String&gt;</code>，仔细一看，把 <code>Optional</code> 换成 <code>Parser</code>，就是我们所需要的转换解析器的方法。</p>
<p><code>Optional</code> 的函数签名是 <code>func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; U?</code>，所以依葫芦画瓢，我们可以得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;B&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = <span class="keyword">self</span>.parse(input) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">            <span class="keyword">return</span> (transform(result), remainder)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像上面的 <code>satisfy</code> 和其他函数一样，把 <code>map</code> 方法从结构图内移出来，则得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(x: Parser&lt;A&gt;, f: @escaping <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = x.parse(input)<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (f(result), remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于值是在 <code>Parser</code> 中包裹着的，想把返回的 <code>Parser&lt;Character</code> 变成 <code>Parser&lt;Int&gt;</code>，需要把 <code>Parser&lt;Character&gt;</code> 解开取出里面<character>的值，然后把它变成<int>类型，然后重现包装起来。对于不同的类型转换，解包重新包装的步骤是一样的，不同的地方是把结果从一种类型变成另一种类型，函数的作用就是把相同的封装起来，把不同做为参赛传进去，所以在 <code>map</code> 函数的实现中，我们只需要在返回前，给外部将这个结果进行一次转换机会，所以需要一个参赛，能够将解开后得到的值变成另一种类型的值，也就是提供一个函数 <code>(Character) -&gt; Int</code>。</int></character></p>
<p>两种不同的结构体 <code>Optional&lt;T&gt;</code> 和 <code>Parser&lt;A&gt;</code>，我们都可以给它实现一个 <code>map</code> 方法，使得它变成一个不同类型的结构体。而支持这种 <code>map</code> 方法的结构体，我们称把它为 <code>Functor</code>。</p>
<blockquote>
<p>简单来说，所谓的 <code>Functor</code> 就是可以把一个函数应用于一个 <strong>封装过的值</strong> 上，得到一个新的 <strong>封装过的值</strong></p>
</blockquote>
<p>「未完待续」</p>
<h3 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h3><p>Apply…</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>从 Group 说起…</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/hlian/jiffy" target="_blank" rel="external">Jiffy</a><br><a href="https://news.realm.io/news/tryswift-yasuhiro-inami-parser-combinator/" target="_blank" rel="external">parser combinator</a><br><a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf" target="_blank" rel="external">monparsing</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/20/cherry-blessing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/cherry-blessing/" itemprop="url">Cherry Blessing</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T12:37:36+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to Cherry Blessing.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Xspyhack" />
          <p class="site-author-name" itemprop="name">Xspyhack</p>
           
              <p class="site-description motion-element" itemprop="description">Why join the navy if you can be a pirate?</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xspyhack</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
