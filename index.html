<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Why join the navy if you can be a pirate?">
<meta property="og:type" content="website">
<meta property="og:title" content="Cherry Blessing">
<meta property="og:url" content="https://blessingsoft.com/index.html">
<meta property="og:site_name" content="Cherry Blessing">
<meta property="og:description" content="Why join the navy if you can be a pirate?">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cherry Blessing">
<meta name="twitter:description" content="Why join the navy if you can be a pirate?">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blessingsoft.com/"/>





  <title>Cherry Blessing</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cherry Blessing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">A monad is a monoid in the category of endofunctors</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/12/group-theory-and-category-theory/" itemprop="url">Group Theory and Category Theory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T22:53:27+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想理解函数式编程中的一些高大上的概念，比如 Functor, Monad 等，必须要先理解范畴论。</p>
<h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><blockquote>
<p>群，是一种代数结构，由一个集合（G）以及一个二元运算符（·）所组成。<a href="https://zh.wikipedia.org/wiki/群" target="_blank" rel="external">wikipedia</a></p>
</blockquote>
<p>一个群必须满足一些称为 <em>群公理</em> 的条件，也就是 <strong>封闭性</strong>、<strong>结合律</strong>、<strong>单位元</strong> 和 <strong>逆元</strong>。如整数配备上加法运算就形成一个群。</p>
<ul>
<li>封闭性（Closure）：对于任意 a,b∈G，a·b∈G。</li>
<li>结合律（Associativity）：对于任意 a,b,c∈G，(a·b)·c = a·(b·c)。</li>
<li>单位元（Identity）：G 中存在一个元素 e，使得任意 a∈G，a·e = e·a = a。</li>
<li>逆元：对于任意 a∈G，存在 b∈G，使得 a·b = b·a = e。</li>
</ul>
<p>群并不要求这个二元运算符（·）具体做什么，它只要求这个二元运算符存在，所以很多数学结构都是群。比如我们可以把整数当作一个群，把 <code>+</code> 作为二元运算符。</p>
<ul>
<li>封闭性：对于任意两个整数 a,b，a+b 依然是一个整数。</li>
<li>结合律：对于任意整数 a,b,c，(a+b)+c = a+(b+c)。</li>
<li>单位元：存在元素 0，使得 a+0 = 0+a = a。</li>
<li>逆元：对于任意整数 a，当 b=-a 时，a+b = b+a = e。</li>
</ul>
<p>所以我们可以说 <code>(整数, +)</code> 是一个群。如果把 <code>*</code> 当作二元运算符，把 <code>1</code> 作为单位元的时候，整数就形成了另一个群。</p>
<p>除了整数，还有很多数学结构是群。</p>
<h3 id="Semigroup"><a href="#Semigroup" class="headerlink" title="Semigroup"></a>Semigroup</h3><p>满足封闭性和结合律的群，称为半群（semigroup）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;&gt;: <span class="type">AdditionPrecedence</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> lhs + rhs</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Array, rhs: Array)</span></span> -&gt; <span class="type">Array</span> &#123;</div><div class="line">        <span class="keyword">return</span> lhs + rhs</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 折叠 fold</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;S: Semigroup&gt;<span class="params">(<span class="number">_</span> xs: [S], <span class="number">_</span> initial: S)</span></span> -&gt; <span class="type">S</span> &#123;</div><div class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(initial, &lt;&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>半群的结合律特性使得我们可以进行并行运算，<code>1 &lt;&gt; 2 &lt;&gt; 3 &lt;&gt; 4</code>。</p>
<h3 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h3><p>在抽象代数中，有一类简单的抽象结构被称为 Monoid（幺半群）。许多数学结构都是幺半群，因为成为幺半群的要求非常低。</p>
<p>存在单位元的半群，称为含幺半群，或者幺半群，或者单群，或者独异点（monoid）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Monoid</span>: <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Monoid</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e = <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Monoid</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Array</span> &#123;</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;M: Monoid&gt;<span class="params">(<span class="number">_</span> xs: [M])</span></span> -&gt; <span class="type">M</span> &#123;</div><div class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(<span class="type">M</span>.e, &lt;&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>concat</code> 是对 Monoid 的一种应用，它可以利用 Monoid 的定义（ 二元操作 <code>&lt;&gt;</code> 和 单位元 <code>e</code> ）进行折叠操作。</p>
<h2 id="Category-Theory"><a href="#Category-Theory" class="headerlink" title="Category Theory"></a>Category Theory</h2><blockquote>
<p>范畴论是数学的一门学科，以抽象的方法来处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。<a href="https://zh.wikipedia.org/wiki/范畴论" target="_blank" rel="external">wikipedia</a></p>
</blockquote>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>一个范畴 C 包括：</p>
<ul>
<li>一个由对象（object）组成的类 ob(C)。（注：这里把“物件”成为“对象“更有助于从计算机的角度理解</li>
<li>对象间态射（morphism，-&gt;）组成的类 hom(C)：每个态射 f 都只有一个「源对象」a 以及一个「目标对象」b（其中 a,b 都在 ob(C) 内），称之为 <strong>从 a 到 b 的态射</strong>，记为 f: a-&gt;b。（注：identity 态射即自己映射到自己的特殊态射，f: a-&gt;a，简单记为 id[a]）</li>
<li>一个二元运算符（·），用于态射组合，如 h=g·f。</li>
</ul>
<p>满足公理：</p>
<ul>
<li>结合律：f: a-&gt;b, g: b-&gt;c, h: c-&gt;d，h·(g·f) = (h·g)·f。</li>
<li>单位元：id[a]·f = id[b]·f = f。</li>
<li>封闭性：f: a-&gt;b, g: b-&gt;c, h: a-&gt;c, h = f·g。</li>
</ul>
<p>范畴举例：</p>
<ul>
<li>范畴 C 有 Int 类型和 String 类型对象。</li>
<li>存在态射 f: Int-&gt;String。</li>
</ul>
<p>划重点：幺半群可以视为一类特殊的范畴。幺半群运算满足的公理同于范畴中 <strong>从一个对象到自身的态射</strong>。换言之：<br>幺半群实质上是只有单个对象的范畴。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><blockquote>
<p>在范畴论中，函子是范畴间的一类映射。函子也可以解释为小范畴为成员的范畴内的态射。 <a href="https://zh.wikipedia.org/wiki/函子" target="_blank" rel="external">wikipedia</a></p>
</blockquote>
<p>在当代数学中，函子被用来描述各种范畴间的关系。对范畴论者来说，函子则是个特别类型的函数。</p>
<p>设 C 和 D 为范畴，从 C 至 D 的函子为一映射 F:</p>
<ul>
<li>将每个对象 x∈C 映射至一对象 F(x)∈D 上。</li>
<li>将每个态射 f: x-&gt;y∈C 映射至一态射 F(f): F(x)-&gt;F(y)∈D 上，</li>
</ul>
<p>使之满足：</p>
<ul>
<li>对任何对象 x∈C，恒有 F(id[x]) = id[F(x)]。</li>
<li>对任何态射 f: x-&gt;y, g: y-&gt;z，恒有 F(f·g) = F(f)·F(g)。</li>
</ul>
<p>换言之，函子会保持单位态射与态射的复合。<br>一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
<h4 id="可以把范畴当作一组类型的集合"><a href="#可以把范畴当作一组类型的集合" class="headerlink" title="可以把范畴当作一组类型的集合"></a>可以把范畴当作一组类型的集合</h4><p>如范畴 C 有 <code>Int</code> 类型和 <code>String</code> 类型对象，以及 <code>Int -&gt; String</code> 的态射；范畴 D 有 <code>Array&lt;Int&gt;</code> 类型和 <code>Array&lt;String&gt;</code> 类型对象，以及 <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code> 的态射。两个范畴之间的映射 F：</p>
<ul>
<li><code>Int</code> 映射至 <code>Array&lt;Int&gt;</code> 上，<code>String</code> 映射至 <code>Array&lt;String&gt;</code> 上。</li>
<li>态射 <code>Int -&gt; String</code> 映射至 <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code> 上。</li>
</ul>
<p>翻译成代码：C: <code>Int</code>, <code>String</code>, f: <code>Int -&gt; String</code>, D: <code>Array&lt;Int&gt;</code>, <code>Array&lt;String&gt;</code>, f: <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code>。</p>
<ul>
<li>x: <code>Int</code> -&gt; F(x): <code>Array&lt;Int&gt;</code>，<code>String</code> -&gt; F(x): <code>Array&lt;String&gt;</code></li>
<li>f: <code>(Int -&gt; String)</code> -&gt; F(f): <code>(Array&lt;Int&gt; -&gt; Array&lt;String&gt;)</code></li>
</ul>
<p>范畴是不涉及具体类型的，所以用泛型表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tmap</span>&lt;T&gt;<span class="params">(x: T)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">T</span>&gt;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmap</span>&lt;A, B&gt;<span class="params">(f: A -&gt; B)</span></span> -&gt; (<span class="type">F</span>&lt;<span class="type">A</span>&gt; -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;)</div></pre></td></tr></table></figure>
<p>简化一下变成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 中把 Int 映射到 Array&lt;Int&gt; 由 Array 的初始化方法提供，</span></div><div class="line"><span class="comment">// 所以可以不写。</span></div><div class="line"><span class="comment">// 由于 fmap 实际上是 (F&lt;A&gt;, A -&gt; B) -&gt; F&lt;B&gt; 的 currying 版本，</span></div><div class="line"><span class="comment">// 所以两者是等价的。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;, f: A -&gt; B)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</div></pre></td></tr></table></figure>
<p>再来看看 Swift 中的 <code>Array</code> 和 <code>Optional</code>。如果把 Swift 中所有的类型 <code>A, B</code> 当作对象，以及 Swift 中所有的函数当作态射 <code>A -&gt; B</code>，那么这些类型和函数就组成一个范畴 A。把 <code>Array</code> 类型当作对象 <code>Array&lt;A&gt;, Array&lt;B&gt;</code>，<code>Array</code> 上所有的函数当作态射 <code>Array&lt;A&gt; -&gt; Array&lt;B&gt;</code>，那么也组成一个范畴 B。而 A 到 B 之间的函子是 <code>Array</code>，因为函子 <code>Array</code> 能将任意类型 <code>T</code> 转换为 <code>Array&lt;T&gt;</code>。<code>Optional</code> 同理。</p>
<p>很多库对 <code>Functor</code> 的支持直接在类型构造器（Type Constructor）的定义中实现 <code>map</code> 方法，比如 Swift 中的 <code>Array</code> 和 <code>Optional</code> 就是需要一个泛型作为参数来构建具体类型的类型构造器，它在定义中实现了 <code>map</code> 方法。这些类型构造器相当于同时具备了类型和函数的映射。在 Haskell 里把这个行为称为 <code>Lift</code>，相当于把类型和函数放到容器里面。所以一个带有 <code>map</code> 方法的类型构造器就是一个函子。</p>
<p>范畴与高阶类型：如果忽略范畴中的态射，范畴其实就是对特定类型的抽象，即高阶类型（类型构造器）。对于范畴 D，它的所有类型都是 <code>Array&lt;T&gt;</code> 的特定类型。而对于范畴 C，可以看作是一个 Identity 类型的构造器（id[T] = T）。</p>
<p>注意⚠️：函子不是容器，函子不是容器，函子不是容器。<br>如 <code>typealias Parser&lt;A&gt; = (String) -&gt; (A, String)?</code> 我们可以实现 <code>func map&lt;A, B&gt;(x: Parser&lt;A&gt;, f: (A) -&gt; B) -&gt; Parser&lt;B&gt;</code> 函数，所以我们可以说 <code>Parser&lt;A&gt;</code> 是一个函子，但它不是容器。</p>
<h3 id="Endofunctor"><a href="#Endofunctor" class="headerlink" title="Endofunctor"></a>Endofunctor</h3><blockquote>
<p>A functor that maps a category to itself。一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
</blockquote>
<p>先看自函数的概念：将一个类型映射到自身类型，如 <code>Int -&gt; Int</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</div></pre></td></tr></table></figure>
<p>单位函数（Identity Function）的概念：什么都不做，传入什么就返回什么。属于自函数的特例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">id</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x &#125;</div></pre></td></tr></table></figure>
<p><strong>自函子不是单位函子（Identity Functor）</strong>。还是上面的范畴 C，为了区分自函子和单位函子，多加一种态射 g: <code>String -&gt; Int</code>，那么：</p>
<p>自函子：对于函子 F，对于 <code>F(Int)</code> 结果是 <code>String</code>，<code>F(String)</code> 结果是 <code>Int</code>，对于 <code>F(f: Int -&gt; String)</code> 结果是 g: <code>String -&gt; Int</code>。那么这个函子就是自函子。</p>
<p>单位函子（Identity Functor）：对于函子 F，对于 <code>F(Int)</code> 结果还是 <code>Int</code>，对于 <code>F(String)</code> 结果还是 <code>String</code>，对于 <code>F(f: Int -&gt; String)</code> 结果还是 <code>f: Int -&gt; String</code>，对于 <code>F(g: String -&gt; Int)</code> 结果还是 g: <code>String -&gt; Int</code>。那么这个函子就是单位函子。 </p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><blockquote>
<p>An applicative is a monoid in the category of endofunctors, what’s the problem?</p>
</blockquote>
<p>虽然在 Haskell 中 Monad 是 Applicative 的一种，但是 Applicative 的出现却在 Monad 之后。</p>
<p><a href="https://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/" target="_blank" rel="external">Applicative</a></p>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><blockquote>
<p>A monad is a monoid in the category of endofunctors – Philip Wadler</p>
</blockquote>
<p>自函子说穿了就是把一个范畴映射到自身的函子，自函子范畴说穿了就是从小范畴映射到自身的函子所构成的以自函子为对象以自然变换为态射的范畴，幺半群说穿了就是只有单个对象的范畴，给定了一个幺半群则可构造出一个仅有单个对象的小范畴使其态射由幺半群的元素给出而合成由幺半群的运算给出，而单子说穿了就是自函子范畴上的这样一个幺半群。（这都不理解么亲连这种最基本的概念都不理解还学什么编程！</p>
<p>一系列 Endofunctor 组成的范畴，成为 <strong>自函子范畴</strong>。</p>
<ul>
<li>X 上的自函子：F：<code>X -&gt; X</code></li>
<li>单位自函子 id[X] 到函子 F 的自然转换：<code>id[X] -&gt; F</code> (pure</li>
<li>函子 F 的张量积 F⊗F 到函子 F 的自然转换：<code>F⊗F -&gt; F</code> (join</li>
</ul>
<p>代码表示：</p>
<ul>
<li><code>func unit&lt;T&gt;(x: T) -&gt; F&lt;T&gt; // x = id[x]</code> </li>
<li><code>func join&lt;T&gt;(a: F&lt;F&lt;T&gt;&gt;) -&gt; F&lt;T&gt;</code></li>
</ul>
<p>此处函子的张量积 ⊗ 可以看作为组合（Composition）；<br>注意结合 Monoidal Category 理解，<code>unit</code> 和 <code>join</code> 满足 Monoid 的定律，所有形成了 Monoid。</p>
<p>也就是说：单子（Monad）是自函子的 Monoidal 范畴上的一个幺半群，该 Monoidal 范畴的张量积（Tensor Product，⊗：F×F -&gt; F）是自函子的复合（Composition），单位元是 Id Functor。</p>
<p><code>bind</code> 或者说 <code>flatMap</code> 或者 <code>&gt;&gt;=</code> 其实等于 <code>map + join</code>。（见 <a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a> 中的 <code>stdlib/public/core/FlatMap.swift</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;=&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;, f: A -&gt; F&lt;B&gt;)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</div><div class="line"><span class="comment">// Currying 前的样子</span></div><div class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;=&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;)</span></span> -&gt; (f: <span class="type">A</span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Too much</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/28/parser-combinator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/28/parser-combinator/" itemprop="url">Parser Combinator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T16:50:04+08:00">
                2017-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</p>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>将一个数据流解析成结构化的数据的工具，我们称为解析器。比如我们需要将用户输入的表达式字符串解析成 AST，我们就可以使用解析器来达到我们的目的。</p>
<p><code>( 4 + 3  )</code> 就是一个表达式语句，它由字符 <code>(</code>  <code>4</code> <code>空格</code> <code>+</code> <code>3</code> 和 <code>)</code> 组成。我们可以将这个表达式解析成一种 <em>表达式树</em> (AST 的一种)。</p>
<p>所以我们的解析器简单的用一个函数来描述就是：<br><code>func parser(_ string: String) -&gt; AST</code></p>
<p>我们不是用正则表达式来解析输入的表达式字符串，为了得到表达式树里面的节点，我们需要一步步的解析，每次解析得到不同的节点。所以我们需要将解析器的定义变成解析成功的话，会返回结果值和剩下的字符串。</p>
<p><code>func parser(_ string: String) -&gt; (AST, String)</code></p>
<p>表达式树的节点都是一些 <code>4</code> <code>+</code> 这种不同类型的数据，所以为了表示解析 <code>4</code> 成功和解析 <code>+</code> 成功，我们的返回值可以定义为泛型。并且表达出解析失败的情况，我们可以使用可选值。最终解析器函数就变成了：</p>
<p><code>func parser&lt;T&gt;(_ string: String) -&gt; (T, String)?</code></p>
<p>所以解析第一个数字 4 的解析器函数为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">String</span>)? &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = string.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="type">Optional</span>.some((<span class="number">4</span>, <span class="type">String</span>(string.characters.<span class="built_in">dropFirst</span>())))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Combinator"><a href="#Combinator" class="headerlink" title="Combinator"></a>Combinator</h2><blockquote>
<p>One of the distinguishing features of functional programming is the widespread use of combinators to construct programs. <em>A combinator is a function which builds program fragments from program fragments</em>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. – John Hughes</p>
</blockquote>
<p>其实 Combinator 很容易理解，就像字面意思那样 —— 组合子。首先定义一系列原子操作，然后定义组合的规则，然后根据组合的规则把这些原子操作组合起来。</p>
<h2 id="Parser-Combinator"><a href="#Parser-Combinator" class="headerlink" title="Parser Combinator"></a>Parser Combinator</h2><p>回到开头的话：<em>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</em> 所以我们需要重新定义一下我们的解析器，把它变成一个解析组合子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">let</span> parse: (<span class="type">String</span>) -&gt; (<span class="type">A</span>, <span class="type">String</span>)?</div><div class="line">    <span class="comment">// (input) -&gt; (result, remaining)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个解析字符串的解析器，我们把这个函数放到一个结构体 <code>Parser</code> 中，作为一个 <code>parse</code> 变量。当然我们也可以用类型别名 <code>typealias Parser&lt;Result&gt; = (String) -&gt; (Result, String)?</code>。</p>
<p>当然解析组合子不仅仅能解析字符串，所以可以用泛型来把它变得更通用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">let</span> parse: (<span class="type">I</span>) -&gt; (<span class="type">O</span>, <span class="type">I</span>)?</div><div class="line">    <span class="comment">// (input) -&gt; (output, remaining input)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以解析数字字符 <code>4</code> 的解析器就变成了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">character4</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="string">"4"</span>, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以根据 <code>func character4() -&gt; Parser&lt;Character&gt;</code> 很容易得到一个能够解析任何字符的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">character</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == character <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 的区别，很容易又得到能够解析任何数字的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">digit</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, <span class="string">"0"</span>...<span class="string">"9"</span> ~= head <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 相同和不同，我们可以进一步抽象，把相同部分进行封装，把不同部分作为参数，得到新的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">satisfy</span><span class="params">(<span class="number">_</span> condition: @escaping <span class="params">(Character)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, condition(head) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以解析数字：</p>
<p><code>(satisfy { &quot;0&quot;...&quot;9&quot; ~= $0 }).parse(&quot;1abc&quot;)</code></p>
<p>解析空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSpace</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">String</span>(character).trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines).isEmpty</div><div class="line">&#125;</div><div class="line">(satisfy(isSpace)).parse(<span class="string">" abc"</span>)</div></pre></td></tr></table></figure>
<p>所以我们只需要给 <code>satisfy</code> 函数传入一个是否属于 X 的函数，就可以得到一个能够解析 x 的解析器。</p>
<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>最基本的 <code>character</code> 有了，<code>digit</code> 有了，当我们需要解析一个字符串 <code>alex</code> 的时候，我们只需要把 <code>alex</code> 看成 <code>a</code> <code>l</code> <code>e</code> <code>x</code> 4 个字符，然后不断的用 <code>character</code> 进行解析，最后把每一步返回的结果合并起来就行了。考虑到解析一个字符串是一个基本功能，为了不用每次写重复的代码，把它封装成用来解析 <code>string</code> 的解析器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> parsers = str.characters.<span class="built_in">map</span> &#123; character($<span class="number">0</span>) &#125;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">for</span> parser <span class="keyword">in</span> parsers &#123;</div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = parser.parse(stream) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">            &#125;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="type">String</span>(results), stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察 parse 函数类型 <code>(String) -&gt; (A, String)</code>，解析成功的返回值是解析结果和 <strong>剩余</strong> 的字符串，所以解析 <code>alex</code> 的时候：</p>
<ol>
<li>“alex”: ‘a’ -&gt; (‘a’, “lex”)</li>
<li>“lex”: ‘l’ -&gt; (‘l’, “ex”)</li>
<li>“ex”: ‘e’ -&gt; (‘e’, “x”)</li>
<li>“x”: ‘x’ -&gt; (‘x’, “”)</li>
<li>Parser&lt;”alex”&gt;</li>
</ol>
<p>可以看到这几步做的事情除了参数不一样，内部逻辑是一样的，而且很容易看出是一个递归的过程，<strong>每次解析成功就 <code>吃掉</code> 第一个字符</strong>（留意这句话），然后解析剩下的字符串。</p>
<p>所以我们写一个递归的版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 0. 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 1. 先解析第一个字符</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = character(head).parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. 然后解析剩下的所有</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder2) = string1(<span class="type">String</span>(tail)).parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. 返回("结果", "剩余的字符串")</span></div><div class="line">        <span class="keyword">return</span> (str, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncons</span>&lt;C: Collection&gt;<span class="params">(<span class="number">_</span> xs: C)</span></span> -&gt; (<span class="type">C</span>.<span class="type">Iterator</span>.<span class="type">Element</span>, <span class="type">C</span>.<span class="type">SubSequence</span>)? &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = xs.first <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (head, xs.suffix(from: xs.index(after: xs.startIndex)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察 1 和 2，在这两步中，我们都没有使用解析的 <strong>结果</strong>，这两步实现的仅仅是 <strong>每次解析成功就 <code>吃掉</code> 结果</strong>！最后在第 3 步一次将结果返回。也就是说我们 1 和 2 这两本并不关心结果，只关心这些要解析道字符存在就行了。</p>
<p>我们把解析成功吃掉结果这一步封装一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只保留右边的解析器的结果 result2，没有 result1</span></div><div class="line">        <span class="keyword">return</span> (result2, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>discarding</code> 函数会 <strong>吃掉</strong> 左边第一个参数 <code>x</code> 的解析结果，返回值中只保留右边 <code>y</code> 的解析结果。用 <code>discarding</code> 函数重写一下上面的 <code>string</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 1 吃掉 character(head) 的结果</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder) = discarding(character(head), string2(<span class="type">String</span>(tail))).parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2 返回 ("结果", "剩余的字符串")</span></div><div class="line">        <span class="keyword">return</span> (str, remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次改版的 <code>string</code> 里面第 1 步中的解析结果还是被忽略了，所以是否可以继续用 <code>discarding</code> 来简化？但是 <code>discarding</code> 函数需要两个解析器，但函数内只有 <code>lift</code> 返回的一个解析器，所以没办法继续简化了？</p>
<p>仔细看 <code>string</code> 函数体的第一行 <code>return Parser {}</code> 就是一个解析器，能否把这个解析器利用上呢？<code>discarding</code> 是在 <code>Parser {}</code> 里面的，所以只要能想办法把它展平，那么就能再次利用上 <code>lift</code>，而且展平后的解析器需要做为 <code>string</code> 函数的返回值，所以它肯定是做为 <code>discarding</code> 的右边的参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> lhs = <span class="type">Parser</span> &#123;&#125;</div><div class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;&#125;</div><div class="line">    <span class="keyword">return</span> lift(x, y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据第 2 步的 <code>return (str, remainder)</code> 可以知道，最终的返回结果是 <code>(输入的，lhs 吃剩的)</code>，所以很容易得到 <code>let rhs = Parser&lt;String&gt; { (str, $0) }</code>。所以可以推出 lhs 要做的只是负责吃掉一部分。也就是上面的第 1 步所做的。所以：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">        <span class="keyword">return</span> (<span class="string">""</span>, input)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2 吃掉</span></div><div class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</div><div class="line">    <span class="comment">// 3 结果和剩下的</span></div><div class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</div><div class="line">    <span class="comment">// 4 返回</span></div><div class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的返回值是 <code>Parser</code>，由于外面没有 Parser {} ，展开后 1 那里需要返回一个 <code>Parser</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">        <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (<span class="string">""</span>, $<span class="number">0</span>) &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>明眼人可以看到 1 和 3 只有 <code>&quot;&quot;</code> 和 <code>str</code> 不一样，剩下的一模一样，虽然代码不长，但我们还是把它相同部分封装成一个函数，然后把不同的部分做为参赛。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">        <span class="keyword">return</span> pure(<span class="string">""</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    <span class="keyword">let</span> rhs = pure(str)</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Lift a value</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pure</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: A)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123; (x, $<span class="number">0</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以封装一个简洁的 <code>string</code> 解析器，花了很多功夫，但抛开性能，它比迭代的版本更简洁易懂。</p>
<h2 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h2><p>观察表达式 <code>( 4 + 3  )</code>，里面 <code>(</code> 和 <code>4</code> 之间有 1 个空格，数字 <code>3</code> 和 <code>)</code> 中间是有 2 个空格，在做加法运算的时候，这些 <em>many</em> 个空格是没有意义的，所以需要 <em>skip</em> 掉。</p>
<h4 id="Many"><a href="#Many" class="headerlink" title="Many"></a>Many</h4><p>首先需要解析空格的解析器，前面已经有实现过：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">space</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> satisfy(isSpace)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于空格数量未知，可能有 <em>many</em> 个，假如有一个解析器，能够解析 <em>many</em> 个 parser。用一个 loop 不断去解析就能实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">many</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">var</span> results: [<span class="type">A</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (results, stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任意个空格就是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many(space())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>spaces</code> 得到的是一个 <code>Parser&lt;[Character]&gt;</code> 类型的 parser，但是按照理解更希望得到一个 <code>Parser&lt;String&gt;</code> 类型的 parser。在 Swift 中，<code>String([Character])</code> 就能够将 <code>[Character]</code> 拍扁成 <code>String</code> 类型。所以把 <code>many</code> 稍微修改一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">many</span>&lt;Character&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;Character&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="type">String</span>(results), stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为不是任何泛型 A 类型，都能用 String 拍扁，也不一定能通过其他类型进行拍扁，所以这里把泛型 A 去掉，直接用 Character 代替。但是这样做并不理想，因为 <code>many</code> 解析器从一个泛型解析器，变成了一个只能解析 Character 类型的解析器，变成了 <code>manyCharacter</code>。后面考虑解析这个问题，重新把 <code>many</code> 变成通用的解析器。</p>
<h4 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h4><p>接着实现一个通用的 <code>skip</code> 解析器，它要做的事情很简单，输入什么吃掉什么，返回剩下的，和上面吃掉左边的 <code>discarding</code> 很像，不一样的是 <code>skip</code> 只有一个参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">skip</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Void</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> ((), input)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> ((), remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把 <code>skip</code> 和 <code>spaces</code> 进行组合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">skipSpaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Void</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> skip(spaces)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Many1"><a href="#Many1" class="headerlink" title="Many1"></a>Many1</h4><p>前面实现的 <code>digit</code> 解析器，它只能解析个位数，这是没有什么卵用的。相比 <code>digit</code>，更加需要的是一个 <code>number</code> 解析器。一个 <em>number</em> 实际上也是由 <em>many</em> 个 <em>digit</em> 组成。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many(digit())</div><div class="line">&#125;</div><div class="line"></div><div class="line">number().parse(<span class="string">"123abc"</span>) <span class="comment">// (["1", "2", "3"], "abc")</span></div><div class="line">number().parse(<span class="string">"abc"</span>) <span class="comment">// ([], "abc")</span></div></pre></td></tr></table></figure>
<p>等等！<code>number().parse(&quot;abc&quot;)</code> 也解析成功了，结果是空数组。这并不是想要的结果，一个 <em>string</em> 可以是空的，<em>space</em> 甚至也可以是空的，但一个 <em>number</em> 不能是空的。所以需要另外一个只是有一个的 <code>many</code>。这其实很常见，比如正则表达式中有 <code>*</code> 和 <code>+</code>，一个 {0, +} 一个是 {1, +}。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">many1</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="comment">// 多加一个判断，第一个值必须满足条件</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> results: [<span class="type">A</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (results, stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以正确的 <code>number</code> 解析器就变成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many1(digit())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>number</code> 解析器和 <code>spaces</code> 解析器遇到了同样的问题，<code>number</code> 解析器的结果应该是 <code>Int</code>（暂不考虑浮点数），而不是 <code>[Character]</code>。解决方法可以类似 <code>manyCharacter</code>，但是这显示是很有问题的，抽象抽象抽象！</p>
<p>程序员要有抽象思维，要学会用更高的层次的思维去看待问题，发现不同问题的共同点。<code>[Character]</code> 可以用 <code>String([Character])</code> 变成一个 <code>String</code>。对于 <code>digit</code> character，同样的也是用 <code>String([Character])</code> 拍扁，然后用 <code>Int(String)</code> 得到一个 <code>number</code>。</p>
<p>结合 Swift 的 OOP（面向协议编程），可以定义一个协议，暂且叫做 <code>Combinable</code> :D</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Combinable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">Self</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Combinable</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Int</span>(<span class="type">String</span>(describing: xs))!</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">Combinable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: xs)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">many1</span>&lt;A: Combinable&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;Character&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="type">A</span>.combine(results), stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就可以得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many1(digit())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many1(space()) <span class="comment">// 忽略 spaces 可以为空的情况</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上 <code>skipSpaces</code> 还可以用另外一个角度来拆分，上面先解析 <em>many</em> 个空格，然后一次 <em>skip</em> 掉。还可以每次 <em>skip</em> 一个空格，然后进行 <em>many</em> 次。不同的地方是 <code>skip</code> 和 <code>many</code> 两个 parser 的调用次序不一样，甚至还可以定义一个叫做 <code>skipMany</code> 的解析器，这也说明了 <strong>Combinator</strong> 的强大。通过定义一系列基础的 parser，进行不同的排列组合操作，最后覆盖所有的 case。（理想状态</p>
<h4 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h4><p>合并两个 parser 的解析器 <code>zip</code> 的实现也很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">zip</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;(<span class="type">A</span>, <span class="type">B</span>)&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ((result1, result2), remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Choice"><a href="#Choice" class="headerlink" title="Choice"></a>Choice</h4><p>接下来还需要解析几个简单的一元运算符 <code>+</code> <code>-</code> <code>*</code> <code>/</code>。去掉空格后，两个数中间必须是其中一个运算符那么表达式就是合法的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">opt</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> opts = [<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>].<span class="built_in">map</span> &#123; character($<span class="number">0</span>.characters.first!) &#125;</div><div class="line">    <span class="keyword">return</span> choice(opts)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 也可以叫 one(of:)</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice</span>&lt;A, S: Sequence&gt;<span class="params">(<span class="number">_</span> xs: S)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(empty(), &#123; $<span class="number">0</span> &lt;|&gt; $<span class="number">1</span> &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span>&lt;A&gt;<span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">nil</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>上面利用 Protocol 实现的 <code>number</code> 和 <code>space</code> 解析器其实并不是很优雅，费了很大劲把 <code>many</code> 变得 <del>通用</del>，结果却并不是很 <strong>通用</strong>，因为要求结果的类型必须实现 <code>Combinable</code> 协议。但它做的工作却很少，只是把传入的 <code>Parser&lt;A&gt;</code> 循环解析得到的结果 <code>[A]</code> 在 <code>many</code> <strong>内部</strong> 组合成最终的类型，实现把 <code>Parser&lt;[A]</code> 转换为 <code>Parser&lt;B&gt;</code>。正由于它是在 <code>many</code> 内部做的操作，所以依赖于传入的类型，使得 <code>many</code> 不再那么通用。</p>
<p>再看 <code>func character(_ character: Character) -&gt; Parser&lt;Character&gt;</code> 的定义，假如调用 <code>character(&quot;4&quot;)</code>，那么返回的是一个 <code>Parser&lt;Character&gt;</code> 类型的解析器，这个解析器调用 <code>parse</code> 方法，返回的结果是 <code>Character</code> 类型的值。在解析表达式 <code>4 + 3</code> 的时候，需要将解析到的 <code>4</code> 和 <code>3</code> 当作一个整数然后相加，才能得到最终的结果，所以不想要 <code>Character</code> 类型的值，而是想要 <code>Int</code> 类型的值，那么需要将 <code>Parser&lt;Character&gt;</code> 转换为 <code>Parser&lt;Int&gt;</code> 解析器。</p>
<p>所以，假如能实现一个函数，可以将任意 <code>Parser&lt;A&gt;</code> 转换为 <code>Parser&lt;B&gt;</code> 解析器，就完美了。<code>many</code> 只负责将 <code>Parser&lt;A&gt;</code> 解析得到 <code>Parser&lt;[A]&gt;</code>，然后由 <code>number</code> 自己将 <code>Parser&lt;[A]&gt;</code> 转换为 <code>Parser&lt;Int&gt;</code>。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><p>回忆 Swift 中 Optional 类型中的 map 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt; = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> b: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = a.<span class="built_in">map</span> &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</div></pre></td></tr></table></figure>
<p>它将一个 <code>Optional&lt;Int&gt;</code> 转换为 <code>Optional&lt;String&gt;</code>，仔细一看，把 <code>Optional</code> 换成 <code>Parser</code>，就是我们所需要的转换解析器的方法。</p>
<p><code>Optional</code> 的函数签名是 <code>func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; U?</code>，所以依葫芦画瓢，我们可以得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;B&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = <span class="keyword">self</span>.parse(input) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">            <span class="keyword">return</span> (transform(result), remainder)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像上面的 <code>satisfy</code> 和其他函数一样，把 <code>map</code> 方法从结构图内移出来，则得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: @escaping <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = x.parse(input)<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (f(result), remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于值是在 <code>Parser</code> 中包裹着的，想把返回的 <code>Parser&lt;Character</code> 变成 <code>Parser&lt;Int&gt;</code>，需要把 <code>Parser&lt;Character&gt;</code> 解开取出里面<character>的值，然后把它变成<int>类型，然后重现包装起来。对于不同的类型转换，解包重新包装的步骤是一样的，不同的地方是把结果从一种类型变成另一种类型，函数的作用就是把相同的封装起来，把不同做为参赛传进去，所以在 <code>map</code> 函数的实现中，只需要在返回前，给外部将这个结果进行一次转换机会，所以需要一个参赛，能够将解开后得到的值变成另一种类型的值，也就是提供一个函数 <code>(Character) -&gt; Int</code>。</int></character></p>
<p>重新实现 <code>number</code> 和 <code>spaces</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(many1(digit()), &#123; <span class="type">Int</span>(<span class="type">String</span>($<span class="number">0</span>))! &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(many(space()), &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种不同的结构体 <code>Optional&lt;T&gt;</code> 和 <code>Parser&lt;A&gt;</code>，都可以给它实现一个 <code>map</code> 方法，使得它变成一个不同类型的结构体。而支持这种 <code>map</code> 方法的结构体，我们称把它为 <code>Functor</code>。</p>
<blockquote>
<p>简单来说，所谓的 <code>Functor</code> 就是可以把一个函数应用于一个 <strong>封装过的值</strong> 上，得到一个新的 <strong>封装过的值</strong></p>
</blockquote>
<p><code>Functor</code> 最早出自于代数拓扑，这里说的 <code>Functor</code> 一般是指范畴论（Category Theory）中的 <code>Functor</code>，它被用来描述各种范畴间的关系。更多 Functor 的理解 <a href="http://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">Group Theory and Category Theory</a>。</p>
<h3 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pure</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: A)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123; (x, $<span class="number">0</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上前面的 <code>pure</code> 和 <code>discarding</code> 函数就是一种 Applicative。像 <code>discarding</code> 一样有时候只关心这些要解析道字符存在就行了，上面定义的 <code>discarding</code> 解析器作用是忽略第一个 parser 参数的解析结果，同样地，可以定义一个忽略第二个 parser 参数的解析器。比如当解析出现在右边的 symbol 的时候就很有用，<code>discarding2(parser, string(&quot;)&quot;))</code> 的作用就是确保存在闭合的右括号 “)”。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 吃掉右边的结果</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding2</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只保留左边的解析器的结果 result1，没有 result2</span></div><div class="line">        <span class="keyword">return</span> (result1, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 吃掉左边的结果</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding1</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只保留右边的解析器的结果 result2，没有 result1</span></div><div class="line">        <span class="keyword">return</span> (result2, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个 <code>discarding</code> 函数长的很像，如果有办法把它们抽象一下，把相似的地方提取出来就好了。</p>
<p>对于两个结果，忽略其中一个，实际上很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 忽略 B</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">A</span> &#123;</div><div class="line">    <span class="keyword">return</span> a</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 忽略 A</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">B</span> &#123;</div><div class="line">    <span class="keyword">return</span> b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 吃掉左边的结果</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">left</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">discarding</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">A</span> &#123;</div><div class="line">        <span class="keyword">return</span> b</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (discarding(result1, result2), remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后这个函数并没有卵用。</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>观看 <code>map</code> 函数 <code>func map&lt;A, B&gt;(_ x: Parser&lt;A&gt;, _ f: (A) -&gt; B) -&gt; Parser&lt;B&gt;</code></p>
<p>它要求传入两个参数，一个是 <code>Parser&lt;A&gt;</code>，一个是函数 <code>A -&gt; B</code>，第二个参数对标题中的 <strong>Combinator</strong> 并不是很友好，<strong>Parser Combinator</strong> 的思想是组合一系列的 <code>Parser</code> 得到结果。上面定义了有很多小的 parser，比如 <code>func string(_ str: String) -&gt; Parser&lt;String&gt;</code>，函数签名是 <code>(String) -&gt; Parser&lt;String&gt;</code>，由于 <code>map</code> 函数的第二个参数的签名是 <code>(A) -&gt; B</code>，而非 <code>(A) -&gt; Parser&lt;B&gt;</code>，所以假如存在一个与 <code>map</code> 功能相似，但第二个参数的签名是 <code>(A) -&gt; Parser&lt;B&gt;</code>，则能够使得之前定义的很多小的 <code>parser</code> 能够直接作为一个参数，直接得到一个新类型的 <code>Parser</code>，大概这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: <span class="params">(A)</span></span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;</div></pre></td></tr></table></figure>
<p>使用的时候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> parser = flatMap(stringParser, string(<span class="string">"alex"</span>))</div></pre></td></tr></table></figure>
<p>具体实现与 <code>map</code> 也很像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: @escaping <span class="params">(A)</span></span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = x.parse(input)<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> f(result).parse(remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">Group Theory and Category Theory</a></p>
<h3 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span>&lt;A&gt;<span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">nil</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">return</span> x.parse(input) ?? y.parse(input)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Alternative 类似于 <code>Swift Standard Library</code> 中定义的运算符 <code>??</code>，它有两个同类型的参数，第一个参数是偏爱的 <code>parser</code>，第二个参数是默认的 <code>parser</code>。它首先尝试使用第一个 <code>parser</code> 来进行解析，如果成功，则返回。如果不成功，则使用默认的 <code>parser</code> 进行解析。它的返回值类型也是同类型的 <code>Parser</code>。</p>
<p>作用是假如有 Int, String, Bool 三个类型的 <code>parser</code>，而一个 scalar 类型的 <code>parser</code> 只要能够解析 Int, String, Bool 任意一种类型，则算解析成功。换句话说就是 scalar 是 Int, String, Bool 的父集。一种简单的从 <code>Parser&lt;Int&gt;</code>, <code>Parser&lt;String&gt;</code>, <code>Parser&lt;Bool&gt;</code> 三种已有实现的 parser 得到 <code>Parser&lt;Scalar&gt;</code> 的方法是逐个进行 parse，如果成功则马上返回。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> scalar = parserInt &lt;|&gt; parserString &lt;|&gt; parserBool</div></pre></td></tr></table></figure>
<p>从这个例子看有点 one of 的意思，但实际上更加准确的说法是 choice。</p>
<h3 id="Applicative-amp-Monad"><a href="#Applicative-amp-Monad" class="headerlink" title="Applicative &amp; Monad"></a>Applicative &amp; Monad</h3><p>Applicative 和 Monad 的区别在于：</p>
<p>Applicative 的两个 parser 是相互独立的，组合后的新 parser 是可以静态分析其行为的。而对于 Monad，在不知道输入的情况下，是不能确定其行为，也就是说 Monad 是依赖于计算结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">alex</span><span class="params">(<span class="number">_</span> x: Parser&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(<span class="string">"alex.huo"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> af: <span class="type">Parser</span>&lt;(<span class="type">String</span>) -&gt; <span class="type">String</span>&gt; = pure(id)</div><div class="line"><span class="keyword">let</span> ax = string(<span class="string">"alex"</span>)</div><div class="line">alex(af &lt;*&gt; ax) <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> mf: (<span class="type">String</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; = &#123; string($<span class="number">0</span>) &#125;</div><div class="line"><span class="keyword">let</span> mx = string(<span class="string">"alex"</span>)</div><div class="line">alex(mx &gt;&gt;- mf) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/hlian/jiffy" target="_blank" rel="external">Jiffy</a><br><a href="https://news.realm.io/news/tryswift-yasuhiro-inami-parser-combinator/" target="_blank" rel="external">Parser combinators</a><br><a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf" target="_blank" rel="external">Monadic Parser Combinators</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/20/cherry-blessing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/cherry-blessing/" itemprop="url">Cherry Blessing</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T12:37:36+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to Cherry Blessing.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Xspyhack" />
          <p class="site-author-name" itemprop="name">Xspyhack</p>
           
              <p class="site-description motion-element" itemprop="description">Why join the navy if you can be a pirate?</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xspyhack</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
