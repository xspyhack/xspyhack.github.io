<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="Why join the navy if you can be a pirate?">
<meta property="og:type" content="website">
<meta property="og:title" content="Cherry Blessing">
<meta property="og:url" content="https://blessingsoft.com/index.html">
<meta property="og:site_name" content="Cherry Blessing">
<meta property="og:description" content="Why join the navy if you can be a pirate?">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cherry Blessing">
<meta name="twitter:description" content="Why join the navy if you can be a pirate?">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blessingsoft.com/">





  <title>Cherry Blessing</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cherry Blessing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">A monad is a monoid in the category of endofunctors</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2023/09/29/swiftui-coredata-tca/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/09/29/swiftui-coredata-tca/" itemprop="url">SwiftUI + CoreData + TCA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-09-29T20:00:00+08:00">
                2023-09-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swiftui/" itemprop="url" rel="index">
                    <span itemprop="name">swiftui</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Unidirectional Data Flow (<strong>UDF</strong>)</p>
<p><img src="../images/flow.png" alt="flow"></p>
<h2 id="CoreData"><a href="#CoreData" class="headerlink" title="CoreData"></a>CoreData</h2><p>官方推荐在 SwiftUI 中使用 Core Data 的方式是通过的  <code>FetchRequest</code> 来进行数据查询（一个专用的 <code>propertyWrapper</code>，底层对 <code>NSFetchRequest</code> 和 <code>NSFetchRequestController</code> 进行了封装），可以自定义 <code>Predicate</code> 和 <code>SortDescriptor</code>。系统会触发 fetch 和监听 change 并进行 UI 的刷新。</p>
<h3 id="CoreData-Model"><a href="#CoreData-Model" class="headerlink" title="CoreData Model"></a>CoreData Model</h3><p>Core Data 是 Obj-C 时期的产物，同时利用了一些 Obj-C 的运行时动态的特性（KVC/KVO），所以 Model 天然不支持 Immutable 类型。</p>
<p>但在普通的 SwiftUI 中，@Publish 修饰的属性 property 必须是 immutable 类型，否则无法知道属性发生了改变。</p>
<p>在 TCA 中，Immutable 非常重要。比如能够减少 View 的刷新提升性能。</p>
<h3 id="CoreData-ORM"><a href="#CoreData-ORM" class="headerlink" title="CoreData ORM"></a>CoreData ORM</h3><p>由于 Core Data 的复杂性，以及不支持 Immutable 的特性，对 SwiftUI 和 TCA 不够友好，直接将 Core Data Model 用于上层的 State 不是一个很好的选择。</p>
<p>一种方式是为每一个 Core Data Model 创建一个自己的 struct 类型的 Domain Model，手动的进行映射（Mapping）。但这种方式的缺点显然易见，需要写很多冗余代码，并且容易出错。</p>
<p>Core Data 本身就是 Obj-C 语言的 ORM，但却不是很好的 Swift ORM。<a href="https://github.com/prisma-ai/Sworm" target="_blank" rel="noopener">Prisma</a> 通过对 Core Data 进一步的抽象，提供一套新的 ORM 模型（主要也是利用了 Core Data 的运行时特性），Immutable, Type-safe，同时不损失大部分 Core Data 的优点。对比起手动 Mapping 也更简单。</p>
<ul>
<li>Attributes: 利用 Swift KeyPath 进行映射；</li>
<li>Relationships: 对关系进行描述；</li>
<li>Query: 对 NSFetchRequest 进一步封装，利用 KeyPath 获得类型安全。</li>
</ul>
<blockquote>
<p><a href="https://developer.apple.com/documentation/swiftdata" target="_blank" rel="noopener">SwiftData</a>，但依然是 class 类型，配合 Observable 使用。</p>
</blockquote>
<h2 id="TCA"><a href="#TCA" class="headerlink" title="TCA"></a>TCA</h2><h3 id="Single-Source-of-Truth"><a href="#Single-Source-of-Truth" class="headerlink" title="Single Source of Truth"></a>Single Source of Truth</h3><p>TCA （包括普通的 SwiftUI）强调的是单一可信数据源，所有的 State 统一管理起来，形成一棵（或多颗）状态数。而使用 <code>@FetchRequest</code> 进行访问的 Core Data 数据，没法在 TCA 中进行管理，散落在各个 View 中。</p>
<p>对于一个主要数据流是 CoreData 的 app 来说，使用 <code>@FetchRequest</code> 的话就没有什么必要再使用 TCA 了。（TCA 依然有很多好用的其他特性可以帮助我们更好的驾驭 SwiftUI，特别是一些独立成库的工具如 Dependence）</p>
<h3 id="Global-State-Scope-State"><a href="#Global-State-Scope-State" class="headerlink" title="Global State / Scope State"></a>Global State / Scope State</h3><p>TCA 管理的这颗状态树，如果每一个 View / Feature 都能访问和修改的话，那么管理起来就会很麻烦。而且对于模块化来说会很不友好，因为会存在双向的依赖。</p>
<p>同样对于性能来说，如果 State 的所有变化，所有的 View 都需要重新计算刷新的话，将会对性能造成非常大的浪费和影响。</p>
<p>为了解决这个问题，需要一些手段来对 State 进行拆分，把它变成单向的依赖关系。在 TCA 中 Scope 的概念，加上一些 pullback （也叫 lift）的手段。同时通过引入 ViewStore 来解决 Observe Scope 切片的问题。</p>
<h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><p>TCA 中还有一个很重要的概念：<strong>Composable</strong>。</p>
<p>包括 State Composition 和 Reducer Composition。</p>
<p>State Composition 体现于 App State 这颗状态树的定义。而 App State 其实也影响着 Reducer 是怎么定义，因为 State, Action, Reducer 一般是成套配置的。</p>
<h3 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h3><p>对于 Reducer 来说，同样的输入需要得到相同的输出。所以需要把不确定的东西（包括调用环境等）作为 Dependency 来管理，也就是说通过控制 Dependency 来保证 Reducer 的纯函数的要求。</p>
<p>假如一个 State 的值每次初始化都不是一样的，那么这个 State 就不适合作为 State 来使用，而应该作为 Dependency 来使用。</p>
<p>如果一个 State 需要在不同的 View / Feature 中共享，比如：不同页面都需要显示某个 State，并且部分页面可以修改这个 State，修改后所有页面都需要进行更新。对于这类的 State，更适合把它作为 Dependency 来使用。</p>
<h2 id="TCA-CoreData"><a href="#TCA-CoreData" class="headerlink" title="TCA + CoreData"></a>TCA + CoreData</h2><p>TCA + Core Data 这个组合由于历史原因（所以才有了 SwiftData）没法天然的很好配合使用，比如最重要的 Data Flow 状态管理问题。还有一些问题是由于不直接使用 Core Data 而引入的新问题，有一些是 SwiftUI + Core Data 本身就有的问题或者说 Core Data 本身的问题。</p>
<p>新的 SwiftData 能解决很多 SwiftUI + Core Data 中的问题，但目前看到的大多数特性对于 TCA 来说并没有什么帮助，或许等 TCA 支持 Observable 后会有改变。</p>
<h3 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h3><p>自己实现一个类似的 FetchRequest 作为 Dependency，然后在 Reducer 中进行调用。这个 FetchRequest 对 <code>NSFetchRequestController</code> 进行封装，然后利用 <code>NSFetchRequestControllerDelegate</code> 中进行数据的监听，并且在数据发生变化时把数据更新回调到 Reducer 中。</p>
<p>因为 Core Data 是支持 Relationship 的，所以理想的情况 Core Data 的数据结构 Entity 也是一棵树。这样是不是能通过监听树根，来知道一整颗树的所有的变化呢？然后把 Core Data 的数据结构和 TCA 的数据结构进行对应，这样就能实现 Core Data 的数据变化，直接映射到 TCA 的 State 上了。</p>
<p>但理想归理想，现实情况是，首先 Core Data 并不能监听到 Relationship 对象的变化，只能监听到自己的属性的变化，所以这个方案行不通[^1]；其次，TCA 践行的是 Immutable 的 State，所有的 State 的变化，都应该是可以有迹可循的，不同 Reducer 之间的 State 的变化，是主动的通过 Action 来进行更新的，而不是通过监听的方式。举例来说就是 Child 页面是某一个时刻从 Parent 中通过 Scope 来拆分出来的，是一个 Immutable 的 State，所以 Parent 页面的 State 的变化，是不会影响到 Child 页面的 State 的，也就是在根 Reducer 监听 Core Data 树的变化，没有办法实时更新到所有的子节点的 State 上，也就没法实时刷新页面。</p>
<p>对于 Relationship 变化的监听，也可以通过监听 <code>NSManagedObjectContext.didChangeObjectsNotification</code> 和 <code>NSManagedObjectContext.didSaveObjectsNotification</code>，然后通过对比判断变化的对象是否属于当前 Fetched Object 的 Relationship 来进行判断[^1]。这一种方案的缺点在于没有强类型的支持[^2]，同时现实的 Relationship 可能会比较复杂，可以是 one-to-one, one-to-many, many-to-many，还可以是多层的嵌套，这样的话，对比的逻辑就会比较复杂，怎么样的颗粒度才是合适的呢？如果所有的 Object 是一颗树状，那么是否意味着每一个 Object 的变化，会导致所有父节点的 Object 都被动变化，所谓牵一发而动全身。需要监听根节点的变化，等于所有的变化，这样的话，性能就是一个问题了。并且这种方式是不是相等于直接监听通知无脑刷新页面就好了。</p>
<h3 id="KeyPath"><a href="#KeyPath" class="headerlink" title="KeyPath"></a>KeyPath</h3><p>Swift 中的 Value Type 也支持 KeyPath，但是和 Core Data 的 KeyPath 不是同一个东西，并且没有办法直接转换，因为 Swift struct 的 KeyPath 是静态的类型安全的，而 Core Data 的 KeyPath 是动态的利用了 NSObject 的运行时特性的。所以在设计接口的时候没法直接使用 KeyPath 来作为 predicate 的参数，这样会缺失很多便捷性。</p>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>Core Data 有很多的性能优化，上述的方案会导致一部分的性能优化不起作用，比如 Fault 特性。懒加载在大量数据的时候对性能的提升还是很有帮助的。除此之外，包括使用 <code>fetchLimit</code> 来实现分页加载；通过 <code>predicate</code> 来过滤非必要的数据，不要一次把所有的对象查询出来。</p>
<h2 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h2><p>在 <a href="https://www.fatbobman.com/posts/modern-Core-Data-Data-definition/" target="_blank" rel="noopener">SwiftUI 与 Core Data —— 数据定义</a> 这篇博客中的 <code>AnyConvertibleValueObservableObject</code> 和 Prisma 中的 <code>AnyConvertibleValue</code> 类似，都是对 Core Data 的 <code>NSManagedObject</code> 进行了不同形式的 Mapping 抽象。相比起来 Prisma 是一套更加成熟的方案，抽象程度更高。</p>
<p>而 <a href="https://www.fatbobman.com/posts/modern-Core-Data-fetcher/" target="_blank" rel="noopener">SwiftUI 与 Core Data —— 数据获取</a> 中的 <code>MockableFetchRequest</code>，更像是自己实现一套 <code>@FetchRequest</code> propertyWrapper，同样是直接在 View 中使用，但是可以方便进行 Mock 数据。和 <code>FetchRequestObserver</code>[^2] 相比多了方便 Mock，但是缺少了 Observer 的功能。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>SwiftUI + Core Data + TCA 这个组合，在目前来说还是比较不友好的，没办法既要…又要…。所以只能通过自己实现一些辅助工具来进行转换和抽象，但抽象就意味着对原有功能接口进行限制，随着功能逻辑的增加，这部分的接口就需要不断的进行扩展，这样的话，就会导致这个抽象越来越难，甚至一整套接口没法满足后来的需求而面临着重新设计重构。</p>
<p>同时由于没有直接使用 Core Data 的托管对象，而是转换成了一套 struct 类型的 Model，导致一些 Core Data 的性能优化没法享用。</p>
<p>但现在也不是没法用，可以结合实际情况来通过一些手段先解决比较重要的点。</p>
<p>[^1]: <a href="https://www.avanderlee.com/swift/nsfetchedresultscontroller-observe-relationship-changes/" target="_blank" rel="noopener">NSFetchedResultsController extension to observe relationship changes</a><br>[^2]<a href="https://github.com/xspyhack/Alfheim/blob/master/Underworld/Sources/Persistence/FetchRequestObserver.swift" target="_blank" rel="noopener">FetchRequestObserver</a></p>
<p><a href="https://www.merowing.info/the-composable-architecture-best-practices/" target="_blank" rel="noopener">The Composable Architecture - Best Practices</a><br><a href="https://github.com/pointfreeco/swift-composable-architecture/discussions/1898" target="_blank" rel="noopener">Working with a common state throughout the app</a><br><a href="https://onevcat.com/2021/12/tca-1/" target="_blank" rel="noopener">TCA - SwiftUI 的救星？(一)</a><br><a href="https://www.fatbobman.com/posts/the_Composable_Architecture/" target="_blank" rel="noopener">聊一聊可组装框架（ TCA ）</a><br><a href="https://www.fatbobman.com/posts/modern-Core-Data-fetcher/" target="_blank" rel="noopener">SwiftUI 与 Core Data —— 数据获取</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2022/07/16/silgen-name/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/16/silgen-name/" itemprop="url">silgen name</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-16T20:00:00+08:00">
                2022-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在设计 <code>Router</code> 组件的时候，其中必不可少的一步是路由注册，将 <code>pattern</code> 和 <code>handler</code> 函数进行绑定。</p>
</blockquote>
<h2 id="使用-silgen-name-来进行注册"><a href="#使用-silgen-name-来进行注册" class="headerlink" title="使用 @_silgen_name 来进行注册"></a>使用 @_silgen_name 来进行注册</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@_silgen_name(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">user</span><span class="params">(context: Context)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="什么是-silgen-name"><a href="#什么是-silgen-name" class="headerlink" title="什么是 @silgen_name"></a>什么是 @silgen_name</h3><p>根据 Swift 的官方手册，<code>@silgen_name</code> 有两个作用：</p>
<blockquote>
<ol>
<li>To specify the symbol name of a Swift function so that it can be called from Swift-aware C. Such functions have bodies.</li>
<li>To provide a Swift declaration which really represents a C declaration. Such functions do not have bodies.<br><a href="https://github.com/apple/swift/blob/main/docs/StandardLibraryProgrammersManual.md#_silgen_name" target="_blank" rel="noopener">swift/StandardLibraryProgrammersManual.md</a></li>
</ol>
</blockquote>
<p>所以可以利用第2个特性给 <code>handler</code> 函数指定一个导出函数符号 <code>Exported Symbols</code>，然后通过将 <code>pattern</code> 作为导出符号即可绑定对应的 <code>handler</code> 函数。</p>
<p>同时为了避免与其它导出符号冲突并且提高查找的效率，可以给导出符号加一个约定的前缀，如 <code>ditto:</code>。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>运行时利用 <code>_dyld_register_func_for_add_image()</code> 来监听所有的 <code>image</code> 加载，然后遍历带特定前缀的导出函数符号。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_dyld_register_func_for_add_image &#123; image, slide <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> mhp = image?.withMemoryRebound(to: <span class="type">MachHeader</span>.<span class="keyword">self</span>, capacity: <span class="number">1</span>, &#123; $<span class="number">0</span> &#125;)</span><br><span class="line">    <span class="keyword">let</span> symbols = getDyldRouteSymbols(<span class="keyword">prefix</span>: <span class="string">"ditto:"</span>, image: mhp!, slide: slide)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过 <code>unsafeBitCast(_:to:)</code> 函数将函数符号转为 <code>handler</code> 函数进行注册。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> routes: [(<span class="type">String</span>, <span class="type">Route</span>&lt;<span class="type">Coordinator</span>&gt;.<span class="type">Handler</span>)] = symbols</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span>.key.hasPrefix(<span class="string">"ditto:"</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; (<span class="type">String</span>($<span class="number">0</span>.key.<span class="built_in">dropFirst</span>(<span class="string">"ditto:"</span>.<span class="built_in">count</span>)), <span class="built_in">unsafeBitCast</span>($<span class="number">0</span>.value, to: <span class="type">Handler</span>.<span class="keyword">self</span>)) &#125;</span><br><span class="line"><span class="keyword">try</span>? register(routes)</span><br></pre></td></tr></table></figure>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p><a href="https://github.com/xspyhack/Ditto" target="_blank" rel="noopener">Ditto</a> 在设计之初便支持范型，并且可以同时存在多个 <code>Router</code>（虽然没太必要）。</p>
<h3 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h3><p><code>_dyld_register_func_for_add_image()</code> 是一个 <code>C</code> 函数，支持传入一个回调函数指针作为参数，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dyld_register_func_for_add_image(<span class="keyword">void</span> (*func)(<span class="keyword">const</span> struct mach_header* mh, <span class="keyword">intptr_t</span> vmaddr_slide));</span><br></pre></td></tr></table></figure>
<p>回调函数并不同于一般的 <code>closure</code>，它不能捕获上下文信息：<code>A C function pointer cannot be formed from a closure that captures context</code>。所以对于支持范型的 <code>Router</code> 来说，就不能直接的调用这个函数。</p>
<p>所以我们需要用过一些其他手段先把遍历到的函数符号先存起来，再重新读取出来即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SIL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> symbols: [<span class="type">UnsafeMutableRawPointer?</span>] = []</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">SIL</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _dyld_register_func_for_add_image &#123; image, slide <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> mhp = image?.withMemoryRebound(to: <span class="type">MachHeader</span>.<span class="keyword">self</span>, capacity: <span class="number">1</span>, &#123; $<span class="number">0</span> &#125;)</span><br><span class="line">            <span class="keyword">let</span> symbols = getDyldRouteSymbols(image: mhp!, slide: slide)</span><br><span class="line">            <span class="type">SIL</span>.shared.symbols.append(contentsOf: symbols)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Handler</span> = <span class="meta">@convention</span>(thin) (<span class="type">Context</span>&lt;<span class="type">Coordinator</span>&gt;) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">SIL</span>.install()</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.register(symbols: <span class="type">SIL</span>.shared.symbols)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(symbols: [UnsafeMutableRawPointer?])</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> routes: [(<span class="type">String</span>, <span class="type">Route</span>&lt;<span class="type">Coordinator</span>&gt;.<span class="type">Handler</span>)] = symbols</span><br><span class="line">            .<span class="built_in">map</span> &#123; (<span class="type">String</span>($<span class="number">0</span>.key), <span class="built_in">unsafeBitCast</span>($<span class="number">0</span>.value, to: <span class="type">Handler</span>.<span class="keyword">self</span>)) &#125;</span><br><span class="line">        <span class="keyword">try</span>? register(routes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>假如同时存在多个 <code>Router</code> 的话，那么只靠 <code>pattern</code> 无法区分要注册到哪一个。同时由于 <code>_dyld_register_func_for_add_image()</code> 函数无法捕获上下文，也无法传递指定的 <code>silgen_name</code> 前缀来进行分开遍历。</p>
<p>一个可行但并不优雅的方法依然是在 <code>silgen_name</code> 的命名中做文章，如约定特殊的前缀来进行区分。</p>
<p>如果不同的 <code>Router</code> 是在不同的模块中（<code>module</code>），那么可以通过遍历指定的 <code>image</code> （通过 <code>_dyld_get_image_name()</code> 方法）来注册当前模块的符号。</p>
<p><a href="https://github.com/apple/swift/blob/main/docs/StandardLibraryProgrammersManual.md#_silgen_name" target="_blank" rel="noopener">swift/StandardLibraryProgrammersManual.md</a><br><a href="https://forums.swift.org/t/should-anyone-be-using-silgen-name-outside-of-the-standard-library-developers/19396/23" target="_blank" rel="noopener">Should anyone be using @_silgen_name outside of the standard library developers?</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2022/01/01/some-any/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/01/some-any/" itemprop="url">some P and any P</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-01T20:00:00+08:00">
                2022-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li><code>some</code> 是另一种特殊的 <code>generic</code>（符合要求的未知但具体的类型）。它的目的是用来对复杂的类型进行抽象，类型的信息不会被擦除。</li>
<li><code>any</code> 其实是显式的声明 <code>existential</code>。它的目的是用来对值进行抽象，类型信息会被 compiler 擦除。</li>
</ul>
<h2 id="some-Protocol"><a href="#some-Protocol" class="headerlink" title="some Protocol"></a>some Protocol</h2><p>写过 SwiftUI 的人对于 <code>some</code> 都不陌生，每一个 <code>View</code> 的 <code>body</code> 的类型都是 <code>some View</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么需要引进一个新的关键词 <code>some</code>，不能直接写 <code>var body: View { ... }</code>？原因是 <code>View</code> 这个协议是经典的 <em>PAT</em>，对就是那个万恶之源 <a href="https://blessingsoft.com/2018/08/26/pats/">PAT</a> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Body</span> : <span class="type">View</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">Self</span>.<span class="type">Body</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>PAT</code> 不能直接的把 <code>View</code> 当作一个类型来使用，<code>Protocol ‘View’ can only be used as generic constraint because it has Self or associated type requirements</code>。<code>View</code> 这个 <code>PAT</code> 没法自动生成一个 <a href="https://blessingsoft.com/2019/06/05/existential/">Existential</a>，所以不能直接写 <code>var body: View { ... }</code>，必须明确指定 <code>View</code> 的具体类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="comment">// typealias Body = Text</span></span><br><span class="line">  <span class="keyword">var</span> body: <span class="type">Text</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明确 <code>Body</code> 的具体类型，有助于揭示 <code>ContentView</code> 的部分实现，同时也使得声明变得脆弱。如果想改变 <code>body</code> 的返回类型，必须同时修改对应的类型。在这个场景中，具体的 <code>body</code> 返回类型其实并不重要，重要的是它符合 <code>View</code> 协议，它是一个 <code>View</code>。这时候如果想要抽象出声明的返回值类型，就必须要考虑 <code>existential</code> 或者 <code>type erasure</code>。</p>
<p>基于这一点，Swift 5.1 中引入了 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md" target="_blank" rel="noopener">SE-0244 opaque result types</a> 这一特性。<code>some Protocol</code> 表示一个确定的实现了 <code>Protocol</code> 协议的类型。同时它还有一个要求，就是 <code>some</code> 修饰 return type 的时候，要求所有的 return 语句返回相同的具体类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> : <span class="title">P</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> : <span class="title">P</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(flip: Bool)</span></span> -&gt; some <span class="type">P</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> flip &#123; <span class="keyword">return</span> <span class="number">17</span> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"a string"</span> <span class="comment">// error: different return types Int and String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个支持范型的语言中，想使用 <code>PAT</code> 又不需要指定具体的类型对于编写简洁代码非常重要。考虑一下嵌套的范型，如 SwiftUI 中那些 View 的 body 的真实类型。</p>
<blockquote>
<p>当然，<code>some</code> 只是在编写代码的时候帮助我们进行了简化，类型信息依然存在，<code>SwiftUI</code> 非常依赖这些信息进行 View 的更新。</p>
</blockquote>
<h2 id="any-Protocol"><a href="#any-Protocol" class="headerlink" title="any Protocol"></a>any Protocol</h2><p>Swift 中想要把一个 <code>Protocol</code> 作为一个类型来用，要求这个 <code>Protocol</code> 必须不能是 <code>PAT</code>，否则的话就会报错 <code>Protocol can only be used as generic constraint because it has Self or associated type requirements</code>。为了缓解这个问题，Swift 引入了 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md" target="_blank" rel="noopener">SE-0309 unlock existential types for all protocols</a>，compiler 帮忙自动的进行 <code>type erasure</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Logging</span>: <span class="title">Hashtable</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// -func add(_ logger: AnyLogger) &#123;</span></span><br><span class="line"><span class="comment">// after, 🙂️ OK</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> logger: Logging)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，<code>PAT</code> 的使用成本大大的降低，实用性大大提升。终于可以像使用范型那样的使用 <code>PAT</code> 了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> logger: Logging)</span></span> &#123; ... &#125; <span class="comment">// existential type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>&lt;T: Logging&gt;<span class="params">(<span class="number">_</span> logger: T)</span></span> &#123; ... &#125; <span class="comment">// generic type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logger: <span class="type">MemoryLogger</span></span><br><span class="line">add(logger)</span><br></pre></td></tr></table></figure>
<p>但是 <code>generic type</code> 和 <code>existential type</code> 始终是不同的东西，前者是 <code>type-level abstraction</code> 而后者是 <code>value-level abstraction</code>，前者强调的是类型以及类型之间的关系，后者关心的是值，类型信息被 compiler 帮忙抹除掉。</p>
<p>为了从语法上区分开两者，Swift 又引入了 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0335-existential-any.md" target="_blank" rel="noopener">SE-0335 existential any</a>，<code>existential type</code> 必须通过 <code>any</code> 关键词进行显式声明 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logger: <span class="type">Logging</span> = <span class="type">MemoryLogger</span>() <span class="comment">// before</span></span><br><span class="line"><span class="keyword">let</span> logger: any <span class="type">Logging</span> = <span class="type">MemoryLogger</span>() <span class="comment">// after</span></span><br></pre></td></tr></table></figure>
<p>至此，终于可以一致的对待 Swift 中的所有 protocol 了，而不需要区别它是不是 PAT。</p>
<h2 id="Type-level-and-value-level-abstraction"><a href="#Type-level-and-value-level-abstraction" class="headerlink" title="Type-level and value-level abstraction"></a>Type-level and value-level abstraction</h2><p>要深入了解 <code>some</code> 和 <code>any</code>，还是要先了解什么是 <code>type-level abstraction</code> 和 <code>value-level abstraction</code> 。</p>
<h3 id="Type-level-abstraction"><a href="#Type-level-abstraction" class="headerlink" title="Type-level abstraction"></a>Type-level abstraction</h3><p>Generics（范型）提供了类型层面上的抽象，范型允许函数或者类型与符合给定约束集的任何类型统一使用，同时保留了在任何特定实例中使用的特定类型的标识。泛型函数引入了代表特定类型的类型变量（type variables，感觉更多时候被叫做类型参数？）。 这允许函数声明它接受任何符合协议的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>&lt;T: Collection&gt;<span class="params">(x: T)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>类型变量 <code>T</code> 在类型层面上抽象出特定的 <code>Collection</code> 类型。具体的类型标识仍然保留着，因此类型系统可以保留不同值之间的类型关系。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span>&lt;T: Collection&gt;<span class="params">(x: T, y: T)</span></span> -&gt; [<span class="type">T</span>] &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Value-level-abstraction"><a href="#Value-level-abstraction" class="headerlink" title="Value-level abstraction"></a>Value-level abstraction</h3><p>Existential 类型提供了值层面上的抽象。与绑定一些符合约束的现有类型的泛型类型参数相比，existential 类型是一种不同的类型，它可以保存符合一组约束的任何类型的任何值，在值层面上抽象底层的具体类型。Existentials 允许不同的具体类型的值作为相同的存在类型的值互换使用，在值层面上抽象了底层符合类型之间的差异。同一个 existential 类型的不同实例可以持有完全不同的底层类型的值，并且改变一个 existential 类型可以改变该值所持有的底层类型。</p>
<h3 id="Type-level-abstraction-is-missing-for-function-returns"><a href="#Type-level-abstraction-is-missing-for-function-returns" class="headerlink" title="Type-level abstraction is missing for function returns"></a>Type-level abstraction is missing for function returns</h3><p>泛型是 Swift 在函数接口中进行类型层面的抽象的工具，但它们的工作方式基本上在调用者的控制之下，也就是说具体类型由调用方来决定。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zim</span>&lt;T: P&gt;<span class="params">()</span></span> -&gt; <span class="type">T</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>zim</code> 这个范型函数，具体返回的类型 <code>T</code>，是由调用方来决定，实现方（callee）只声明了它必须要满足 <code>P</code> 约束。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">Int</span> = zim() <span class="comment">// T == Int chosen by caller</span></span><br><span class="line"><span class="keyword">let</span> y: <span class="type">String</span> = zim() <span class="comment">// T == String chosen by caller</span></span><br></pre></td></tr></table></figure>
<h3 id="“Reverse-generics”-for-return-type-abstraction"><a href="#“Reverse-generics”-for-return-type-abstraction" class="headerlink" title="“Reverse generics” for return type abstraction"></a>“Reverse generics” for return type abstraction</h3><p>但有时候，实现方真正希望的 <code>zim</code> 函数是它返回一个 <code>P</code> 类型，但具体是 <code>Int</code> 还是 <code>String</code> 由实现方来决定。这点与普通的范型刚刚相反，可以认为是反向的范型（<code>reverse generics</code>）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zim</span><span class="params">()</span></span> -&gt; <span class="type">P</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>此时的 <code>P</code> 不再是用来作为范型约束，<code>zim</code> 函数返回的值是一个 existential。 </p>
<h3 id="Expressing-constraints-directly-on-arguments-and-returns"><a href="#Expressing-constraints-directly-on-arguments-and-returns" class="headerlink" title="Expressing constraints directly on arguments and returns"></a>Expressing constraints directly on arguments and returns</h3><p>为了完善 Swift 的类型抽象系统，提出了使用 <code>some</code> 这个修饰符来对参数和返回值表达约束，而不需要使用 <code>existential</code> 类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatenate</span><span class="params">(a: some Collection, b: some Collection)</span></span> -&gt; some <span class="type">Collection</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以使用 <code>where</code> 来表达它们直接的类型关系。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatenate</span><span class="params">(a: some Collection, b: some Collection)</span></span> -&gt; some <span class="type">Collection</span></span><br><span class="line">  <span class="keyword">where</span> type(of: a).<span class="type">Element</span> == type(of: b).<span class="type">Element</span>,</span><br><span class="line">        type(of: <span class="keyword">return</span>).<span class="type">Element</span> == type(of: b).<span class="type">Element</span></span><br></pre></td></tr></table></figure>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li><code>some</code> 是另一种特殊的 <code>generic</code>（符合要求的未知但具体的类型）。它的目的是用来对复杂的类型进行抽象，类型的信息不会被擦除。</li>
<li><code>any</code> 其实是显式的声明 <code>existential</code>。它的目的是用来对值进行抽象，类型信息会被 compiler 擦除。</li>
</ul>
<p><code>some</code> 和 <code>any</code> 是对偶的（<code>duals</code>）两个修饰词，它们都解决了 <code>PAT</code> 所带来的一些不方便的问题。目前 Swift 只支持使用 <code>some</code> 来修饰返回值，而 <code>any</code> 的使用场景则比较多。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md" target="_blank" rel="noopener">swift-evolution/0244-opaque-result-types.md at master · apple/swift-evolution · GitHub</a><br><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md" target="_blank" rel="noopener">swift-evolution/0309-unlock-existential-types-for-all-protocols.md at main · apple/swift-evolution · GitHub</a><br><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0335-existential-any.md" target="_blank" rel="noopener">swift-evolution/0335-existential-any.md at main · apple/swift-evolution · GitHub</a><br><a href="https://forums.swift.org/t/improving-the-ui-of-generics/22814#heading--clarifying-existentials" target="_blank" rel="noopener">Improving the UI of generics - Discussion - Swift Forums</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2019/06/05/existential/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/05/existential/" itemprop="url">∃ Existential</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-05T20:00:00+08:00">
                2019-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最初看到 <strong>existential</strong> 这个词，是在 <a href="http://www.russbishop.net/swift-associated-types-cont" target="_blank" rel="noopener">Swift Associated Types, cont.</a> 这篇文章中（第一次知道 <code>typealias Any = protocol&lt;&gt;</code> 也是在这篇文章），但当时并没有对这个陌生名称留下什么深刻印象。</p>
<p>后来陆陆续续应该也看到过一些，比如 <a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance - WWDC 2016</a>。</p>
<p>真正的想要去了解它，是之前写 <a href="http://blessingsoft.com/2018/08/26/pats/">PATs</a> 的时候，那时候 <strong>existential</strong> 这个词很高频的出现，甚至是和 PATs 息息相关，所以进行了一个初步的了解。</p>
<p>但是呢，只是片面的了解，而没有建立起立体的认识，记忆很快就会开始模糊，直到最后忘记掉。所以才有了这次的 <strong>existential</strong> 认知之旅。</p>
<blockquote>
<p>注：这篇大多数概念、观点、片段都来自于官方文档或者参考文章，小部分自己的认知理解，并且不保证理解的正确。</p>
</blockquote>
<h2 id="Existential-Type"><a href="#Existential-Type" class="headerlink" title="Existential Type"></a>Existential Type</h2><p>想理解 <strong>existential</strong>，必须要先了解 <strong>existential values</strong>, <strong>existential containers</strong> 和 <strong>witness tables</strong> 的概念。</p>
<p>在类型论中， <a href="https://en.wikipedia.org/wiki/Type_system#Existential_types" target="_blank" rel="noopener">existential type</a> 描述了抽象类型的接口。当对象的类型是 <code>protocol</code> 时，就会用到 <strong>existential type</strong>，因为存储或传递一个 <code>protocol</code> 类型的对象意味着对象在运行时的真实类型是不透明的（也就是编译期不可知的，因此我们也无法确定这类对象的布局）。</p>
<p>一个遵从了特定 <code>protocol</code> 的类型一定包含其约定的所有方法，但是这些方法的地址是无法在编译期确定的，因为我们只有在运行时，才能确定这个 <code>protocol</code> 对应的真实类型。这和 <code>non-final class</code> 引用是类似的（因为可能被 override），因此也使用了 <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md#method-dispatch" target="_blank" rel="noopener">类似的技术手段</a> 来解决。<code>Protocol</code> 中约定的每一个被实现的方法的地址，都被保存在 <strong>witness table</strong> 中。</p>
<h3 id="Existential-Value"><a href="#Existential-Value" class="headerlink" title="Existential Value"></a>Existential Value</h3><p>显然的，<strong>existential type</strong> 的值，就是 <strong>existential value</strong>。:P</p>
<h3 id="Existential-Container"><a href="#Existential-Container" class="headerlink" title="Existential Container"></a>Existential Container</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foos: [<span class="type">Foo</span>] = ... <span class="comment">// What's the memory storage looks like?</span></span><br></pre></td></tr></table></figure>
<p>简单来说 <strong>existential of a protocol</strong> 就是一个编译器生成的盒子 box，用来存放遵从这个 <code>protocol</code> 的值，这个盒子，也叫做 <strong>Existential Container</strong>，盒子里面的东西，就叫做 <strong>witness</strong>。</p>
<p>关于 <strong>existential container</strong> 的内存布局，这些值怎么存储，要分几种情况来说。因为值类型和引用类型的处理方式不一样，值比较小和比较大也可以为了性能用不同的策略。<a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance - WWDC 2016</a> 和 <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" target="_blank" rel="noopener">ABIStabilityManifesto · GitHub</a> 中都有详细的描述。</p>
<p>简单来说就是 5 个字节的大小，前三个连续的字节叫做 <em>value buffer</em>，用来存放对象的值或者指针。值类型如果放得下，就直接内联放在 <em>value buffer</em> 里面，如果放不下，就在存放在堆上，把指针地址存放在 <em>value buffer</em> 里；引用类型直接放指针。<br>第四个字节存放 <code>vwt</code> (<em>value witness table</em>) 指针。<br>第五个字节存放 <code>pwt</code> (<em>protocol witness table</em>) 指针。</p>
<p>对于那些限定了只能是 <code>class</code> 实现的 <code>protocol</code>，<code>containers</code> 中则会忽略 <code>vwt</code> 指针（因为对象自身包含指向自己类型信息的指针）以及多余的内连 buffer。并且，这里还有一个特例 <code>Any</code>，由于它没有遵从任何 <code>protocol</code>，因此 <code>Any</code> 对象的 <code>containers</code> 中没有 <em>witness table</em> 指针。（没错，<code>Any</code> 也是一个 <strong>existential</strong> ！即使 Swift 3 之后把 <code>Any</code> 当作了 keyword，但估计和之前的 <code>protocol &lt;&gt;</code> 差不多的实现，所以依然是 <strong>existential</strong> 。）</p>
<h3 id="VWT"><a href="#VWT" class="headerlink" title="VWT"></a>VWT</h3><p>每一个具体类型（concrete type）都有一张 <em>value witness table</em>，用来存放这个类型的有关内存布局和操作它的值的信息。当一个值类型具有不透明布局的时候，因为值编译的时候没办法知道实际类型，所以只能通过查询这个表来知道这些有关信息（metadata）。</p>
<h3 id="PWT"><a href="#PWT" class="headerlink" title="PWT"></a>PWT</h3><p><em>Protocol witness table</em> 是 <code>protocol</code> 接口的一张函数表。如果有 associated type，它还会存储 associated type 的 metadata。</p>
<blockquote>
<p>所以什么是 <strong>existential</strong> 是什么？就是一个 <code>protocol</code> 类型的值。</p>
</blockquote>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>当一个 <code>protocol</code> 作为类型而不是具体的类型约束的时候，它就是一个 <strong>existential</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span>&lt;T: Foo&gt;<span class="params">(<span class="number">_</span> foo: T)</span></span> &#123;&#125; <span class="comment">// This requires a concrete T that conforms to Foo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">baz</span><span class="params">(<span class="number">_</span> foo: Foo)</span></span> &#123;&#125; <span class="comment">// This requires a variable of type Foo (pedantically: "a Foo existential")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo: <span class="type">Foo</span> = ... <span class="comment">// existential of protocol `Foo`</span></span><br><span class="line">bar(foo) <span class="comment">// 😢 Protocol type 'Foo' cannot conform to 'Foo' because only concrete types can conform to protocols</span></span><br><span class="line">baz(foo) <span class="comment">// 😊</span></span><br></pre></td></tr></table></figure>
<p>所以当看到 “a protocol doesn’t conform to itself” 的时候，它实际上是指 “the existential of a protocol doesn’t conform to that protocol”。 </p>
<h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p><strong>Existentials</strong> 不是真正的泛型（<code>generic</code>），但由于它们相互依赖于 <code>protocol</code>，这两个系统紧密地交织在一起。</p>
<blockquote>
<p>While protocols create existential (“there exists”) types, generics create universal (“for all”) types. </p>
</blockquote>
<p>先回顾一下泛型的一些常见概念：</p>
<ul>
<li>泛型函数 <code>func swap&lt;T&gt;(_ a: inout T, _ b: inout T)</code></li>
<li>类型参数 <code>&lt;T&gt;</code></li>
<li>泛型类型 <code>Queue&lt;T&gt;</code></li>
<li>类型约束 <code>&lt;T: Protocol, U: Class&gt;</code></li>
<li>关联类型 <code>associatedtype T</code></li>
<li>泛型从句 <code>func foo&lt;T: P, U: P&gt;(_ a: T, _ b: T) where T: Equatable, T.Item == U.Item</code></li>
</ul>
<p>当使用泛型作为类型约束的时候，会涉及到 <strong>existentials</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span>&lt;T: Foo&gt;<span class="params">(<span class="number">_</span> foo: T)</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo: <span class="type">Foo</span> = ...</span><br><span class="line">bar(foo) <span class="comment">// Protocol type 'Foo' cannot conform to 'Foo' because only concrete types can conform to protocols</span></span><br></pre></td></tr></table></figure>
<h2 id="PATs"><a href="#PATs" class="headerlink" title="PATs"></a>PATs</h2><p>既然有 <strong>existentials</strong> 了，那为什么还需要 <strong>type eraser</strong> 呢？</p>
<p>先回过头来看看之前在 <a href="http://blessingsoft.com/2018/08/26/pats/">PATs</a> 中遇到的几个问题。</p>
<blockquote>
<p>Protocol ‘Caching’ can only be used as generic constraint because it has Self or associated type requirements</p>
</blockquote>
<p>它的意思是，<code>Caching</code>  这个 PATs 没有（无法自动生成）一个 <strong>existential</strong>.</p>
<blockquote>
<p>Using ‘Logging’ as a concrete type conforming to protocol ‘Hashable’ is no supported</p>
</blockquote>
<p>它的意思是，这个 <code>Logging</code> 的 <strong>existential</strong> 没有实现 <code>Hashable</code> 这个协议。</p>
<p>为什么无法为 PATs 生成一个 <strong>existential</strong> 呢？实际上是可以的，但它很复杂。它可以通过一种叫做 <strong>generalized existentials</strong> 的技术，生成一个 <strong>implicit existential</strong>。即使这样，它还有很多问题需要解决。</p>
<p>对于 <strong>existential</strong> 的自动生成，首先 <strong>existential</strong> 是运行时的（泛型 <code>generic</code> 是编译时的），它是通过在运行时，把 <code>protocol</code> 的一些信息存放在 <strong>existential container</strong> 里面。当 <code>protocol</code> 里面存在有 <em>associated types</em> 或者有 <code>Self</code> 约束的时候，它没办法针对任意类型（Any）自动生成填充这个 <strong>existential container</strong>。（Swift 是静态语言，对于泛型需要在编译时就进行泛型特化，<strong>generic specialization</strong>，除非把泛型当作是 <code>Any</code> 来处理。还有一种方式就是对 PATs 进行约束，<code>let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>，也就是 <code>AnySequence&lt;String&gt;</code> ）</p>
<p>理解这一点非常重要，可能会有点晕，再来捋一下。首先编译器把存储或者传递的  <code>protocol</code> 类型，先替换成 <code>existential container</code>（生成代码），然后再编译成目标代码。当编译器发现这个 <code>protocol</code> 是 PATs 时，它如果不通过 <em>generic specialization</em> 的话，无法生成不带泛型的代码。那为什么说 <strong>existential</strong> 是运行时的呢？因为存储或传递一个 <code>protocol</code> 类型的对象意味着对象在运行时的真实类型是不透明的（也就是编译期不可知的，因此我们也无法确定这类对象的布局）。</p>
<p>还有一些类型是不适合自动生成 <strong>existential</strong> 的，编译器没法满足有 <code>init</code> 和 <code>static</code> 的要求。比如 <code>Decodable</code> 这样的没有实例方法的协议，<strong>existential</strong> 没有任何意义。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span>: <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(<span class="number">_</span> decodable: Decodable)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> decodable: <span class="type">Decodable</span> = <span class="type">Model</span>(x: <span class="string">"x"</span>)</span><br><span class="line">decode(decodable)</span><br><span class="line"><span class="comment">// 上面对代码编译起来没有任何问题，也就是能自动生成 *existential*</span></span><br><span class="line"><span class="comment">// 但对于 decode(_:) 函数，根本无从下手，因为 Decoder 需要的是一个遵守 Decodable 协议的类型，而不是值。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(<span class="number">_</span> type: Decodable.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> decodable = <span class="type">JSONDecoder</span>().decode(type, from: data)</span><br><span class="line">    <span class="comment">// let decodable = JSONDecoder().decode(Decodable.self, from: data)</span></span><br><span class="line">    <span class="comment">// Protocol type 'Decodable' cannot conform to 'Decodable' because only concrete types can conform to protocols</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终还是那个 `Protocol type 'Decodable' cannot conform to 'Decodable' because only concrete types can conform to protocols`</span></span><br></pre></td></tr></table></figure>
<p>其实 <strong>type eraser</strong> 和 <strong>existentials</strong> 这两种是对偶的（ duals ），泛型（ generic ）的 <code>Any&lt;T&gt;</code> 等同于 协议（ protocol ）的一种 <strong>explicit existential</strong>。</p>
<h2 id="Existential-in-Other-Language"><a href="#Existential-in-Other-Language" class="headerlink" title="Existential in Other Language"></a>Existential in Other Language</h2><h3 id="Existential-type-in-Java"><a href="#Existential-type-in-Java" class="headerlink" title="Existential type in Java"></a>Existential type in Java</h3><p>Java 泛型中的 <strong>Wildcards</strong> 其实就是一种 existential type，比如 <code>java.util.List&lt;?&gt;</code>。</p>
<p>在 Java 中由于有<a href="h">类型擦除</a> 的存在，泛型的参数类型信息在运行时会丢失，在运行时无法根据已知的类型信息区分 <code>List[Int]</code> 和 <code>List[String]</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List foo = <span class="keyword">new</span> ArrayList();</span><br><span class="line">foo.add(<span class="string">"foo"</span>);</span><br><span class="line">foo.get(<span class="number">0</span>); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<p>当没有给出类型参数的时候，通过使用 existential 来解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;</span><br><span class="line">List&lt;? extends Number&gt;</span><br><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Existential-type-in-Kotlin"><a href="#Existential-type-in-Kotlin" class="headerlink" title="Existential type in Kotlin"></a>Existential type in Kotlin</h3><p>Kotlin 中没有 <strong>existential type</strong>。它有一个概念叫着 <strong>The Existential</strong> 的概念。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dogBar: Bar&lt;Dog&gt; = Bar()</span><br><span class="line"><span class="keyword">var</span> animalBar: Bar&lt;Animal&gt; = dogBar <span class="comment">// 😢</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dogBar: Bar&lt;Dog&gt; = Bar()</span><br><span class="line"><span class="keyword">var</span> animalBar: Bar&lt;Animal&gt; = dogBar <span class="comment">// 😊</span></span><br></pre></td></tr></table></figure>
<h3 id="Existential-type-in-Scala"><a href="#Existential-type-in-Scala" class="headerlink" title="Existential type in Scala"></a>Existential type in Scala</h3><p><code>ArrayList() == List[]</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Trait</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(seq: <span class="type">Seq</span>[<span class="type">String</span>]): <span class="type">Seq</span>[<span class="type">String</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(seq: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">Seq</span>[<span class="type">Int</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error, have the same type after erasure</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span>[_] <span class="comment">// List[T] forSome &#123; type T &#125;</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[+<span class="type">T</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="Existential-type-in-Rust"><a href="#Existential-type-in-Rust" class="headerlink" title="Existential type in Rust"></a>Existential type in Rust</h3><p> <code>fn foo() -&gt; impl Trait</code></p>
<p>核心在于 <code>impl Trait</code>，和 Swift 5.1 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md" target="_blank" rel="noopener">Opaque Result Types</a> 中的 <code>func foo() -&gt; some P</code> 一样。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><strong>Existential</strong> 是什么？<strong>Existential</strong> 就是 <code>protocol</code> 类型的值。这是编译层面相关的概念，平时写代码不需要知道它意味着什么或者是什么，只需要知道它会跟你想象中一样 work 就行了。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://www.russbishop.net/swift-associated-types-cont" target="_blank" rel="noopener">Swift Associated Types, cont. - Russ Bishop</a><br><a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" target="_blank" rel="noopener">ABIStabilityManifesto · GitHub</a><br><a href="https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md" target="_blank" rel="noopener">GenericsManifesto · GitHub</a><br><a href="https://forums.swift.org/t/improving-the-ui-of-generics/22814" target="_blank" rel="noopener">Improving the UI of generics - Swift Forums</a><br><a href="http://robnapier.net/existential-spelling" target="_blank" rel="noopener">Protocols III: Existential Spelling - Cocoaphony</a><br><a href="https://en.wikipedia.org/wiki/Type_system#Existential_types" target="_blank" rel="noopener">Existential types - Wikipedia</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance - WWDC 2016</a><br><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md" target="_blank" rel="noopener">0244-opaque-result-types - GitHub</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2018/11/19/from-result-to-error-handling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/from-result-to-error-handling/" itemprop="url">From Result to Error Handling</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T20:00:00+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近关于 <a href="swift-evolution/0235-add-result.md at master · apple/swift-evolution · GitHub">Add Result to the Standard Library</a> 的提案正在激烈的<a href="SE-0235 - Add Result to the Standard Library - Proposal Reviews - Swift Forums">讨论中</a>，讨论的内容从命名到异步错误处理，再到是否应该有一个 <code>Either</code> 类型等等。</p>
</blockquote>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>对于在项目中使用过 Swift 的人来说，<code>Result</code> 类型应该再熟悉不过了，在 community 中有着非常广泛的应用。最早看到对于 <code>Result</code> 的应用是在<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a> 中，然后是有订阅的博客开始介绍 <code>Result</code> 是如何帮忙解决非必要的错误值/可选值检查，明确的区分成功和失败。再后来就是大家都开始在项目中使用 <code>Result</code> 类型来进行 <strong>异步错误处理</strong>。</p>
<p>为什么说 <strong>异步错误处理</strong> 呢，因为最早接触到 <code>Result</code> 这个类型的使用案例，就是用来处理异步错误的，并且它非常的适合，如果不从语言设计上考虑的话，它可以说是非常完美，因为它和 <code>Optional</code> 一样是个 Monad。虽然 <code>Result</code> 只是一个非常简单的数据结构，它和同步异步一点关系都没有，它只跟错误处理有关。</p>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>错误处理按执行顺序上可以分为同步（synchronization）和异步（concurrency）两种。</p>
<p>同步错误处理在 Cocoa 中有两种，一种是 <code>throw</code> + <code>try catch</code>，遇到异常的时候函数内部通过 <code>throw</code>/<code>raise</code>等关键词把异常信息抛出，调用方通过 <code>try catch</code> 进行捕获。另一种是古老的 C 中的 Error 指针，调用方通过把 Error 指针作为参数传到函数内部，当遇到错误时，给 Error 指针赋值，以达到把错误信息往外传递的目的。</p>
<p>异步错误处理在 Cocoa 中一般是通过 block, delegate 或者 notification 等方式进行传递，但大多数接口通常会把正常结果回调和异常结果回调合并一起进行回调，好处在于不需要两个 block 或者两个 delegate 函数或者 notification，缺点也就是上面的 <code>Result</code> 解决的问题。除此之外也有一些比较少见的方式，比如 <a href="https://developer.apple.com/documentation/avfoundation/avassetexportsession" target="_blank" rel="noopener">AVAssetExportSession</a>，它的 <code>completionHandler</code> 是 <code>@escaping () -&gt;  Void</code>，并不携带任何正常和错误的信息，而是通过 <code>var status: AVAssetExportSession.Status</code> 和 <code>var error: Error?</code> 等属性来提供。</p>
<p>抛开遥遥无期的 async/await 不谈，对于异步错误处理来说，可能由于网络库之类的接触的太多，所以平时去设计 API 的时候都非常的顺手的就写出来了，要么 <code>completionHandler: (Value?, Error?) -&gt; Void</code>，要么 <code>completionHandler: (Result&lt;Value&gt;) -&gt; Void</code>。但是对于同步错误处理却不是这样。</p>
<p>首先在 Swift 中推荐的错误处理是 <code>throw</code> + <code>try catch</code>，所以 Error 指针是不需要再讨论的。但不知道是因为 <code>throw</code> + <code>try catch</code> 难用，还是因为懒，一般的项目中其实很少见到 <code>throw/throws/rethrows</code> 这样的关键词（ObjC 中很少见到 throw/raise 同理）。</p>
<p>注：异步中是无法直接使用 <code>throw</code> + <code>try catch</code>，下面的两种写法都是不合法的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(forKey key: StoreKey)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    queue.async &#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="keyword">try</span> disk.url(atPath: path(forKey: key), <span class="keyword">in</span>: directory)</span><br><span class="line">        <span class="keyword">try</span> disk.remove(at: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(forKey key: StoreKey)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> queue.async &#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="keyword">try</span> disk.url(atPath: path(forKey: key), <span class="keyword">in</span>: directory)</span><br><span class="line">        <span class="keyword">try</span> disk.remove(at: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="万恶的-return"><a href="#万恶的-return" class="headerlink" title="万恶的 return"></a>万恶的 return</h3><p>一个当前在做的 Alligator 项目中的代码片段：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 视频导出</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter asset: 要导出的视频资源</span></span><br><span class="line"><span class="comment">/// - Parameter outputURL: 指定的导出地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">export</span><span class="params">(asset: AVAsset, to outputURL: URL)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> outputURL.isFileURL <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">"output url must be file url."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> exportSession = <span class="type">AVAssetExportSession</span>(asset: asset, presetName: <span class="type">AVAssetExportPresetHighestQuality</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exportSession.outputURL = outputURL</span><br><span class="line">    exportSession.outputFileType = .mp4</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的大概功能是进行配置和导出视频到文件，看起来是不是很熟悉？有参赛合法性的判断，提供开发调试帮助的 assertion，<code>guard</code> 的使用也很合理。</p>
<p>再看一段：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VideoProcessor.swift</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> videoWriterInput = </span><br><span class="line">    <span class="keyword">let</span> audioWriterInput = </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> videoWriter = <span class="keyword">try</span>? <span class="type">AVAssetWriter</span>(outputURL: outputURL, fileType: .mp4) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> videoWriter.canAdd(videoWriterInput) &#123;</span><br><span class="line">        videoWriter.add(videoWriterInput)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">"can't add video writer input"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> videoWriter.canAdd(audioWriterInput) &#123;</span><br><span class="line">        videoWriter.add(audioWriterInput)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">"can't add audio writer input"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似这样的代码在 project 中应该非常常见，但是却有着非常大的问题，那就是 <strong>故意的忽略异常</strong>。只处理了一切正常执行的分支，当遇到异常的时候，直接 return 或是加上 assertion 信息。这样写大多数情况下都没有什么问题，功能也正常，即使是遇到了异常情况，也不会引起 crash，但却有着很大的缺陷。（甚至有很多人连 assertion 都不用，替而代之的是 <code>print</code> :P</p>
<p>在这个例子中这些视频处理的逻辑实际上是相对比较独立的，功能也比较”单一”，这些异常一旦出现，后续的逻辑基本都是不可用，并且大多数的异常在实际应用中是需要被调用方知道并处理的，比如体现在 UI 上。</p>
<p>一个带异常处理（滑稽）的视频处理的示例代码片段：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVAsset+Processor.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Alligator</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">AVAsset</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Merge the given video asset and audio asset</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - videoAsset: the given video asset</span></span><br><span class="line">    <span class="comment">///   - audioAsset: the given audio asset</span></span><br><span class="line">    <span class="comment">/// - Returns: the merged asset</span></span><br><span class="line">    <span class="comment">/// - Throws: throws error when the given asset is invalid. e.g. video asset without video tracks.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(videoAsset: AVAsset, audioAsset: AVAsset)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">AVAsset</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> mixComposition = <span class="type">AVMutableComposition</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> mixComposition.agt.add(.video, from: videoAsset)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> videoDuration = mixComposition.duration</span><br><span class="line">        <span class="keyword">try</span> mixComposition.agt.add(.audio, from: audioAsset, maxBounds: videoDuration)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mixComposition</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Merge the given assets one by one</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - segments: given assets, it can't be empty</span></span><br><span class="line">    <span class="comment">///   - isMuted: if true, it will passthrough audio tracks</span></span><br><span class="line">    <span class="comment">/// - Returns: merged asset</span></span><br><span class="line">    <span class="comment">/// - Throws: throws error when segments is empry, or some segment is invalid.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(segments: [AVAsset], isMuted: Bool)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">AVAsset</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !segments.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.segmentsEmpty</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> segments.<span class="built_in">count</span> &gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> mixComposition = <span class="type">AVMutableComposition</span>()</span><br><span class="line">            <span class="keyword">try</span> mixComposition.agt.add(segments, isMuted: isMuted)</span><br><span class="line">            <span class="keyword">return</span> mixComposition</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> segments[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无脑的-Optional"><a href="#无脑的-Optional" class="headerlink" title="无脑的 Optional"></a>无脑的 Optional</h3><p>无脑的 Optional 指的是，对于一个有明确返回值类型 <code>T</code> 的函数，有可能出现某个入参不符合要求的情况，就把返回值改成 <code>T?</code>，用 <code>return nil</code> 来处理异常。如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Format a string, replace invalid symbol with empty character</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameter string: string needs to be format</span></span><br><span class="line">    <span class="comment">/// - Returns: formatted string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> string.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> string.replacingOccurrences(of: <span class="string">"\n"</span>, with: <span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该大多数人都试过这样，并且甚至有人一直都是这样，不经思索。有人会觉得这样写并没有什么问题。那么再看：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Format a string, replace invalid symbol with empty character. If it is empty or contains `@`, `#`, return nil.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameter string: string needs to be format</span></span><br><span class="line">    <span class="comment">/// - Returns: formatted string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> string.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> !string.<span class="built_in">contains</span>(<span class="string">"@"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> !string.<span class="built_in">contains</span>(<span class="string">"#"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> string.replacingOccurrences(of: <span class="string">"\n"</span>, with: <span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写有没有问题呢？或者说有没有更好的方案呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> emptyString</span><br><span class="line">        <span class="keyword">case</span> containsHashtag</span><br><span class="line">        <span class="keyword">case</span> containsMention</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Format a string, replace invalid symbol with empty character</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameter string: string needs to be format</span></span><br><span class="line">    <span class="comment">/// - Returns: formatted string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(<span class="number">_</span> string: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> string.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.emptyString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> !string.<span class="built_in">contains</span>(<span class="string">"@"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.containsMention</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> !string.<span class="built_in">contains</span>(<span class="string">"#"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.containsHashtag</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> string.replacingOccurrences(of: <span class="string">"\n"</span>, with: <span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个问题可以归为，<strong>对于同步 API 的异常处理，什么时候应该使用 throw？，什么时候可以返回 nil？</strong></p>
<p>这是一个很大的话题，并且大多数情况下需要根据场景来选择。通过对比这两种设计，可以简单的理解为如果希望使用方以更加合适的方式来处理错误，错误信息分类清晰详细，那么应该使用 <code>throw</code>。是否需要隐藏异常，交给使用方来决定。如果错误比较单一明确，可以考虑使用 <code>Optional</code>。</p>
<h3 id="混淆的人为错误和程序错误"><a href="#混淆的人为错误和程序错误" class="headerlink" title="混淆的人为错误和程序错误"></a>混淆的人为错误和程序错误</h3><p>简单来说对于人为错误，应该通过 <code>assertion</code>, <code>precondition</code>, <code>fatalError</code> 等来帮助在开发测试阶段发现问题。而对于程序错误，应该根据同步或者异步来区分处理，使得程序能继续正常的工作。</p>
<p>人为错误一般是指手误参数传错这种，如果没有手误（比如拼错单词、下标越界等），从逻辑上说不可能发生这种情况。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">else</span> &#123;</span><br><span class="line">        fataError(<span class="string">"不应该啊兄弟"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序错误更多是指所有参数都没有错误，但还是遇到异常了，并且不能忽略，比如磁盘满了导致无法写入文件。</p>
<blockquote>
<p>最后值得一提的就是大多数人在写 ObjC 的时候都会选择性的忽略异常，经典的场景就是设计 API 的时候滥用 <code>id</code>，然后虽然在方法内部对参数类型进行了判断，但在出现参数类型不合法的时候，直接通过 <code>return</code> 来处理。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/apple/swift-package-manager/blob/master/Sources/Basic/Result.swift" target="_blank" rel="noopener">Swift Package Manager</a><br><a href="https://onevcat.com/2018/10/swift-result-error/" target="_blank" rel="noopener">Result&lt;T&gt; 还是 Result&lt;T, E: Error&gt;</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2018/08/26/logging-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/logging-system/" itemprop="url">How to design a lightweight Logging System</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T20:00:00+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>之前项目一直都是使用 <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a> 来定制 Log 系统，这次整个工程使用 Pure-Swift 来开发，而且作为一个初创项目，对于 Log 系统的需求并没有那么高，虽然 <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a> 在 Swift 项目中直接使用也比较友好，但是感觉还是 <del>太重了</del> 。所以为何不直接设计一个比较轻量级的日志系统呢？</p>
</blockquote>
<h2 id="Logging-System"><a href="#Logging-System" class="headerlink" title="Logging System"></a>Logging System</h2><p>在 iOS 中，可以用 Swift 中的 <code>print()</code> 和 <code>debugPrint()</code> 函数来向 Xcode Console 来打印信息，也可以使用 Foundation 中的 <code>NSLog()</code> 来打印，更新的就是 <a href="https://developer.apple.com/documentation/os/logging" target="_blank" rel="noopener">os_log</a> 了。这三种不同的方式有不同的特点。</p>
<ul>
<li><strong>print</strong>/<strong>debugPrint</strong>: Swift 语言层面提供的实现，可以输出到 Xcode Console，但不能输出到 Apple System Logs（Mac Console.app）。</li>
<li><strong>NSLog</strong>: Foundation 中的实现，除了能在 Xcode Console 中输出外，还会往 Console.app 发，并且有较大的性能损害。</li>
<li><strong>os_log</strong>: 待补充 <a href="https://developer.apple.com/videos/play/wwdc2016/721/" target="_blank" rel="noopener">Unified Logging and Activity Tracing - WWDC 2016 - Videos - Apple Developer</a> <a href="https://developer.apple.com/videos/play/wwdc2018/405/" target="_blank" rel="noopener">Measuring Performance Using Logging - WWDC 2018 - Videos - Apple Developer</a></li>
</ul>
<p>Xcode Console 和 Apple System Logs 都是需要物理接触设备才能看到 log。但是在项目中，如果想要看到线上用户的 log 信息，必须要把这些 log 写到本地文件中，或者实时/定时发到远端服务器上。这时候直接使用内置的 API 是无法满足需求的。</p>
<p>对于一个相对比较合理的日志系统，一般有几点要求：</p>
<ul>
<li>在 release 下禁止输出日志到 Xcode Console</li>
<li><del>在 release 下</del> 禁止输出日志到 Apple System Logs</li>
<li>提供输出日志到本地文件中的能力</li>
<li>能够方便的扩展，如直接输出到 Web</li>
<li>对于日志根据重要性划分为不同的等级</li>
<li>可以根据日志等级，过滤日志</li>
</ul>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h3><p>Level 有两个作用：</p>
<ul>
<li>定义一条日志的重要性</li>
<li>对日志进行过滤，比如过滤掉某个等级以下的日志（实际是有包含的关系</li>
</ul>
<p>这里通过两个类型来实现 level 的作用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Level</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> off = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> error = <span class="number">1</span> <span class="comment">// Flag.error | Level.off</span></span><br><span class="line">    <span class="keyword">case</span> warning = <span class="number">3</span> <span class="comment">// Flag.warning | Level.error</span></span><br><span class="line">    <span class="keyword">case</span> info = <span class="number">7</span> <span class="comment">// Flag.info | Level.warning</span></span><br><span class="line">    <span class="keyword">case</span> debug = <span class="number">15</span> <span class="comment">// Flag.debug | Level.info</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Flag</span>: <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> rawValue: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> error = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> warning = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> info = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> debug = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">3</span>) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rawValue = rawValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Message-amp-Formatter"><a href="#Message-amp-Formatter" class="headerlink" title="Message &amp; Formatter"></a>Message &amp; Formatter</h3><p>一条日志如果只有正文部分，很难帮助定位具体的位置和发生的时间点，所以一条更加有意义的日志，会带上所在的文件、函数、行数以及时间戳等信息。</p>
<p>首先定义一个 <code>Message</code> 的数据结构来定义一条日志，这些信息最终具体如何 format 成一条字符串，需要提供一个 <code>Formatter</code> 来实现。</p>
<p>既然是 Pure-Swift，所以这里 <code>Message</code> 使用 <code>struct</code> （Value Type），而不是 <code>class</code> （Reference Type）。（<code>Codable</code>, <code>CustomStringConvertible</code>, <code>Equatable</code> 什么的暂时不需要考虑。</p>
<p>对于 <code>Formatter</code>，可能不同的 logger 需要不同的 format，比如输出到本地文件的 logger 需要更详细的信息，比如时间戳，才好帮助日后还原 app 当时运行的情况，而输出到 Xcode Console 的日志一般是在开发的时候看的，所以时间戳可能就没那么重要。（为什么 <code>Formatter</code> 使用 <code>protocol</code>？可以先想想，后面再解释。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> level: <span class="type">Level</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> flag: <span class="type">Flag</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> context: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> file: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> function: <span class="type">StaticString</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> line: <span class="type">UInt</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> timestamp: <span class="type">Date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(message: Message)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>根据日志输出的目标不同，可以划分为不同类型的 logger，比如 <code>ConsoleLogger</code>、<code>FileLogger</code> 以及 <code>WebLogger</code> 等。每一种不同的 logger 都有一些同样的接口，所以第一反应有两种不同的方式来实现类型的划分以及相同接口（行为）的约束。</p>
<p>使用面向对象的思想，通过继承来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> console</span><br><span class="line">        <span class="keyword">case</span> file</span><br><span class="line">        <span class="keyword">case</span> web</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .console</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"must override this method in subclass."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span>: <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .console</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span>: <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .file</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用面向协议的思想，通过协议来约束行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Type</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogger</span>: <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .console</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileLogger</span>: <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .file</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种不同的实现，体现的是两种不同的思想：</p>
<ul>
<li>一种是使用面向对象的思想，通过一个基类来提供相同的接口，然后子类重写这些接口来提供不同的能力；</li>
<li>另一种是使用面向协议的思想，通过一个协议来对接口进行约束，每一个具体的实现都必须实现这些接口来提供不同都能力。</li>
</ul>
<p>而对于不同类型的 logger 都共有的行为，前一种方式可以直接在基类中实现，后一种方式可以通过 <code>protocol extension</code> 来提供默认实现。</p>
<p>两种方式各有优缺点，如果你也不喜欢前一种 <strong>需要运行时才能知道子类必须重写父类的某个方法</strong>，完全不能体现出 Swift 作为一门有着强大类型安全的静态语言的优势，那么这里毫不犹豫的选择后一种方式。（不解释</p>
<p>对于这里的 <code>Type</code>，虽然使用 <code>enum</code> 有着很好的强类型信息，但这样写有着很大的约束，就是一开始就必须定义好所有的 Type，对于扩展性来说，非常不友好。</p>
<p>所以综合可扩展性和 <code>Type</code> 的作用考虑，这里通过添加一个 <code>String</code> 类型的属性 <code>name</code> 来简单的区分。（很方便于 debug</p>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>最终得到一整个 Logging 相关的接口定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> formatter: <span class="type">Formatter</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> level: <span class="type">Level</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message: Message)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flush</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unified"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flush</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>前面定义了每个不同 <code>logger</code> 的接口（行为），但是使用的时候，如果需要手动调用每个 <code>logger</code> 的 <code>log(message:)</code> 方法，那就太没有意义了。所以需要一个数据结构，来管理所有的 <code>logger</code>，并且将消息转发到每一个 <code>logger</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Logger</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.xspyhack.logger.queue"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> loggers: <span class="type">Set</span>&lt;<span class="type">AnyLogger</span>&gt; = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        loggers.forEach &#123;</span><br><span class="line">            $<span class="number">0</span>.teardown()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        loggers = []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> logger: Logging)</span></span> &#123;</span><br><span class="line">        loggers.update(with: logger)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message: Message, asynchronous: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> work = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.loggers.forEach &#123; logger <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> message.flag.rawValue &amp; logger.level.rawValue != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                logger.log(message: message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> asynchronous &#123;</span><br><span class="line">            queue.async(execute: work)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queue.sync(execute: work)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        loggers.forEach &#123;</span><br><span class="line">            $<span class="number">0</span>.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flush</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> work = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.loggers.forEach &#123; logger <span class="keyword">in</span></span><br><span class="line">                logger.flush()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.sync(execute: work)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是比较粗糙的实现，很多细节还没有处理，比如 <code>loggers</code> 的线程安全问题、以及 <code>logger</code> 的删除等等。</p>
<h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p>有了 <code>Logging</code> 来定义每一种不同作用的 <code>logger</code>，以及一个管理所有 <code>logger</code> 的管理器 <code>Logger</code>（至于这个让人懵逼的命名，实际是因为懒，取一个别的名字比较适合，比如 <del>Charmander</del>），还需要考虑最终如何简单的使用这个 Logging System。</p>
<p>现在如果要使用这个系统，首先需要实现自己的多种 <code>loggers</code> 和对应的 <code>Formatter</code>，然后添加到 <code>Logger</code> 里面，然后在需要打 log 的地方，初始化 一个 <code>Message</code>，调用 <code>Logger.shared.log(message:)</code> 方法。</p>
<p>这里每次初始化一个 <code>Message</code> 太麻烦了。如何简化？默认参数啊。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>, level: <span class="type">Level</span>, flag: <span class="type">Flag</span>, context: <span class="type">Int</span> = <span class="number">0</span>, file: <span class="type">String</span> = #file, function: <span class="type">StaticString</span> = #function, line: <span class="type">UInt</span> = #line, asynchronous: <span class="type">Bool</span> = <span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> message = <span class="type">Message</span>(message: message(), level: level, flag: flag, context: context, file: file, function: function, line: line, timestamp: <span class="type">Date</span>())</span><br><span class="line"></span><br><span class="line">    <span class="type">Logger</span>.shared.log(message: message, asynchronous: asynchronous)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>level</code> 和 <code>flag</code> 如果能提供默认参数，那么在调用的时候，就可以像 <code>print</code> 一样，直接只关注要 log 的内容就好了。一个比较简单直接的方法，就是针对这几种 <code>level</code> 暴露多个方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Log</span>.d(<span class="string">"This is a debug level log"</span>)</span><br><span class="line"><span class="type">Log</span>.i(<span class="string">"This is an info level log"</span>)</span><br><span class="line"><span class="type">Log</span>.w(<span class="string">"This is a warning level log"</span>)</span><br><span class="line"><span class="type">Log</span>.e(<span class="string">"This is an error level log"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个思考，上面的 <code>log</code> 函数中参数 message 的类型为什么使用 <code>@autoclosure</code>？</p>
</blockquote>
<blockquote>
<p>第二个思考，<code>Swift.print</code> 函数的定义你知道吗？</p>
</blockquote>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p><a href="https://github.com/xspyhack/Keldeo" target="_blank" rel="noopener">GitHub - xspyhack/Keldeo: A lightweight logging library written in Swift.</a></p>
<h3 id="Why-AnyLogger"><a href="#Why-AnyLogger" class="headerlink" title="Why AnyLogger"></a>Why AnyLogger</h3><p>对于引入 <code>AnyLogger</code>，是因为我希望能够提供移除一个 <code>logger</code> 的能力，用处就是当我在脱离 Xcode 的时候，可以通过一种可以输出到浏览器的 <code>logger</code> 来实时看到日志输出。而这个名为 <code>WebLogger</code> 的 <code>logger</code> 平时并不会用到，所以它是需要的时候才添加进去，用完之后便移除，所以就涉及到 <code>logger</code> 必须实现 <code>Equatable</code>，实现从 <code>loggers</code> 里面移除它。</p>
<blockquote>
<p>Why <code>protocol Logging: Equatable {}</code> needs <code>AnyLogger</code>？见另一篇 <a href="http://blessingsoft.com/2018/08/26/pats/">PATs</a></p>
</blockquote>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">GitHub - CocoaLumberjack/CocoaLumberjack: A fast &amp; simple, yet powerful &amp; flexible logging framework for Mac and iOS</a></li>
<li><a href="https://github.com/onevcat/Kingfisher/blob/master/Sources/ImageCache.swift" target="_blank" rel="noopener">Kingfisher/ImageCache.swift at master · onevcat/Kingfisher · GitHub</a></li>
<li><a href="https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/AnyHashable.swift" target="_blank" rel="noopener">swift/AnyHashable.swift at swift-3.0-branch · apple/swift · GitHub</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2018/08/26/pats/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/pats/" itemprop="url">PATs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T20:00:00+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>更新：随着 Swift 中一些新的提案（如 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md" target="_blank" rel="noopener">SE-0309</a> 和 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0335-existential-any.md" target="_blank" rel="noopener">SE-0335</a>）的提出，大大的简化了 Swift 中的 Protocol 的使用，文中的一些概念或者观点抑或是写法已经显得落后而不适用。–2022.01.01</p>
</blockquote>
<blockquote>
<p>很久没有写 Swift 了，闲着写几行玩玩的时候，遇到了一个之前没有接触过的问题——Protocol with Associated Types</p>
</blockquote>
<h2 id="Protocol-Oriented-Programming"><a href="#Protocol-Oriented-Programming" class="headerlink" title="Protocol-Oriented Programming"></a>Protocol-Oriented Programming</h2><p>首先 Swift 是一个 <strong>支持</strong> 面向协议编程思想的语言，并且 <a href="https://github.com/apple/swift" target="_blank" rel="noopener">Standard Library</a> 也是大量使用这种思想来实现很多的特性。（这里删掉介绍 POP 以及对应优缺点的几千字</p>
<p>先看看用 POP 的思想，来实现一个 Cache：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryCache</span>: <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Memory Cache"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DiskCache</span>: <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Disk Cache"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> memory: <span class="type">Caching</span> = <span class="type">MemoryCache</span>() <span class="comment">// 🙂️</span></span><br><span class="line"><span class="keyword">let</span> disk: <span class="type">Caching</span> = <span class="type">DiskCache</span>() <span class="comment">// 🙂️</span></span><br><span class="line"><span class="keyword">let</span> caches: [<span class="type">Caching</span>] = [memory, disk] <span class="comment">// 🙂️</span></span><br></pre></td></tr></table></figure>
<p>到这里，一切都是很熟悉的样子，也能正常的 work，类似这样的<strong>用一个 <em>protocol</em> 来进行接口（行为）约束</strong>的代码估计写的也不少。</p>
<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><blockquote>
<p>作为一个现代语言，泛型是必须支持的。作为一个现代程序员，泛型也是必须会使用的。</p>
</blockquote>
<p>Cache  是用来缓存数据的，但有很多数据类型都适合被缓存，比如一张图片，一个视频等等。如果希望不同类型的数据有不同的缓存策略，使用的时候也能直接获取某一种类型的缓存，不需要各种 <code>as? XXX</code>，立马想到的就是泛型。</p>
<p>泛型还不简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Object</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(<span class="number">_</span> object: Object, forKey key: String)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">retrieve</span><span class="params">(forKey key: String)</span></span> -&gt; <span class="type">Object?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryCache</span>: <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Object</span> = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(<span class="number">_</span> object: Object, forKey key: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">retrieve</span><span class="params">(forKey key: String)</span></span> -&gt; <span class="type">Object?</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DiskCache</span>: <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Object</span> = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(<span class="number">_</span> object: Object, forKey key: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">retrieve</span><span class="params">(forKey key: String)</span></span> -&gt; <span class="type">Object?</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> memory: <span class="type">Caching</span> = <span class="type">MemoryCache</span>() <span class="comment">// 🙃</span></span><br><span class="line"><span class="keyword">let</span> disk: <span class="type">Caching</span> = <span class="type">DiskCache</span>() <span class="comment">// 🙃</span></span><br><span class="line"><span class="keyword">let</span> caches: [<span class="type">Caching</span>] = [memory, disk] <span class="comment">// 🙃</span></span><br></pre></td></tr></table></figure>
<p>然后 Xcode 就好很无情的提示你：</p>
<blockquote>
<p>❗️Protocol ‘Caching’ can only be used as generic constraint because it has Self or associated type requirements</p>
</blockquote>
<p>WTF?</p>
<h2 id="What-is-Protocol-with-Associated-Types"><a href="#What-is-Protocol-with-Associated-Types" class="headerlink" title="What is Protocol with Associated Types?"></a>What is Protocol with Associated Types?</h2><p>看到这个错误提示，有经验的 Swift  程序员一般会想到，<code>Caching</code> 里面关联了一个类型，如果不指定这个关联的类型的具体类型是什么，作为一门静态语言，那可能就无法知道内存是怎么布局的。</p>
<p>既然需要指定类型，马上想到的就是 <em>泛型参数</em>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache: <span class="type">Caching</span>&lt;<span class="type">UIImage</span>&gt; =  ...</span><br><span class="line"><span class="comment">// ❗️Protocol 'Caching' can only be used as generic constraint because it has Self or associated type requirements</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Caching</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ❗️Protocols do not allow generic parameters; use associated types instead</span></span><br></pre></td></tr></table></figure>
<p>WTF？</p>
<h2 id="Protocol-as-Types"><a href="#Protocol-as-Types" class="headerlink" title="Protocol as Types"></a>Protocol as Types</h2><p>突然发现自己好像一点都不了解 protocol，看看文档介绍<a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" target="_blank" rel="noopener">Protocols — The Swift Programming Language (Swift 4.2)</a>。里面 Protocol as Types 一节有一段话：</p>
<blockquote>
<p>Protocols don’t actually implement any functionality themselves. Nonetheless, any protocol you create will become a fully-fledged type for use in your code.<br>Because it’s a type, you can use a protocol in many places where other types are allowed, including:</p>
<ul>
<li>As a parameter type or return type in a function, method, or initializer</li>
<li>As the type of a constant, variable, or property</li>
<li>As the type of items in an array, dictionary, or other container</li>
</ul>
</blockquote>
<p>为什么 protocol + generic 就这么难用？应该怎么用？</p>
<h2 id="PATs-in-Swift-Standard-Library"><a href="#PATs-in-Swift-Standard-Library" class="headerlink" title="PATs in Swift Standard Library"></a>PATs in Swift Standard Library</h2><p>既然不会用，那么看看 Standard Library 里面是如何使用的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The type of element traversed by the iterator.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// - Returns: The next element in the underlying sequence, if a next element</span></span><br><span class="line">    <span class="comment">///   exists; otherwise, `nil`.</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// A type representing the sequence's elements.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A type that provides the sequence's iteration interface and</span></span><br><span class="line">    <span class="comment">/// encapsulates its iteration state.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span> : <span class="type">IteratorProtocol</span> <span class="keyword">where</span> <span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns an iterator over the elements of this sequence.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后又发现有一个叫 <code>AnyIterator</code> 和 <code>AnySequence</code> 的东西。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AnyIterator</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> _box: _AnyIteratorBoxBase&lt;<span class="type">Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">I</span> : <span class="type">IteratorProtocol</span>&gt;(<span class="number">_</span> base: <span class="type">I</span>) <span class="keyword">where</span> <span class="type">I</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _IteratorBox(base)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> body: @escaping () -&gt; <span class="type">Element?</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _IteratorBox(_ClosureBasedIterator(body))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(_box: _AnyIteratorBoxBase&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _box</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AnyIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _box.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AnySequence</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> _box: _AnySequenceBox&lt;<span class="type">Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">I</span> : <span class="type">IteratorProtocol</span>&gt;(<span class="number">_</span> makeUnderlyingIterator: @escaping () -&gt; <span class="type">I</span>) <span class="keyword">where</span> <span class="type">I</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(_ClosureBasedSequence(makeUnderlyingIterator))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(_box: _AnySequenceBox&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _box</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AnySequence</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Iterator</span> = <span class="type">AnyIterator</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">S</span> : <span class="type">Sequence</span>&gt;(<span class="number">_</span> base: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _SequenceBox(_base: base)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是什么鬼，先看看文档：</p>
<blockquote>
<p>This iterator forwards its next() method to an arbitrary underlying iterator having the same Element type, hiding the specifics of the underlying IteratorProtocol. —<a href="https://developer.apple.com/documentation/swift/anyiterator" target="_blank" rel="noopener">AnyIterator - Swift Standard Library | Apple Developer Documentation</a></p>
</blockquote>
<blockquote>
<p>An instance of AnySequence forwards its operations to an underlying base sequence having the same Element type, hiding the specifics of the underlying sequence. —<a href="https://developer.apple.com/documentation/swift/anysequence" target="_blank" rel="noopener">AnySequence - Swift Standard Library | Apple Developer Documentation</a></p>
</blockquote>
<p>说白了就是包装一层，转发一下，它有个术语叫做 <strong>Type Erasure</strong></p>
<h2 id="What-is-Type-Erasure"><a href="#What-is-Type-Erasure" class="headerlink" title="What is Type Erasure?"></a>What is Type Erasure?</h2><p>首先 Swift 的类型系统里面，有两种类型：</p>
<ul>
<li>Concrete Type: Int, Bool…</li>
<li>Abstract Type: associatedType, <t></t></li>
</ul>
<p>对于抽象类型来说，编译器无法知道这个类型的确切功能。当编译器处理抽象类型的时候，它无法知晓其所占的空间大小；甚至可能会认为这个类型是不存在的。Swift 是静态语言。</p>
<blockquote>
<p>Type erasure is a process in code that makes abstract types concrete.</p>
</blockquote>
<p>具体看看 Swift Standard Library 里面，是怎么做到的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. abstract base</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">_AnyIteratorBoxBase</span>&lt;<span class="title">Element</span>&gt; : <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123; _abstract() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. private box</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_IteratorBox</span>&lt;<span class="title">Base</span> : <span class="title">IteratorProtocol</span>&gt; : <span class="title">_AnyIteratorBoxBase</span>&lt;<span class="title">Base</span>.<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123; <span class="keyword">self</span>._base = base &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Base</span>.<span class="type">Element?</span> &#123; <span class="keyword">return</span> _base.next() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _base: <span class="type">Base</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. public wrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AnyIterator</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> _box: _AnyIteratorBoxBase&lt;<span class="type">Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">I</span> : <span class="type">IteratorProtocol</span>&gt;(<span class="number">_</span> base: <span class="type">I</span>) <span class="keyword">where</span> <span class="type">I</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _IteratorBox(base)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> body: @escaping () -&gt; <span class="type">Element?</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _IteratorBox(_ClosureBasedIterator(body))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(_box: _AnyIteratorBoxBase&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _box</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模式概括起来就是三个步骤：</p>
<ul>
<li>an abstract base class</li>
<li>a private box class</li>
<li>a public wrapper class</li>
</ul>
<p>（想了解更多相关的理论知识？<em>Existential</em> 了解一下</p>
<h2 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h2><p>到这里，我以为我已经掌握了如何用 PATs 了，然后有一天，我开始写一个轻量级的日志系统。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Logging</span>: <span class="title">Hashtable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> loggers: <span class="type">Set</span>&lt;<span class="type">Logging</span>&gt; = []</span><br><span class="line"><span class="comment">// ❗️Using 'Logging' as a concrete type conforming to protocol 'Hashable' is no supported</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> logger: Logging)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ❗️Protocol 'Logging' can only be used as generic constraint because it has Self or associated type requirements</span></span><br></pre></td></tr></table></figure>
<p>看到这熟悉的错误，马上就想到 <code>Hashable</code> 其实是继承 <code>Equatable</code> 的，然后这个 <code>Equatable</code> 的几个方法里面，用了 <code>Self</code> 来占位，它其实也是 PATs 的一种。意不意外，惊不惊喜。（其实一点都不意外</p>
<p>然后就是 type erasure 了，真正根据上面的三个步骤来写的时候，发现好像跟之前的又有点不太一样，因为它没有关联别的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. abstract baes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnyLoggerBoxBase</span>&lt;<span class="title">T</span>&gt; : <span class="title">Logging</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. private box</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoggerBox</span>&lt;<span class="title">Base</span> : <span class="title">Logging</span>&gt; : <span class="title">_AnyLoggerBoxBase</span> &lt;<span class="title">Base</span>.<span class="title">Self</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. public wrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnyLogger</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">L</span> : <span class="type">Logging</span>&gt;(<span class="number">_</span> base: <span class="type">L</span>) <span class="keyword">where</span> <span class="type">L</span>.<span class="type">Self</span> == <span class="type">Self</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三步里面的泛型参数像是多出来的，根本无从下手。</p>
<blockquote>
<p>遇到不懂，首先看源码总是不会有错。— 圣人</p>
</blockquote>
<p>了解 Swift 的都知道，有一个叫做 <code>AnyHashable</code> 的东西。（一顿抄，完事</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://www.youtube.com/watch?v=XWoNjiSPqI8&amp;t=2391s" target="_blank" rel="noopener">Alexis Gallagher - Protocols with Associated Types - YouTube</a></li>
<li><a href="https://academy.realm.io/posts/tryswift-gwendolyn-weston-type-erasure/" target="_blank" rel="noopener">Keep Calm and Type Erase On</a></li>
<li><a href="https://developer.apple.com/documentation/swift/anysequence" target="_blank" rel="noopener">AnySequence - Swift Standard Library | Apple Developer Documentation</a></li>
<li><a href="https://github.com/apple/swift/blob/master/stdlib/public/core/ExistentialCollection.swift.gyb" target="_blank" rel="noopener">swift/ExistentialCollection.swift.gyb at master · apple/swift · GitHub</a></li>
<li><a href="https://github.com/apple/swift/blob/master/stdlib/public/core/AnyHashable.swift" target="_blank" rel="noopener">swift/AnyHashable.swift at master · apple/swift · GitHub</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/08/10/plist-parser/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/plist-parser/" itemprop="url">Plist Parser</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T20:00:00+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Plist 是 Apple 家平台上一种很常见的配置文件，常见的存储格式是常见的 XML 格式（还有 Binary 格式），不同于 HTML 的复杂，Plist 只包含了比较少的几种标签（tag），所以实现使用 functional 的 parser combinator 来实现一个简单的 plist parser 也是一件很有意思的事情。</p>
<h2 id="Plist"><a href="#Plist" class="headerlink" title="Plist"></a>Plist</h2><p>一个 Plist 文件内容长这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;number&lt;/key&gt;</span><br><span class="line">    &lt;integer&gt;0&lt;/integer&gt;</span><br><span class="line">    &lt;key&gt;date&lt;/key&gt;</span><br><span class="line">    &lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;</span><br><span class="line">    &lt;key&gt;data&lt;/key&gt;</span><br><span class="line">    &lt;data&gt;VGVzdFZhbHVl&lt;/data&gt;</span><br><span class="line">    &lt;key&gt;boolean&lt;/key&gt;</span><br><span class="line">    &lt;true/&gt;</span><br><span class="line">    &lt;key&gt;array&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;string&gt;string&lt;/string&gt;</span><br><span class="line">        &lt;false/&gt;</span><br><span class="line">        &lt;integer&gt;0&lt;/integer&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line"> &lt;/dict&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://zh.wikipedia.org/zh-hans/属性列表" target="_blank" rel="noopener">wikipedia</a> 上列出了一个详细的 <code>XML</code> 标签和 macOS/iOS 中的类型关系以及存储格式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Foundation 类</th>
<th style="text-align:left">Core Foundation 类型</th>
<th style="text-align:left">XML 标签</th>
<th style="text-align:left">储存格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NSString</td>
<td style="text-align:left">CFString</td>
<td style="text-align:left">&lt;string&gt;</td>
<td style="text-align:left">UTF-8 编码的字符串</td>
</tr>
<tr>
<td style="text-align:left">NSNumber</td>
<td style="text-align:left">CFNumber</td>
<td style="text-align:left">&lt;real&gt;, &lt;integer&gt;</td>
<td style="text-align:left">十进制数字符串</td>
</tr>
<tr>
<td style="text-align:left">NSNumber</td>
<td style="text-align:left">CFBoolean</td>
<td style="text-align:left">&lt;true/&gt;, or &lt;false/&gt;</td>
<td style="text-align:left">无数据（只有标签）</td>
</tr>
<tr>
<td style="text-align:left">NSDate</td>
<td style="text-align:left">CFDate</td>
<td style="text-align:left">&lt;date&gt;</td>
<td style="text-align:left">ISO 8601 格式的日期字符串</td>
</tr>
<tr>
<td style="text-align:left">NSData</td>
<td style="text-align:left">CFData</td>
<td style="text-align:left">&lt;data&gt;</td>
<td style="text-align:left">Base64 编码的数据</td>
</tr>
<tr>
<td style="text-align:left">NSArray</td>
<td style="text-align:left">CFArray</td>
<td style="text-align:left">&lt;array&gt;</td>
<td style="text-align:left">可以包含任意数量的子元素</td>
</tr>
<tr>
<td style="text-align:left">NSDictionary</td>
<td style="text-align:left">CFDictionary</td>
<td style="text-align:left">&lt;dict&gt;</td>
<td style="text-align:left">交替包含 &lt;key&gt; 标签和 plist 元素标签</td>
</tr>
</tbody>
</table>
<p>根据这个表格，我们可以定义出 Plist 的数据结构。</p>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The plist data model</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PLIST</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// &lt;true/&gt; or &lt;false/&gt;</span></span><br><span class="line">    <span class="keyword">case</span> bool(<span class="type">Bool</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 2017-08-05T14:25:14Z</span></span><br><span class="line">    <span class="keyword">case</span> date(<span class="type">Date</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;data&gt;VGVzdFZhbHVl&lt;/data&gt; (&lt;54657374 56616c75 65&gt;</span></span><br><span class="line">    <span class="keyword">case</span> data(<span class="type">Data</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;integer&gt;233&lt;/integer&gt; or &lt;real&gt;2.33&lt;/real&gt;</span></span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;string&gt;string&lt;/string&gt;</span></span><br><span class="line">    <span class="keyword">case</span> string(<span class="type">String</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;array&gt;&lt;string&gt;The String&lt;/string&gt;&lt;/array&gt;</span></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> array([<span class="type">PLIST</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;dict&gt;&lt;key&gt;The Key&lt;/key&gt;&lt;string&gt;The String&lt;/string&gt;&lt;/dict&gt;</span></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> dict([<span class="type">String</span>: <span class="type">PLIST</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>根据 Plist data model，想要解析一个 Plist 字符串 得到 <code>PLIST</code> 类型，只需要一个 <code>parser</code>。</p>
<p>没错，只需要一个 parser，这个 parser 大概长这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parser: <span class="type">Parser</span>&lt;<span class="type">PLIST</span>&gt;</span><br><span class="line"><span class="keyword">let</span> result = parser.parse(<span class="string">"plist"</span>)</span><br></pre></td></tr></table></figure>
<p>这个 <code>let parser: Parser&lt;PLIST&gt;</code> 的实现才是最关键的。一个 <code>PLIST</code> 是由 <code>Bool</code> <code>Date</code> <code>Data</code> <code>Number</code> <code>String</code> 5 种简单的类型和 <code>Array&lt;PLIST&gt;</code> <code>Dictionary&lt;PLIST&gt;</code> 2 种容器（nested）类型组成，所以一个 <code>Parser&lt;PLIST&gt;</code> 也是由对应的 <code>Parser&lt;Bool&gt;</code> <code>Parser&lt;Date&gt;</code> <code>Parser&lt;Data&gt;</code> <code>Parser&lt;Number&gt;</code> <code>Parser&lt;String&gt;</code> 5 中简单的 parser 和 <code>Parser&lt;Array&gt;</code> <code>Parser&lt;Dictionary&gt;</code> 2 种容器类型 parser 组成。</p>
<h3 id="Bool-Parser"><a href="#Bool-Parser" class="headerlink" title="Bool Parser"></a>Bool Parser</h3><p>在 Plist 中，Bool 类型由两种形式 <code>&lt;true/&gt;</code> 和 <code>&lt;false/&gt;</code>，所以一个 Bool 类型的 parser 也就是能够解析字符串 <code>&lt;true/&gt;</code> 和 <code>&lt;false/&gt;</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _true = string(<span class="string">"&lt;true/&gt;"</span>) &lt;&amp;&gt; const(<span class="type">PLIST</span>.bool(<span class="literal">true</span>))</span><br><span class="line"><span class="keyword">let</span> _false = string(<span class="string">"&lt;false/&gt;"</span>) &lt;&amp;&gt; const(<span class="type">PLIST</span>.bool(<span class="literal">false</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _bool = _true &lt;|&gt; _false</span><br><span class="line">_bool.parse(<span class="string">"&lt;false/&gt;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Date-Parser"><a href="#Date-Parser" class="headerlink" title="Date Parser"></a>Date Parser</h3><p>Plist 中的 Date 类型存储的是 UTC 字符串，如 <code>&lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;</code>。字符串中的开始标签 <code>&lt;date&gt;</code> 和结束标签 <code>&lt;/date&gt;</code> 对于解析的结果来说是没有用的，所以一个 Date 类型的 parser 是要将这个字符串解析成 <code>PLIST.date(date)</code>, date 为 2017-08-05T14:25:14Z 通过 format 得到。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _date = string(<span class="string">"&lt;date&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/date&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.date(<span class="type">String</span>($<span class="number">0</span>).date!) &#125;</span><br><span class="line">_date.parse(<span class="string">"&lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// UTC Date</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> date: <span class="type">Date?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        formatter.dateFormat = <span class="string">"yyyy-MM-dd'T'HH:mm:ss'Z'"</span></span><br><span class="line">        <span class="keyword">return</span> formatter.date(from: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-Parser"><a href="#Data-Parser" class="headerlink" title="Data Parser"></a>Data Parser</h3><p>Plist 中的 Data 类型存储的是 Base64 编码后的数据，所以实现一个 Data Parser 和 Date Parser 差不多，区别是 tag 和 Data 类型初始化。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _data = string(<span class="string">"&lt;data&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/data&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.data(<span class="type">Data</span>(base64Encoded: <span class="type">String</span>($<span class="number">0</span>))!) &#125;</span><br><span class="line"><span class="keyword">let</span> dataString = _data.parse(<span class="string">"&lt;data&gt;VGVzdFZhbHVl&lt;/data&gt;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Number-Parser"><a href="#Number-Parser" class="headerlink" title="Number Parser"></a>Number Parser</h3><p>Plist 中的 Number 的存储实际上分两种。一种是整型，一种是浮点型。整型的 <code>tag</code> 是 <code>integer</code>，浮点型是 <code>real</code>。</p>
<p>先看 Integer Parser：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _integer = string(<span class="string">"&lt;integer&gt;"</span>) *&gt; manyTill(_digit, string(<span class="string">"&lt;/integer&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.number(<span class="type">Int</span>(<span class="type">String</span>($<span class="number">0</span>))!) &#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-Parser"><a href="#String-Parser" class="headerlink" title="String Parser"></a>String Parser</h3><p>String Parser 和 Date Parser 以及 Data Parser 对比起来更简单，实际上就是去掉了最后转换的那一步。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _string = string(<span class="string">"&lt;string&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/string&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.string(<span class="type">String</span>($<span class="number">0</span>)) &#125;</span><br><span class="line">_string.parse(<span class="string">"&lt;string&gt;The String&lt;/string&gt;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Tag-Parser"><a href="#Tag-Parser" class="headerlink" title="Tag Parser"></a>Tag Parser</h3><p>通过对比上面几种除了 Bool Parser 之外不同类型的 Parser，可以发现实现的方式很相似。</p>
<ul>
<li>closed tag，成对存在。</li>
<li>中间存储的都是字符串，最后把字符串转为具体类型。</li>
</ul>
<p>把这些相似的 Parser 进行抽象，将相同部分封装成一个函数，不同的部分用传参的形式来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tag</span>&lt;A&gt;<span class="params">(<span class="number">_</span> tag: String, <span class="number">_</span> p: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> string(<span class="string">"&lt;\(tag)&gt;"</span>) *&gt; manyTill(p, string(<span class="string">"&lt;/\(tag)&gt;"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _date1 = tag(<span class="string">"&lt;date&gt;"</span>, _any) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.date(<span class="type">String</span>($<span class="number">0</span>).date!) &#125;</span><br><span class="line">_date1.parse(<span class="string">"&lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _string1 = tag(<span class="string">"string"</span>, _any) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.string(<span class="type">String</span>($<span class="number">0</span>)) &#125;</span><br><span class="line">_string1.parse(<span class="string">"&lt;string&gt;The String&lt;/string&gt;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Array-Parser"><a href="#Array-Parser" class="headerlink" title="Array Parser"></a>Array Parser</h3><p>Array Parser 和 Dictionary Parser 相对比较复杂，因为它们是容器类型，里面可以是任意的 PLIST 类型，包括它们本身。对于 Enum PLIST 来说，可以使用 <code>indirect</code> 关键字来表示这种情况，但是在定义 parser 的时候，确没有这些魔法。</p>
<p>但是通过利用 Swift 的一些特性，还是很容易解决这个递归的问题。先忽略 Dictionary 类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _plist = plist()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plist</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">PLIST</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> _bool &lt;|&gt; _string &lt;|&gt; _integer &lt;|&gt; _date &lt;|&gt; _data &lt;|&gt; _array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _array = tag(<span class="string">"array"</span>, _plist) &lt;&amp;&gt; &#123;</span><br><span class="line">    <span class="type">PLIST</span>.array($<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dictionary-Parser"><a href="#Dictionary-Parser" class="headerlink" title="Dictionary Parser"></a>Dictionary Parser</h3><p>Dictionary Parser 的递归问题和 Array Parser 一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _plist = plist()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plist</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">PLIST</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> _bool &lt;|&gt; _string &lt;|&gt; _integer &lt;|&gt; _date &lt;|&gt; _data &lt;|&gt; _array &lt;|&gt; _dict</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _dict = tag(<span class="string">"dict"</span>, ?) &lt;&amp;&gt; &#123;</span><br><span class="line">   <span class="comment">/// 转换为 PLIST.dict</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 Dictionary 和 Array 不一样的地方在于，Array 里面是多个 Plist 的元素，而 Dictionary 是 key-value 对，且必须是 key-value 对，也就是 <code>tag(&quot;dict&quot;, _keyValue)</code>。</p>
<p>先实现一个 Key-Value Parser：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _key = string(<span class="string">"&lt;key&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/key&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> _keyValue = (&#123; a <span class="keyword">in</span> &#123; b <span class="keyword">in</span> (a, b) &#125;&#125; &lt;^&gt; _key &lt;*&gt; (value))</span><br></pre></td></tr></table></figure>
<p>然后就可以得到 Dictionary Parser：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _dict = tag(<span class="string">"dict"</span>, _keyValue) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.dict(atod($<span class="number">0</span>)) &#125;</span><br><span class="line"><span class="comment">/// Tuple Array to Dictionary</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">atod</span>&lt;Key: Hashable, Value&gt;<span class="params">(<span class="number">_</span> tuples: [<span class="params">(Key, Value)</span></span></span>]) -&gt; [<span class="type">Key</span>: <span class="type">Value</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> dict: [<span class="type">Key</span>: <span class="type">Value</span>] = [:]</span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> tuples &#123;</span><br><span class="line">        dict[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dict</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者换一种写法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _kv = _keyValue &lt;&amp;&gt; &#123; ttod($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _dict1 = tag(<span class="string">"dict"</span>, _kv) &lt;&amp;&gt; &#123;</span><br><span class="line">    <span class="type">PLIST</span>.dict(</span><br><span class="line">    		$<span class="number">0</span>.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line">        .<span class="built_in">reduce</span>([<span class="type">String</span>: <span class="type">PLIST</span>]()) &#123; d, kv <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> dict = d</span><br><span class="line">            dict.updateValue(kv.value, forKey: kv.key)</span><br><span class="line">            <span class="keyword">return</span> dict</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">ttod</span>&lt;Key: Hashable, Value&gt;<span class="params">(<span class="number">_</span> tuple: <span class="params">(Key, Value)</span></span></span>) -&gt; [<span class="type">Key</span>: <span class="type">Value</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple.<span class="number">0</span>: tuple.<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Plist-Parser"><a href="#Plist-Parser" class="headerlink" title="Plist Parser"></a>Plist Parser</h3><p>最后</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _plist = _bool &lt;|&gt; _string &lt;|&gt; _integer &lt;|&gt; _date &lt;|&gt; _data &lt;|&gt; _array &lt;|&gt; _dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = _plist.parse(plist)</span><br><span class="line"><span class="built_in">dump</span>(result)</span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zh.wikipedia.org/zh-hans/属性列表" target="_blank" rel="noopener">属性列表</a><br><a href="http://blessingsoft.com/2017/05/28/parser-combinator/">Parser Combinator</a><br><a href="https://github.com/nixzhu/dev-blog/blob/master/2017-04-12-json-parser.md" target="_blank" rel="noopener">解析组合子</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/12/group-theory-and-category-theory/" itemprop="url">Group Theory and Category Theory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T20:00:00+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想理解函数式编程中的一些高大上的概念，比如 Functor, Monad 等，必须要先理解范畴论。</p>
<h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><blockquote>
<p>群，是一种代数结构，由一个集合（G）以及一个二元运算符（·）所组成。<a href="https://zh.wikipedia.org/wiki/群" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>
<p>一个群必须满足一些称为 <em>群公理</em> 的条件，也就是 <strong>封闭性</strong>、<strong>结合律</strong>、<strong>单位元</strong> 和 <strong>逆元</strong>。如整数配备上加法运算就形成一个群。</p>
<ul>
<li>封闭性（Closure）：对于任意 a,b∈G，a·b∈G。</li>
<li>结合律（Associativity）：对于任意 a,b,c∈G，(a·b)·c = a·(b·c)。</li>
<li>单位元（Identity）：G 中存在一个元素 e，使得任意 a∈G，a·e = e·a = a。</li>
<li>逆元：对于任意 a∈G，存在 b∈G，使得 a·b = b·a = e。</li>
</ul>
<p>群并不要求这个二元运算符（·）具体做什么，它只要求这个二元运算符存在，所以很多数学结构都是群。比如我们可以把整数当作一个群，把 <code>+</code> 作为二元运算符。</p>
<ul>
<li>封闭性：对于任意两个整数 a,b，a+b 依然是一个整数。</li>
<li>结合律：对于任意整数 a,b,c，(a+b)+c = a+(b+c)。</li>
<li>单位元：存在元素 0，使得 a+0 = 0+a = a。</li>
<li>逆元：对于任意整数 a，当 b=-a 时，a+b = b+a = e。</li>
</ul>
<p>所以我们可以说 <code>(整数, +)</code> 是一个群。如果把 <code>*</code> 当作二元运算符，把 <code>1</code> 作为单位元的时候，整数就形成了另一个群。</p>
<p>除了整数，还有很多数学结构是群。</p>
<h3 id="Semigroup"><a href="#Semigroup" class="headerlink" title="Semigroup"></a>Semigroup</h3><p>满足封闭性和结合律的群，称为半群（semigroup）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;&gt;: <span class="type">AdditionPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Semigroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Semigroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs + rhs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Semigroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Array, rhs: Array)</span></span> -&gt; <span class="type">Array</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs + rhs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折叠 fold</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;S: Semigroup&gt;<span class="params">(<span class="number">_</span> xs: [S], <span class="number">_</span> initial: S)</span></span> -&gt; <span class="type">S</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(initial, &lt;&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>半群的结合律特性使得我们可以进行并行运算，<code>1 &lt;&gt; 2 &lt;&gt; 3 &lt;&gt; 4</code>。</p>
<h3 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h3><p>在抽象代数中，有一类简单的抽象结构被称为 Monoid（幺半群）。许多数学结构都是幺半群，因为成为幺半群的要求非常低。</p>
<p>存在单位元的半群，称为含幺半群，或者幺半群，或者单群，或者独异点（monoid）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Monoid</span>: <span class="title">Semigroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Monoid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Monoid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Array</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;M: Monoid&gt;<span class="params">(<span class="number">_</span> xs: [M])</span></span> -&gt; <span class="type">M</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(<span class="type">M</span>.e, &lt;&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>concat</code> 是对 Monoid 的一种应用，它可以利用 Monoid 的定义（ 二元操作 <code>&lt;&gt;</code> 和 单位元 <code>e</code> ）进行折叠操作。</p>
<h2 id="Category-Theory"><a href="#Category-Theory" class="headerlink" title="Category Theory"></a>Category Theory</h2><blockquote>
<p>范畴论是数学的一门学科，以抽象的方法来处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。<a href="https://zh.wikipedia.org/wiki/范畴论" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>一个范畴 C 包括：</p>
<ul>
<li>一个由对象（object）组成的类 ob(C)。（注：这里把“物件”成为“对象“更有助于从计算机的角度理解</li>
<li>对象间态射（morphism，-&gt;）组成的类 hom(C)：每个态射 f 都只有一个「源对象」a 以及一个「目标对象」b（其中 a,b 都在 ob(C) 内），称之为 <strong>从 a 到 b 的态射</strong>，记为 f: a-&gt;b。（注：identity 态射即自己映射到自己的特殊态射，f: a-&gt;a，简单记为 id[a]）</li>
<li>一个二元运算符（·），用于态射组合，如 h=g·f。</li>
</ul>
<p>满足公理：</p>
<ul>
<li>结合律：f: a-&gt;b, g: b-&gt;c, h: c-&gt;d，h·(g·f) = (h·g)·f。</li>
<li>单位元：id[a]·f = id[b]·f = f。</li>
<li>封闭性：f: a-&gt;b, g: b-&gt;c, h: a-&gt;c, h = f·g。</li>
</ul>
<p>范畴举例：</p>
<ul>
<li>范畴 C 有 Int 类型和 String 类型对象。</li>
<li>存在态射 f: Int-&gt;String。</li>
</ul>
<p>划重点：幺半群可以视为一类特殊的范畴。幺半群运算满足的公理同于范畴中 <strong>从一个对象到自身的态射</strong>。换言之：<br>幺半群实质上是只有单个对象的范畴。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><blockquote>
<p>在范畴论中，函子是范畴间的一类映射。函子也可以解释为小范畴为成员的范畴内的态射。 <a href="https://zh.wikipedia.org/wiki/函子" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>
<p>在当代数学中，函子被用来描述各种范畴间的关系。对范畴论者来说，函子则是个特别类型的函数。</p>
<p>设 C 和 D 为范畴，从 C 至 D 的函子为一映射 F:</p>
<ul>
<li>将每个对象 x∈C 映射至一对象 F(x)∈D 上。</li>
<li>将每个态射 f: x-&gt;y∈C 映射至一态射 F(f): F(x)-&gt;F(y)∈D 上，</li>
</ul>
<p>使之满足：</p>
<ul>
<li>对任何对象 x∈C，恒有 F(id[x]) = id[F(x)]。</li>
<li>对任何态射 f: x-&gt;y, g: y-&gt;z，恒有 F(f·g) = F(f)·F(g)。</li>
</ul>
<p>换言之，函子会保持单位态射与态射的复合。<br>一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
<h4 id="可以把范畴当作一组类型的集合"><a href="#可以把范畴当作一组类型的集合" class="headerlink" title="可以把范畴当作一组类型的集合"></a>可以把范畴当作一组类型的集合</h4><p>如范畴 C 有 <code>Int</code> 类型和 <code>String</code> 类型对象，以及 <code>Int -&gt; String</code> 的态射；范畴 D 有 <code>Array&lt;Int&gt;</code> 类型和 <code>Array&lt;String&gt;</code> 类型对象，以及 <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code> 的态射。两个范畴之间的映射 F：</p>
<ul>
<li><code>Int</code> 映射至 <code>Array&lt;Int&gt;</code> 上，<code>String</code> 映射至 <code>Array&lt;String&gt;</code> 上。</li>
<li>态射 <code>Int -&gt; String</code> 映射至 <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code> 上。</li>
</ul>
<p>翻译成代码：C: <code>Int</code>, <code>String</code>, f: <code>Int -&gt; String</code>, D: <code>Array&lt;Int&gt;</code>, <code>Array&lt;String&gt;</code>, f: <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code>。</p>
<ul>
<li>x: <code>Int</code> -&gt; F(x): <code>Array&lt;Int&gt;</code>，<code>String</code> -&gt; F(x): <code>Array&lt;String&gt;</code></li>
<li>f: <code>(Int -&gt; String)</code> -&gt; F(f): <code>(Array&lt;Int&gt; -&gt; Array&lt;String&gt;)</code></li>
</ul>
<p>范畴是不涉及具体类型的，所以用泛型表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tmap</span>&lt;T&gt;<span class="params">(x: T)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmap</span>&lt;A, B&gt;<span class="params">(f: A -&gt; B)</span></span> -&gt; (<span class="type">F</span>&lt;<span class="type">A</span>&gt; -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>简化一下变成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 中把 Int 映射到 Array&lt;Int&gt; 由 Array 的初始化方法提供，</span></span><br><span class="line"><span class="comment">// 所以可以不写。</span></span><br><span class="line"><span class="comment">// 由于 fmap 实际上是 (F&lt;A&gt;, A -&gt; B) -&gt; F&lt;B&gt; 的 currying 版本，</span></span><br><span class="line"><span class="comment">// 所以两者是等价的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;, f: A -&gt; B)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</span><br></pre></td></tr></table></figure>
<p>再来看看 Swift 中的 <code>Array</code> 和 <code>Optional</code>。如果把 Swift 中所有的类型 <code>A, B</code> 当作对象，以及 Swift 中所有的函数当作态射 <code>A -&gt; B</code>，那么这些类型和函数就组成一个范畴 A。把 <code>Array</code> 类型当作对象 <code>Array&lt;A&gt;, Array&lt;B&gt;</code>，<code>Array</code> 上所有的函数当作态射 <code>Array&lt;A&gt; -&gt; Array&lt;B&gt;</code>，那么也组成一个范畴 B。而 A 到 B 之间的函子是 <code>Array</code>，因为函子 <code>Array</code> 能将任意类型 <code>T</code> 转换为 <code>Array&lt;T&gt;</code>。<code>Optional</code> 同理。</p>
<p>很多库对 <code>Functor</code> 的支持直接在类型构造器（Type Constructor）的定义中实现 <code>map</code> 方法，比如 Swift 中的 <code>Array</code> 和 <code>Optional</code> 就是需要一个泛型作为参数来构建具体类型的类型构造器，它在定义中实现了 <code>map</code> 方法。这些类型构造器相当于同时具备了类型和函数的映射。在 Haskell 里把这个行为称为 <code>Lift</code>，相当于把类型和函数放到容器里面。所以一个带有 <code>map</code> 方法的类型构造器就是一个函子。</p>
<p>范畴与高阶类型：如果忽略范畴中的态射，范畴其实就是对特定类型的抽象，即高阶类型（类型构造器）。对于范畴 D，它的所有类型都是 <code>Array&lt;T&gt;</code> 的特定类型。而对于范畴 C，可以看作是一个 Identity 类型的构造器（id[T] = T）。</p>
<p>注意⚠️：函子不是容器，函子不是容器，函子不是容器。<br>如 <code>typealias Parser&lt;A&gt; = (String) -&gt; (A, String)?</code> 我们可以实现 <code>func map&lt;A, B&gt;(x: Parser&lt;A&gt;, f: (A) -&gt; B) -&gt; Parser&lt;B&gt;</code> 函数，所以我们可以说 <code>Parser&lt;A&gt;</code> 是一个函子，但它不是容器。</p>
<h3 id="Endofunctor"><a href="#Endofunctor" class="headerlink" title="Endofunctor"></a>Endofunctor</h3><blockquote>
<p>A functor that maps a category to itself。一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
</blockquote>
<p>先看自函数的概念：将一个类型映射到自身类型，如 <code>Int -&gt; Int</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>单位函数（Identity Function）的概念：什么都不做，传入什么就返回什么。属于自函数的特例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">id</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x &#125;</span><br></pre></td></tr></table></figure>
<p><strong>自函子不是单位函子（Identity Functor）</strong>。还是上面的范畴 C，为了区分自函子和单位函子，多加一种态射 g: <code>String -&gt; Int</code>，那么：</p>
<p>自函子：对于函子 F，对于 <code>F(Int)</code> 结果是 <code>String</code>，<code>F(String)</code> 结果是 <code>Int</code>，对于 <code>F(f: Int -&gt; String)</code> 结果是 g: <code>String -&gt; Int</code>。那么这个函子就是自函子。</p>
<p>单位函子（Identity Functor）：对于函子 F，对于 <code>F(Int)</code> 结果还是 <code>Int</code>，对于 <code>F(String)</code> 结果还是 <code>String</code>，对于 <code>F(f: Int -&gt; String)</code> 结果还是 <code>f: Int -&gt; String</code>，对于 <code>F(g: String -&gt; Int)</code> 结果还是 g: <code>String -&gt; Int</code>。那么这个函子就是单位函子。 </p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><blockquote>
<p>An applicative is a monoid in the category of endofunctors, what’s the problem?</p>
</blockquote>
<p>虽然在 Haskell 中 Monad 是 Applicative 的一种，但是 Applicative 的出现却在 Monad 之后。</p>
<p><a href="https://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/" target="_blank" rel="noopener">Applicative</a></p>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><blockquote>
<p>A monad is a monoid in the category of endofunctors – Philip Wadler</p>
</blockquote>
<p>自函子说穿了就是把一个范畴映射到自身的函子，自函子范畴说穿了就是从小范畴映射到自身的函子所构成的以自函子为对象以自然变换为态射的范畴，幺半群说穿了就是只有单个对象的范畴，给定了一个幺半群则可构造出一个仅有单个对象的小范畴使其态射由幺半群的元素给出而合成由幺半群的运算给出，而单子说穿了就是自函子范畴上的这样一个幺半群。（这都不理解么亲连这种最基本的概念都不理解还学什么编程！</p>
<p>一系列 Endofunctor 组成的范畴，成为 <strong>自函子范畴</strong>。</p>
<ul>
<li>X 上的自函子：F：<code>X -&gt; X</code></li>
<li>单位自函子 id[X] 到函子 F 的自然转换：<code>id[X] -&gt; F</code> (pure</li>
<li>函子 F 的张量积 F⊗F 到函子 F 的自然转换：<code>F⊗F -&gt; F</code> (join</li>
</ul>
<p>代码表示：</p>
<ul>
<li><code>func unit&lt;T&gt;(x: T) -&gt; F&lt;T&gt; // x = id[x]</code> </li>
<li><code>func join&lt;T&gt;(a: F&lt;F&lt;T&gt;&gt;) -&gt; F&lt;T&gt;</code></li>
</ul>
<p>此处函子的张量积 ⊗ 可以看作为组合（Composition）；<br>注意结合 Monoidal Category 理解，<code>unit</code> 和 <code>join</code> 满足 Monoid 的定律，所有形成了 Monoid。</p>
<p>也就是说：单子（Monad）是自函子的 Monoidal 范畴上的一个幺半群，该 Monoidal 范畴的张量积（Tensor Product，⊗：F×F -&gt; F）是自函子的复合（Composition），单位元是 Id Functor。</p>
<p><code>bind</code> 或者说 <code>flatMap</code> 或者 <code>&gt;&gt;=</code> 其实等于 <code>map + join</code>。（见 <a href="https://github.com/apple/swift" target="_blank" rel="noopener">apple/swift</a> 中的 <code>stdlib/public/core/FlatMap.swift</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;=&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;, f: A -&gt; F&lt;B&gt;)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</span><br><span class="line"><span class="comment">// Currying 前的样子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;=&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;)</span></span> -&gt; (f: <span class="type">A</span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Too much</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/28/parser-combinator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/28/parser-combinator/" itemprop="url">Parser Combinator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T20:00:00+08:00">
                2017-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</p>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>将一个数据流解析成结构化的数据的工具，我们称为解析器。比如我们需要将用户输入的表达式字符串解析成 AST，我们就可以使用解析器来达到我们的目的。</p>
<p><code>( 4 + 3  )</code> 就是一个表达式语句，它由字符 <code>(</code>  <code>4</code> <code>空格</code> <code>+</code> <code>3</code> 和 <code>)</code> 组成。我们可以将这个表达式解析成一种 <em>表达式树</em> (AST 的一种)。</p>
<p>所以我们的解析器简单的用一个函数来描述就是：<br><code>func parser(_ string: String) -&gt; AST</code></p>
<p>我们不是用正则表达式来解析输入的表达式字符串，为了得到表达式树里面的节点，我们需要一步步的解析，每次解析得到不同的节点。所以我们需要将解析器的定义变成解析成功的话，会返回结果值和剩下的字符串。</p>
<p><code>func parser(_ string: String) -&gt; (AST, String)</code></p>
<p>表达式树的节点都是一些 <code>4</code> <code>+</code> 这种不同类型的数据，所以为了表示解析 <code>4</code> 成功和解析 <code>+</code> 成功，我们的返回值可以定义为泛型。并且表达出解析失败的情况，我们可以使用可选值。最终解析器函数就变成了：</p>
<p><code>func parser&lt;T&gt;(_ string: String) -&gt; (T, String)?</code></p>
<p>所以解析第一个数字 4 的解析器函数为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">String</span>)? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = string.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Optional</span>.some((<span class="number">4</span>, <span class="type">String</span>(string.characters.<span class="built_in">dropFirst</span>())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Combinator"><a href="#Combinator" class="headerlink" title="Combinator"></a>Combinator</h2><blockquote>
<p>One of the distinguishing features of functional programming is the widespread use of combinators to construct programs. <em>A combinator is a function which builds program fragments from program fragments</em>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. – John Hughes</p>
</blockquote>
<p>其实 Combinator 很容易理解，就像字面意思那样 —— 组合子。首先定义一系列原子操作，然后定义组合的规则，然后根据组合的规则把这些原子操作组合起来。</p>
<h2 id="Parser-Combinator"><a href="#Parser-Combinator" class="headerlink" title="Parser Combinator"></a>Parser Combinator</h2><p>回到开头的话：<em>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</em> 所以我们需要重新定义一下我们的解析器，把它变成一个解析组合子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parse: (<span class="type">String</span>) -&gt; (<span class="type">A</span>, <span class="type">String</span>)?</span><br><span class="line">    <span class="comment">// (input) -&gt; (result, remaining)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个解析字符串的解析器，我们把这个函数放到一个结构体 <code>Parser</code> 中，作为一个 <code>parse</code> 变量。当然我们也可以用类型别名 <code>typealias Parser&lt;Result&gt; = (String) -&gt; (Result, String)?</code>。</p>
<p>当然解析组合子不仅仅能解析字符串，所以可以用泛型来把它变得更通用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parse: (<span class="type">I</span>) -&gt; (<span class="type">O</span>, <span class="type">I</span>)?</span><br><span class="line">    <span class="comment">// (input) -&gt; (output, remaining input)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以解析数字字符 <code>4</code> 的解析器就变成了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">character4</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"4"</span>, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以根据 <code>func character4() -&gt; Parser&lt;Character&gt;</code> 很容易得到一个能够解析任何字符的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">character</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == character <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 的区别，很容易又得到能够解析任何数字的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digit</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, <span class="string">"0"</span>...<span class="string">"9"</span> ~= head <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 相同和不同，我们可以进一步抽象，把相同部分进行封装，把不同部分作为参数，得到新的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">satisfy</span><span class="params">(<span class="number">_</span> condition: @escaping <span class="params">(Character)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, condition(head) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以解析数字：</p>
<p><code>(satisfy { &quot;0&quot;...&quot;9&quot; ~= $0 }).parse(&quot;1abc&quot;)</code></p>
<p>解析空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSpace</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(character).trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines).isEmpty</span><br><span class="line">&#125;</span><br><span class="line">(satisfy(isSpace)).parse(<span class="string">" abc"</span>)</span><br></pre></td></tr></table></figure>
<p>所以我们只需要给 <code>satisfy</code> 函数传入一个是否属于 X 的函数，就可以得到一个能够解析 x 的解析器。</p>
<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>最基本的 <code>character</code> 有了，<code>digit</code> 有了，当我们需要解析一个字符串 <code>alex</code> 的时候，我们只需要把 <code>alex</code> 看成 <code>a</code> <code>l</code> <code>e</code> <code>x</code> 4 个字符，然后不断的用 <code>character</code> 进行解析，最后把每一步返回的结果合并起来就行了。考虑到解析一个字符串是一个基本功能，为了不用每次写重复的代码，把它封装成用来解析 <code>string</code> 的解析器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> parsers = str.characters.<span class="built_in">map</span> &#123; character($<span class="number">0</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">for</span> parser <span class="keyword">in</span> parsers &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = parser.parse(stream) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">String</span>(results), stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 parse 函数类型 <code>(String) -&gt; (A, String)</code>，解析成功的返回值是解析结果和 <strong>剩余</strong> 的字符串，所以解析 <code>alex</code> 的时候：</p>
<ol>
<li>“alex”: ‘a’ -&gt; (‘a’, “lex”)</li>
<li>“lex”: ‘l’ -&gt; (‘l’, “ex”)</li>
<li>“ex”: ‘e’ -&gt; (‘e’, “x”)</li>
<li>“x”: ‘x’ -&gt; (‘x’, “”)</li>
<li>Parser&lt;”alex”&gt;</li>
</ol>
<p>可以看到这几步做的事情除了参数不一样，内部逻辑是一样的，而且很容易看出是一个递归的过程，<strong>每次解析成功就 <code>吃掉</code> 第一个字符</strong>（留意这句话），然后解析剩下的字符串。</p>
<p>所以我们写一个递归的版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 0. 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 先解析第一个字符</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = character(head).parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 然后解析剩下的所有</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder2) = string1(<span class="type">String</span>(tail)).parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回("结果", "剩余的字符串")</span></span><br><span class="line">        <span class="keyword">return</span> (str, remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncons</span>&lt;C: Collection&gt;<span class="params">(<span class="number">_</span> xs: C)</span></span> -&gt; (<span class="type">C</span>.<span class="type">Iterator</span>.<span class="type">Element</span>, <span class="type">C</span>.<span class="type">SubSequence</span>)? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = xs.first <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (head, xs.suffix(from: xs.index(after: xs.startIndex)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 1 和 2，在这两步中，我们都没有使用解析的 <strong>结果</strong>，这两步实现的仅仅是 <strong>每次解析成功就 <code>吃掉</code> 结果</strong>！最后在第 3 步一次将结果返回。也就是说我们 1 和 2 这两本并不关心结果，只关心这些要解析道字符存在就行了。</p>
<p>我们把解析成功吃掉结果这一步封装一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只保留右边的解析器的结果 result2，没有 result1</span></span><br><span class="line">        <span class="keyword">return</span> (result2, remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>discarding</code> 函数会 <strong>吃掉</strong> 左边第一个参数 <code>x</code> 的解析结果，返回值中只保留右边 <code>y</code> 的解析结果。用 <code>discarding</code> 函数重写一下上面的 <code>string</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 吃掉 character(head) 的结果</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder) = discarding(character(head), string2(<span class="type">String</span>(tail))).parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 返回 ("结果", "剩余的字符串")</span></span><br><span class="line">        <span class="keyword">return</span> (str, remainder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次改版的 <code>string</code> 里面第 1 步中的解析结果还是被忽略了，所以是否可以继续用 <code>discarding</code> 来简化？但是 <code>discarding</code> 函数需要两个解析器，但函数内只有 <code>lift</code> 返回的一个解析器，所以没办法继续简化了？</p>
<p>仔细看 <code>string</code> 函数体的第一行 <code>return Parser {}</code> 就是一个解析器，能否把这个解析器利用上呢？<code>discarding</code> 是在 <code>Parser {}</code> 里面的，所以只要能想办法把它展平，那么就能再次利用上 <code>lift</code>，而且展平后的解析器需要做为 <code>string</code> 函数的返回值，所以它肯定是做为 <code>discarding</code> 的右边的参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lhs = <span class="type">Parser</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> lift(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据第 2 步的 <code>return (str, remainder)</code> 可以知道，最终的返回结果是 <code>(输入的，lhs 吃剩的)</code>，所以很容易得到 <code>let rhs = Parser&lt;String&gt; { (str, $0) }</code>。所以可以推出 lhs 要做的只是负责吃掉一部分。也就是上面的第 1 步所做的。所以：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">""</span>, input)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 吃掉</span></span><br><span class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</span><br><span class="line">    <span class="comment">// 3 结果和剩下的</span></span><br><span class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</span><br><span class="line">    <span class="comment">// 4 返回</span></span><br><span class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的返回值是 <code>Parser</code>，由于外面没有 Parser {} ，展开后 1 那里需要返回一个 <code>Parser</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (<span class="string">""</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明眼人可以看到 1 和 3 只有 <code>&quot;&quot;</code> 和 <code>str</code> 不一样，剩下的一模一样，虽然代码不长，但我们还是把它相同部分封装成一个函数，然后把不同的部分做为参赛。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">        <span class="keyword">return</span> pure(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> rhs = pure(str)</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lift a value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pure</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: A)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123; (x, $<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以封装一个简洁的 <code>string</code> 解析器，花了很多功夫，但抛开性能，它比迭代的版本更简洁易懂。</p>
<h2 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h2><p>观察表达式 <code>( 4 + 3  )</code>，里面 <code>(</code> 和 <code>4</code> 之间有 1 个空格，数字 <code>3</code> 和 <code>)</code> 中间是有 2 个空格，在做加法运算的时候，这些 <em>many</em> 个空格是没有意义的，所以需要 <em>skip</em> 掉。</p>
<h4 id="Many"><a href="#Many" class="headerlink" title="Many"></a>Many</h4><p>首先需要解析空格的解析器，前面已经有实现过：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">space</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> satisfy(isSpace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于空格数量未知，可能有 <em>many</em> 个，假如有一个解析器，能够解析 <em>many</em> 个 parser。用一个 loop 不断去解析就能实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">many</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">A</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (results, stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意个空格就是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many(space())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>spaces</code> 得到的是一个 <code>Parser&lt;[Character]&gt;</code> 类型的 parser，但是按照理解更希望得到一个 <code>Parser&lt;String&gt;</code> 类型的 parser。在 Swift 中，<code>String([Character])</code> 就能够将 <code>[Character]</code> 拍扁成 <code>String</code> 类型。所以把 <code>many</code> 稍微修改一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">many</span>&lt;Character&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;Character&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">String</span>(results), stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为不是任何泛型 A 类型，都能用 String 拍扁，也不一定能通过其他类型进行拍扁，所以这里把泛型 A 去掉，直接用 Character 代替。但是这样做并不理想，因为 <code>many</code> 解析器从一个泛型解析器，变成了一个只能解析 Character 类型的解析器，变成了 <code>manyCharacter</code>。后面考虑解析这个问题，重新把 <code>many</code> 变成通用的解析器。</p>
<h4 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h4><p>接着实现一个通用的 <code>skip</code> 解析器，它要做的事情很简单，输入什么吃掉什么，返回剩下的，和上面吃掉左边的 <code>discarding</code> 很像，不一样的是 <code>skip</code> 只有一个参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">skip</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((), input)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ((), remainder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 <code>skip</code> 和 <code>spaces</code> 进行组合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">skipSpaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> skip(spaces)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Many1"><a href="#Many1" class="headerlink" title="Many1"></a>Many1</h4><p>前面实现的 <code>digit</code> 解析器，它只能解析个位数，这是没有什么卵用的。相比 <code>digit</code>，更加需要的是一个 <code>number</code> 解析器。一个 <em>number</em> 实际上也是由 <em>many</em> 个 <em>digit</em> 组成。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many(digit())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">number().parse(<span class="string">"123abc"</span>) <span class="comment">// (["1", "2", "3"], "abc")</span></span><br><span class="line">number().parse(<span class="string">"abc"</span>) <span class="comment">// ([], "abc")</span></span><br></pre></td></tr></table></figure>
<p>等等！<code>number().parse(&quot;abc&quot;)</code> 也解析成功了，结果是空数组。这并不是想要的结果，一个 <em>string</em> 可以是空的，<em>space</em> 甚至也可以是空的，但一个 <em>number</em> 不能是空的。所以需要另外一个只是有一个的 <code>many</code>。这其实很常见，比如正则表达式中有 <code>*</code> 和 <code>+</code>，一个 {0, +} 一个是 {1, +}。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">many1</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 多加一个判断，第一个值必须满足条件</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">A</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (results, stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以正确的 <code>number</code> 解析器就变成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many1(digit())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>number</code> 解析器和 <code>spaces</code> 解析器遇到了同样的问题，<code>number</code> 解析器的结果应该是 <code>Int</code>（暂不考虑浮点数），而不是 <code>[Character]</code>。解决方法可以类似 <code>manyCharacter</code>，但是这显示是很有问题的，抽象抽象抽象！</p>
<p>程序员要有抽象思维，要学会用更高的层次的思维去看待问题，发现不同问题的共同点。<code>[Character]</code> 可以用 <code>String([Character])</code> 变成一个 <code>String</code>。对于 <code>digit</code> character，同样的也是用 <code>String([Character])</code> 拍扁，然后用 <code>Int(String)</code> 得到一个 <code>number</code>。</p>
<p>结合 Swift 的 OOP（面向协议编程），可以定义一个协议，暂且叫做 <code>Combinable</code> :D</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Combinable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Combinable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(<span class="type">String</span>(describing: xs))!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">Combinable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: xs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">many1</span>&lt;A: Combinable&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;Character&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">A</span>.combine(results), stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many1(digit())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many1(space()) <span class="comment">// 忽略 spaces 可以为空的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上 <code>skipSpaces</code> 还可以用另外一个角度来拆分，上面先解析 <em>many</em> 个空格，然后一次 <em>skip</em> 掉。还可以每次 <em>skip</em> 一个空格，然后进行 <em>many</em> 次。不同的地方是 <code>skip</code> 和 <code>many</code> 两个 parser 的调用次序不一样，甚至还可以定义一个叫做 <code>skipMany</code> 的解析器，这也说明了 <strong>Combinator</strong> 的强大。通过定义一系列基础的 parser，进行不同的排列组合操作，最后覆盖所有的 case。（理想状态</p>
<h4 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h4><p>合并两个 parser 的解析器 <code>zip</code> 的实现也很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zip</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;(<span class="type">A</span>, <span class="type">B</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ((result1, result2), remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Choice"><a href="#Choice" class="headerlink" title="Choice"></a>Choice</h4><p>接下来还需要解析几个简单的一元运算符 <code>+</code> <code>-</code> <code>*</code> <code>/</code>。去掉空格后，两个数中间必须是其中一个运算符那么表达式就是合法的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opt</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> opts = [<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>].<span class="built_in">map</span> &#123; character($<span class="number">0</span>.characters.first!) &#125;</span><br><span class="line">    <span class="keyword">return</span> choice(opts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以叫 one(of:)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice</span>&lt;A, S: Sequence&gt;<span class="params">(<span class="number">_</span> xs: S)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(empty(), &#123; $<span class="number">0</span> &lt;|&gt; $<span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span>&lt;A&gt;<span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>上面利用 Protocol 实现的 <code>number</code> 和 <code>space</code> 解析器其实并不是很优雅，费了很大劲把 <code>many</code> 变得 <del>通用</del>，结果却并不是很 <strong>通用</strong>，因为要求结果的类型必须实现 <code>Combinable</code> 协议。但它做的工作却很少，只是把传入的 <code>Parser&lt;A&gt;</code> 循环解析得到的结果 <code>[A]</code> 在 <code>many</code> <strong>内部</strong> 组合成最终的类型，实现把 <code>Parser&lt;[A]</code> 转换为 <code>Parser&lt;B&gt;</code>。正由于它是在 <code>many</code> 内部做的操作，所以依赖于传入的类型，使得 <code>many</code> 不再那么通用。</p>
<p>再看 <code>func character(_ character: Character) -&gt; Parser&lt;Character&gt;</code> 的定义，假如调用 <code>character(&quot;4&quot;)</code>，那么返回的是一个 <code>Parser&lt;Character&gt;</code> 类型的解析器，这个解析器调用 <code>parse</code> 方法，返回的结果是 <code>Character</code> 类型的值。在解析表达式 <code>4 + 3</code> 的时候，需要将解析到的 <code>4</code> 和 <code>3</code> 当作一个整数然后相加，才能得到最终的结果，所以不想要 <code>Character</code> 类型的值，而是想要 <code>Int</code> 类型的值，那么需要将 <code>Parser&lt;Character&gt;</code> 转换为 <code>Parser&lt;Int&gt;</code> 解析器。</p>
<p>所以，假如能实现一个函数，可以将任意 <code>Parser&lt;A&gt;</code> 转换为 <code>Parser&lt;B&gt;</code> 解析器，就完美了。<code>many</code> 只负责将 <code>Parser&lt;A&gt;</code> 解析得到 <code>Parser&lt;[A]&gt;</code>，然后由 <code>number</code> 自己将 <code>Parser&lt;[A]&gt;</code> 转换为 <code>Parser&lt;Int&gt;</code>。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><p>回忆 Swift 中 Optional 类型中的 map 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt; = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = a.<span class="built_in">map</span> &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>它将一个 <code>Optional&lt;Int&gt;</code> 转换为 <code>Optional&lt;String&gt;</code>，仔细一看，把 <code>Optional</code> 换成 <code>Parser</code>，就是我们所需要的转换解析器的方法。</p>
<p><code>Optional</code> 的函数签名是 <code>func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; U?</code>，所以依葫芦画瓢，我们可以得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;B&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = <span class="keyword">self</span>.parse(input) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">            <span class="keyword">return</span> (transform(result), remainder)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面的 <code>satisfy</code> 和其他函数一样，把 <code>map</code> 方法从结构图内移出来，则得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: @escaping <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = x.parse(input)<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (f(result), remainder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于值是在 <code>Parser</code> 中包裹着的，想把返回的 <code>Parser&lt;Character</code> 变成 <code>Parser&lt;Int&gt;</code>，需要把 <code>Parser&lt;Character&gt;</code> 解开取出里面<character>的值，然后把它变成<int>类型，然后重现包装起来。对于不同的类型转换，解包重新包装的步骤是一样的，不同的地方是把结果从一种类型变成另一种类型，函数的作用就是把相同的封装起来，把不同做为参赛传进去，所以在 <code>map</code> 函数的实现中，只需要在返回前，给外部将这个结果进行一次转换机会，所以需要一个参赛，能够将解开后得到的值变成另一种类型的值，也就是提供一个函数 <code>(Character) -&gt; Int</code>。</int></character></p>
<p>重新实现 <code>number</code> 和 <code>spaces</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(many1(digit()), &#123; <span class="type">Int</span>(<span class="type">String</span>($<span class="number">0</span>))! &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(many(space()), &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种不同的结构体 <code>Optional&lt;T&gt;</code> 和 <code>Parser&lt;A&gt;</code>，都可以给它实现一个 <code>map</code> 方法，使得它变成一个不同类型的结构体。而支持这种 <code>map</code> 方法的结构体，我们称把它为 <code>Functor</code>。</p>
<blockquote>
<p>简单来说，所谓的 <code>Functor</code> 就是可以把一个函数应用于一个 <strong>封装过的值</strong> 上，得到一个新的 <strong>封装过的值</strong></p>
</blockquote>
<p><code>Functor</code> 最早出自于代数拓扑，这里说的 <code>Functor</code> 一般是指范畴论（Category Theory）中的 <code>Functor</code>，它被用来描述各种范畴间的关系。更多 Functor 的理解 <a href="http://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">Group Theory and Category Theory</a>。</p>
<h3 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pure</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: A)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123; (x, $<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上前面的 <code>pure</code> 和 <code>discarding</code> 函数就是一种 Applicative。像 <code>discarding</code> 一样有时候只关心这些要解析道字符存在就行了，上面定义的 <code>discarding</code> 解析器作用是忽略第一个 parser 参数的解析结果，同样地，可以定义一个忽略第二个 parser 参数的解析器。比如当解析出现在右边的 symbol 的时候就很有用，<code>discarding2(parser, string(&quot;)&quot;))</code> 的作用就是确保存在闭合的右括号 “)”。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 吃掉右边的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding2</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只保留左边的解析器的结果 result1，没有 result2</span></span><br><span class="line">        <span class="keyword">return</span> (result1, remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 吃掉左边的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding1</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只保留右边的解析器的结果 result2，没有 result1</span></span><br><span class="line">        <span class="keyword">return</span> (result2, remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个 <code>discarding</code> 函数长的很像，如果有办法把它们抽象一下，把相似的地方提取出来就好了。</p>
<p>对于两个结果，忽略其中一个，实际上很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 忽略 B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">A</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 忽略 A</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">B</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 吃掉左边的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">left</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">discarding</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">A</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (discarding(result1, result2), remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这个函数并没有卵用。</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>观看 <code>map</code> 函数 <code>func map&lt;A, B&gt;(_ x: Parser&lt;A&gt;, _ f: (A) -&gt; B) -&gt; Parser&lt;B&gt;</code></p>
<p>它要求传入两个参数，一个是 <code>Parser&lt;A&gt;</code>，一个是函数 <code>A -&gt; B</code>，第二个参数对标题中的 <strong>Combinator</strong> 并不是很友好，<strong>Parser Combinator</strong> 的思想是组合一系列的 <code>Parser</code> 得到结果。上面定义了有很多小的 parser，比如 <code>func string(_ str: String) -&gt; Parser&lt;String&gt;</code>，函数签名是 <code>(String) -&gt; Parser&lt;String&gt;</code>，由于 <code>map</code> 函数的第二个参数的签名是 <code>(A) -&gt; B</code>，而非 <code>(A) -&gt; Parser&lt;B&gt;</code>，所以假如存在一个与 <code>map</code> 功能相似，但第二个参数的签名是 <code>(A) -&gt; Parser&lt;B&gt;</code>，则能够使得之前定义的很多小的 <code>parser</code> 能够直接作为一个参数，直接得到一个新类型的 <code>Parser</code>，大概这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: <span class="params">(A)</span></span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;</span><br></pre></td></tr></table></figure>
<p>使用的时候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parser = flatMap(stringParser, string(<span class="string">"alex"</span>))</span><br></pre></td></tr></table></figure>
<p>具体实现与 <code>map</code> 也很像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: @escaping <span class="params">(A)</span></span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = x.parse(input)<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(result).parse(remainder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">Group Theory and Category Theory</a></p>
<h3 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span>&lt;A&gt;<span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> x.parse(input) ?? y.parse(input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Alternative 类似于 <code>Swift Standard Library</code> 中定义的运算符 <code>??</code>，它有两个同类型的参数，第一个参数是偏爱的 <code>parser</code>，第二个参数是默认的 <code>parser</code>。它首先尝试使用第一个 <code>parser</code> 来进行解析，如果成功，则返回。如果不成功，则使用默认的 <code>parser</code> 进行解析。它的返回值类型也是同类型的 <code>Parser</code>。</p>
<p>作用是假如有 Int, String, Bool 三个类型的 <code>parser</code>，而一个 scalar 类型的 <code>parser</code> 只要能够解析 Int, String, Bool 任意一种类型，则算解析成功。换句话说就是 scalar 是 Int, String, Bool 的父集。一种简单的从 <code>Parser&lt;Int&gt;</code>, <code>Parser&lt;String&gt;</code>, <code>Parser&lt;Bool&gt;</code> 三种已有实现的 parser 得到 <code>Parser&lt;Scalar&gt;</code> 的方法是逐个进行 parse，如果成功则马上返回。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scalar = parserInt &lt;|&gt; parserString &lt;|&gt; parserBool</span><br></pre></td></tr></table></figure>
<p>从这个例子看有点 one of 的意思，但实际上更加准确的说法是 choice。</p>
<h3 id="Applicative-amp-Monad"><a href="#Applicative-amp-Monad" class="headerlink" title="Applicative &amp; Monad"></a>Applicative &amp; Monad</h3><p>Applicative 和 Monad 的区别在于：</p>
<p>Applicative 的两个 parser 是相互独立的，组合后的新 parser 是可以静态分析其行为的。而对于 Monad，在不知道输入的情况下，是不能确定其行为，也就是说 Monad 是依赖于计算结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alex</span><span class="params">(<span class="number">_</span> x: Parser&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(<span class="string">"alex.huo"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> af: <span class="type">Parser</span>&lt;(<span class="type">String</span>) -&gt; <span class="type">String</span>&gt; = pure(id)</span><br><span class="line"><span class="keyword">let</span> ax = string(<span class="string">"alex"</span>)</span><br><span class="line">alex(af &lt;*&gt; ax) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mf: (<span class="type">String</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; = &#123; string($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> mx = string(<span class="string">"alex"</span>)</span><br><span class="line">alex(mx &gt;&gt;- mf) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/hlian/jiffy" target="_blank" rel="noopener">Jiffy</a><br><a href="https://news.realm.io/news/tryswift-yasuhiro-inami-parser-combinator/" target="_blank" rel="noopener">Parser combinators</a><br><a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf" target="_blank" rel="noopener">Monadic Parser Combinators</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/20/cherry-blessing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/cherry-blessing/" itemprop="url">Cherry Blessing</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T20:00:00+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to Cherry Blessing.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Xspyhack">
          <p class="site-author-name" itemprop="name">Xspyhack</p>
           
              <p class="site-description motion-element" itemprop="description">Why join the navy if you can be a pirate?</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xspyhack</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
