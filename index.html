<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Why join the navy if you can be a pirate?">
<meta property="og:type" content="website">
<meta property="og:title" content="Cherry Blessing">
<meta property="og:url" content="https://blessingsoft.com/index.html">
<meta property="og:site_name" content="Cherry Blessing">
<meta property="og:description" content="Why join the navy if you can be a pirate?">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cherry Blessing">
<meta name="twitter:description" content="Why join the navy if you can be a pirate?">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blessingsoft.com/"/>





  <title>Cherry Blessing</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cherry Blessing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">A monad is a monoid in the category of endofunctors</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2018/08/26/pats/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/pats/" itemprop="url">PATs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T01:59:26+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>待续</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2018/08/26/logging-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/logging-system/" itemprop="url">How to design a lightweight Logging System</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T01:37:03+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>之前项目一直都是使用 <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="external">CocoaLumberjack</a> 来定制 Log 系统，这次整个工程使用 Pure-Swift 来开发，而且作为一个初创项目，对于 Log 系统的需求并没有那么高，虽然 <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="external">CocoaLumberjack</a> 在 Swift 项目中直接使用也比较友好，但是感觉还是 <del>太重了</del> 。所以为何不直接设计一个比较轻量级的日志系统呢？</p>
</blockquote>
<h2 id="Logging-System"><a href="#Logging-System" class="headerlink" title="Logging System"></a>Logging System</h2><p>在 iOS 中，可以用 Swift 中的 <code>print()</code> 和 <code>debugPrint()</code> 函数来向 Xcode Console 来打印信息，也可以使用 Foundation 中的 <code>NSLog()</code> 来打印，更新的就是 <a href="https://developer.apple.com/documentation/os/logging" target="_blank" rel="external">os_log</a> 了。这三种不同的方式有不同的特点。</p>
<ul>
<li><strong>print</strong>/<strong>debugPrint</strong>: Swift 语言层面提供的实现，可以输出到 Xcode Console，但不能输出到 Apple System Logs（Mac Console.app）。</li>
<li><strong>NSLog</strong>: Foundation 中的实现，除了能在 Xcode Console 中输出外，还会往 Console.app 发，并且有较大的性能损害。</li>
<li><strong>os_log</strong>: 待补充 <a href="https://developer.apple.com/videos/play/wwdc2016/721/" target="_blank" rel="external">Unified Logging and Activity Tracing - WWDC 2016 - Videos - Apple Developer</a> <a href="https://developer.apple.com/videos/play/wwdc2018/405/" target="_blank" rel="external">Measuring Performance Using Logging - WWDC 2018 - Videos - Apple Developer</a></li>
</ul>
<p>Xcode Console 和 Apple System Logs 都是需要物理接触设备才能看到 log。但是在项目中，如果想要看到线上用户的 log 信息，必须要把这些 log 写到本地文件中，或者实时/定时发到远端服务器上。这时候直接使用内置的 API 是无法满足需求的。</p>
<p>对于一个相对比较合理的日志系统，一般有几点要求：</p>
<ul>
<li>在 release 下禁止输出日志到 Xcode Console</li>
<li><del>在 release 下</del> 禁止输出日志到 Apple System Logs</li>
<li>提供输出日志到本地文件中的能力</li>
<li>能够方便的扩展，如直接输出到 Web</li>
<li>对于日志根据重要性划分为不同的等级</li>
<li>可以根据日志等级，过滤日志</li>
</ul>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h3><p>Level 有两个作用：</p>
<ul>
<li>定义一条日志的重要性</li>
<li>对日志进行过滤，比如过滤掉某个等级以下的日志（实际是有包含的关系</li>
</ul>
<p>这里通过两个类型来实现 level 的作用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Level</span>: <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> off = <span class="number">0</span></div><div class="line">    <span class="keyword">case</span> error = <span class="number">1</span> <span class="comment">// Flag.error | Level.off</span></div><div class="line">    <span class="keyword">case</span> warning = <span class="number">3</span> <span class="comment">// Flag.warning | Level.error</span></div><div class="line">    <span class="keyword">case</span> info = <span class="number">7</span> <span class="comment">// Flag.info | Level.warning</span></div><div class="line">    <span class="keyword">case</span> debug = <span class="number">15</span> <span class="comment">// Flag.debug | Level.info</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Flag</span>: <span class="title">OptionSet</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> rawValue: <span class="type">Int</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> error = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// 1</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> warning = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 2</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> info = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// 4</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> debug = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">3</span>) <span class="comment">// 8</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.rawValue = rawValue</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Message-amp-Formatter"><a href="#Message-amp-Formatter" class="headerlink" title="Message &amp; Formatter"></a>Message &amp; Formatter</h3><p>一条日志如果只有正文部分，很难帮助定位具体的位置和发生的时间点，所以一条更加有意义的日志，会带上所在的文件、函数、行数以及时间戳等信息。</p>
<p>首先定义一个 <code>Message</code> 的数据结构来定义一条日志，这些信息最终具体如何 format 成一条字符串，需要提供一个 <code>Formatter</code> 来实现。</p>
<p>既然是 Pure-Swift，所以这里 <code>Message</code> 使用 <code>struct</code> （Value Type），而不是 <code>class</code> （Reference Type）。（<code>Codable</code>, <code>CustomStringConvertible</code>, <code>Equatable</code> 什么的暂时不需要考虑。</p>
<p>对于 <code>Formatter</code>，可能不同的 logger 需要不同的 format，比如输出到本地文件的 logger 需要更详细的信息，比如时间戳，才好帮助日后还原 app 当时运行的情况，而输出到 Xcode Console 的日志一般是在开发的时候看的，所以时间戳可能就没那么重要。（为什么 <code>Formatter</code> 使用 <code>protocol</code>？可以先想想，后面再解释。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Message</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> message: <span class="type">String</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> level: <span class="type">Level</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> flag: <span class="type">Flag</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> context: <span class="type">Int</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> file: <span class="type">String</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> function: <span class="type">StaticString</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> line: <span class="type">UInt</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> timestamp: <span class="type">Date</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Formatter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(message: Message)</span></span> -&gt; <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>根据日志输出的目标不同，可以划分为不同类型的 logger，比如 <code>ConsoleLogger</code>、<code>FileLogger</code> 以及 <code>WebLogger</code> 等。每一种不同的 logger 都有一些同样的接口，所以第一反应有两种不同的方式来实现类型的划分以及相同接口（行为）的约束。</p>
<p>使用面向对象的思想，通过继承来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Logging</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> console</div><div class="line">        <span class="keyword">case</span> file</div><div class="line">        <span class="keyword">case</span> web</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</div><div class="line">        <span class="keyword">return</span> .console</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    open <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</div><div class="line">        <span class="built_in">fatalError</span>(<span class="string">"must override this method in subclass."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span>: <span class="title">Logging</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> open <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</div><div class="line">        <span class="keyword">return</span> .console</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> open <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span>: <span class="title">Logging</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> open <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</div><div class="line">        <span class="keyword">return</span> .file</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> open <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用面向协议的思想，通过协议来约束行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Logging</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> type: <span class="type">Type</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogger</span>: <span class="title">Logging</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</div><div class="line">        <span class="keyword">return</span> .console</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileLogger</span>: <span class="title">Logging</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</div><div class="line">        <span class="keyword">return</span> .file</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种不同的实现，体现的是两种不同的思想：</p>
<ul>
<li>一种是使用面向对象的思想，通过一个基类来提供相同的接口，然后子类重写这些接口来提供不同的能力；</li>
<li>另一种是使用面向协议的思想，通过一个协议来对接口进行约束，每一个具体的实现都必须实现这些接口来提供不同都能力。</li>
</ul>
<p>而对于不同类型的 logger 都共有的行为，前一种方式可以直接在基类中实现，后一种方式可以通过 <code>protocol extension</code> 来提供默认实现。</p>
<p>两种方式各有优缺点，如果你也不喜欢前一种 <strong>需要运行时才能知道子类必须重写父类的某个方法</strong>，完全不能体现出 Swift 作为一门有着强大类型安全的静态语言的优势，那么这里毫不犹豫的选择后一种方式。（不解释</p>
<p>对于这里的 <code>Type</code>，虽然使用 <code>enum</code> 有着很好的强类型信息，但这样写有着很大的约束，就是一开始就必须定义好所有的 Type，对于扩展性来说，非常不友好。</p>
<p>所以综合可扩展性和 <code>Type</code> 的作用考虑，这里通过添加一个 <code>String</code> 类型的属性 <code>name</code> 来简单的区分。（很方便于 debug</p>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>最终得到一整个 Logging 相关的接口定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Logging</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> formatter: <span class="type">Formatter</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> level: <span class="type">Level</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message: Message)</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flush</span><span class="params">()</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Logging</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Unified"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flush</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>前面定义了每个不同 <code>logger</code> 的接口（行为），但是使用的时候，如果需要手动调用每个 <code>logger</code> 的 <code>log(message:)</code> 方法，那就太没有意义了。所以需要一个数据结构，来管理所有的 <code>logger</code>，并且将消息转发到每一个 <code>logger</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Logger</span>()</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.xspyhack.logger.queue"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> loggers: <span class="type">Set</span>&lt;<span class="type">AnyLogger</span>&gt; = []</div><div class="line"></div><div class="line">    <span class="keyword">deinit</span> &#123;</div><div class="line">        loggers.forEach &#123;</div><div class="line">            $<span class="number">0</span>.teardown()</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        loggers = []</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> logger: Logging)</span></span> &#123;</div><div class="line">        loggers.update(with: logger)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message: Message, asynchronous: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> work = <span class="type">DispatchWorkItem</span> &#123;</div><div class="line">            <span class="keyword">self</span>.loggers.forEach &#123; logger <span class="keyword">in</span></div><div class="line">                <span class="keyword">guard</span> message.flag.rawValue &amp; logger.level.rawValue != <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span></div><div class="line">                &#125;</div><div class="line">                logger.log(message: message)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> asynchronous &#123;</div><div class="line">            queue.async(execute: work)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            queue.sync(execute: work)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;</div><div class="line">        loggers.forEach &#123;</div><div class="line">            $<span class="number">0</span>.start()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flush</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> work = <span class="type">DispatchWorkItem</span> &#123;</div><div class="line">            <span class="keyword">self</span>.loggers.forEach &#123; logger <span class="keyword">in</span></div><div class="line">                logger.flush()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        queue.sync(execute: work)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只是比较粗糙的实现，很多细节还没有处理，比如 <code>loggers</code> 的线程安全问题、以及 <code>logger</code> 的删除等等。</p>
<h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p>有了 <code>Logging</code> 来定义每一种不同作用的 <code>logger</code>，以及一个管理所有 <code>logger</code> 的管理器 <code>Logger</code>（至于这个让人懵逼的命名，实际是因为懒，取一个别的名字比较适合，比如 <del>Charmander</del>），还需要考虑最终如何简单的使用这个 Logging System。</p>
<p>现在如果要使用这个系统，首先需要实现自己的多种 <code>loggers</code> 和对应的 <code>Formatter</code>，然后添加到 <code>Logger</code> 里面，然后在需要打 log 的地方，初始化 一个 <code>Message</code>，调用 <code>Logger.shared.log(message:)</code> 方法。</p>
<p>这里每次初始化一个 <code>Message</code> 太麻烦了。如何简化？默认参数啊。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>, level: <span class="type">Level</span>, flag: <span class="type">Flag</span>, context: <span class="type">Int</span> = <span class="number">0</span>, file: <span class="type">String</span> = #file, function: <span class="type">StaticString</span> = #function, line: <span class="type">UInt</span> = #line, asynchronous: <span class="type">Bool</span> = <span class="literal">false</span>) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> message = <span class="type">Message</span>(message: message(), level: level, flag: flag, context: context, file: file, function: function, line: line, timestamp: <span class="type">Date</span>())</div><div class="line"></div><div class="line">    <span class="type">Logger</span>.shared.log(message: message, asynchronous: asynchronous)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 <code>level</code> 和 <code>flag</code> 如果能提供默认参数，那么在调用的时候，就可以像 <code>print</code> 一样，直接只关注要 log 的内容就好了。一个比较简单直接的方法，就是针对这几种 <code>level</code> 暴露多个方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">Log</span>.d(<span class="string">"This is a debug level log"</span>)</div><div class="line"><span class="type">Log</span>.i(<span class="string">"This is an info level log"</span>)</div><div class="line"><span class="type">Log</span>.w(<span class="string">"This is a warning level log"</span>)</div><div class="line"><span class="type">Log</span>.e(<span class="string">"This is an error level log"</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>一个思考，上面的 <code>log</code> 函数中参数 message 的类型为什么使用 <code>@autoclosure</code>？</p>
<p>第二个思考，<code>Swift.print</code> 函数的定义你知道吗？</p>
</blockquote>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p><a href="https://github.com/xspyhack/Logger" target="_blank" rel="external">GitHub - xspyhack/Logger: A lightweight logging library written in Swift.</a></p>
<h3 id="Why-AnyLogger"><a href="#Why-AnyLogger" class="headerlink" title="Why AnyLogger"></a>Why AnyLogger</h3><p>对于引入 <code>AnyLogger</code>，是因为我希望能够提供移除一个 <code>logger</code> 的能力，用处就是当我在脱离 Xcode 的时候，可以通过一种可以输出到浏览器的 <code>logger</code> 来实时看到日志输出。而这个名为 <code>WebLogger</code> 的 <code>logger</code> 平时并不会用到，所以它是需要的时候才添加进去，用完之后便移除，所以就涉及到 <code>logger</code> 必须实现 <code>Equatable</code>，实现从 <code>loggers</code> 里面移除它。</p>
<blockquote>
<p>Why <code>protocol Logging: Equatable {}</code> needs <code>AnyLogger</code>？见另一篇 <a href="http://blessingsoft.com/2018/08/26/pats/">PATs</a></p>
</blockquote>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="external">GitHub - CocoaLumberjack/CocoaLumberjack: A fast &amp; simple, yet powerful &amp; flexible logging framework for Mac and iOS</a></li>
<li><a href="https://github.com/onevcat/Kingfisher/blob/master/Sources/ImageCache.swift" target="_blank" rel="external">Kingfisher/ImageCache.swift at master · onevcat/Kingfisher · GitHub</a></li>
<li><a href="https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/AnyHashable.swift" target="_blank" rel="external">swift/AnyHashable.swift at swift-3.0-branch · apple/swift · GitHub</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/08/10/plist-parser/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/plist-parser/" itemprop="url">Plist Parser</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T22:38:54+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Plist 是 Apple 家平台上一种很常见的配置文件，常见的存储格式是常见的 XML 格式（还有 Binary 格式），不同于 HTML 的复杂，Plist 只包含了比较少的几种标签（tag），所以实现使用 functional 的 parser combinator 来实现一个简单的 plist parser 也是一件很有意思的事情。</p>
<h2 id="Plist"><a href="#Plist" class="headerlink" title="Plist"></a>Plist</h2><p>一个 Plist 文件内容长这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;dict&gt;</div><div class="line">    &lt;key&gt;number&lt;/key&gt;</div><div class="line">    &lt;integer&gt;0&lt;/integer&gt;</div><div class="line">    &lt;key&gt;date&lt;/key&gt;</div><div class="line">    &lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;</div><div class="line">    &lt;key&gt;data&lt;/key&gt;</div><div class="line">    &lt;data&gt;VGVzdFZhbHVl&lt;/data&gt;</div><div class="line">    &lt;key&gt;boolean&lt;/key&gt;</div><div class="line">    &lt;true/&gt;</div><div class="line">    &lt;key&gt;array&lt;/key&gt;</div><div class="line">    &lt;array&gt;</div><div class="line">        &lt;string&gt;string&lt;/string&gt;</div><div class="line">        &lt;false/&gt;</div><div class="line">        &lt;integer&gt;0&lt;/integer&gt;</div><div class="line">    &lt;/array&gt;</div><div class="line"> &lt;/dict&gt;</div></pre></td></tr></table></figure>
<p><a href="https://zh.wikipedia.org/zh-hans/属性列表" target="_blank" rel="external">wikipedia</a> 上列出了一个详细的 <code>XML</code> 标签和 macOS/iOS 中的类型关系以及存储格式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Foundation 类</th>
<th style="text-align:left">Core Foundation 类型</th>
<th style="text-align:left">XML 标签</th>
<th style="text-align:left">储存格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NSString</td>
<td style="text-align:left">CFString</td>
<td style="text-align:left">&lt;string&gt;</td>
<td style="text-align:left">UTF-8 编码的字符串</td>
</tr>
<tr>
<td style="text-align:left">NSNumber</td>
<td style="text-align:left">CFNumber</td>
<td style="text-align:left">&lt;real&gt;, &lt;integer&gt;</td>
<td style="text-align:left">十进制数字符串</td>
</tr>
<tr>
<td style="text-align:left">NSNumber</td>
<td style="text-align:left">CFBoolean</td>
<td style="text-align:left">&lt;true/&gt;, or &lt;false/&gt;</td>
<td style="text-align:left">无数据（只有标签）</td>
</tr>
<tr>
<td style="text-align:left">NSDate</td>
<td style="text-align:left">CFDate</td>
<td style="text-align:left">&lt;date&gt;</td>
<td style="text-align:left">ISO 8601 格式的日期字符串</td>
</tr>
<tr>
<td style="text-align:left">NSData</td>
<td style="text-align:left">CFData</td>
<td style="text-align:left">&lt;data&gt;</td>
<td style="text-align:left">Base64 编码的数据</td>
</tr>
<tr>
<td style="text-align:left">NSArray</td>
<td style="text-align:left">CFArray</td>
<td style="text-align:left">&lt;array&gt;</td>
<td style="text-align:left">可以包含任意数量的子元素</td>
</tr>
<tr>
<td style="text-align:left">NSDictionary</td>
<td style="text-align:left">CFDictionary</td>
<td style="text-align:left">&lt;dict&gt;</td>
<td style="text-align:left">交替包含 &lt;key&gt; 标签和 plist 元素标签</td>
</tr>
</tbody>
</table>
<p>根据这个表格，我们可以定义出 Plist 的数据结构。</p>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// The plist data model</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PLIST</span> </span>&#123;</div><div class="line">    <span class="comment">/// &lt;true/&gt; or &lt;false/&gt;</span></div><div class="line">    <span class="keyword">case</span> bool(<span class="type">Bool</span>)</div><div class="line">    </div><div class="line">    <span class="comment">/// 2017-08-05T14:25:14Z</span></div><div class="line">    <span class="keyword">case</span> date(<span class="type">Date</span>)</div><div class="line">    </div><div class="line">    <span class="comment">/// &lt;data&gt;VGVzdFZhbHVl&lt;/data&gt; (&lt;54657374 56616c75 65&gt;</span></div><div class="line">    <span class="keyword">case</span> data(<span class="type">Data</span>)</div><div class="line">    </div><div class="line">    <span class="comment">/// &lt;integer&gt;233&lt;/integer&gt; or &lt;real&gt;2.33&lt;/real&gt;</span></div><div class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</div><div class="line">    </div><div class="line">    <span class="comment">/// &lt;string&gt;string&lt;/string&gt;</span></div><div class="line">    <span class="keyword">case</span> string(<span class="type">String</span>)</div><div class="line">    </div><div class="line">    <span class="comment">/// &lt;array&gt;&lt;string&gt;The String&lt;/string&gt;&lt;/array&gt;</span></div><div class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> array([<span class="type">PLIST</span>])</div><div class="line">    </div><div class="line">    <span class="comment">/// &lt;dict&gt;&lt;key&gt;The Key&lt;/key&gt;&lt;string&gt;The String&lt;/string&gt;&lt;/dict&gt;</span></div><div class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> dict([<span class="type">String</span>: <span class="type">PLIST</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>根据 Plist data model，想要解析一个 Plist 字符串 得到 <code>PLIST</code> 类型，只需要一个 <code>parser</code>。</p>
<p>没错，只需要一个 parser，这个 parser 大概长这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> parser: <span class="type">Parser</span>&lt;<span class="type">PLIST</span>&gt;</div><div class="line"><span class="keyword">let</span> result = parser.parse(<span class="string">"plist"</span>)</div></pre></td></tr></table></figure>
<p>这个 <code>let parser: Parser&lt;PLIST&gt;</code> 的实现才是最关键的。一个 <code>PLIST</code> 是由 <code>Bool</code> <code>Date</code> <code>Data</code> <code>Number</code> <code>String</code> 5 种简单的类型和 <code>Array&lt;PLIST&gt;</code> <code>Dictionary&lt;PLIST&gt;</code> 2 种容器（nested）类型组成，所以一个 <code>Parser&lt;PLIST&gt;</code> 也是由对应的 <code>Parser&lt;Bool&gt;</code> <code>Parser&lt;Date&gt;</code> <code>Parser&lt;Data&gt;</code> <code>Parser&lt;Number&gt;</code> <code>Parser&lt;String&gt;</code> 5 中简单的 parser 和 <code>Parser&lt;Array&gt;</code> <code>Parser&lt;Dictionary&gt;</code> 2 种容器类型 parser 组成。</p>
<h3 id="Bool-Parser"><a href="#Bool-Parser" class="headerlink" title="Bool Parser"></a>Bool Parser</h3><p>在 Plist 中，Bool 类型由两种形式 <code>&lt;true/&gt;</code> 和 <code>&lt;false/&gt;</code>，所以一个 Bool 类型的 parser 也就是能够解析字符串 <code>&lt;true/&gt;</code> 和 <code>&lt;false/&gt;</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _true = string(<span class="string">"&lt;true/&gt;"</span>) &lt;&amp;&gt; const(<span class="type">PLIST</span>.bool(<span class="literal">true</span>))</div><div class="line"><span class="keyword">let</span> _false = string(<span class="string">"&lt;false/&gt;"</span>) &lt;&amp;&gt; const(<span class="type">PLIST</span>.bool(<span class="literal">false</span>))</div><div class="line"></div><div class="line"><span class="keyword">let</span> _bool = _true &lt;|&gt; _false</div><div class="line">_bool.parse(<span class="string">"&lt;false/&gt;"</span>)</div></pre></td></tr></table></figure>
<h3 id="Date-Parser"><a href="#Date-Parser" class="headerlink" title="Date Parser"></a>Date Parser</h3><p>Plist 中的 Date 类型存储的是 UTC 字符串，如 <code>&lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;</code>。字符串中的开始标签 <code>&lt;date&gt;</code> 和结束标签 <code>&lt;/date&gt;</code> 对于解析的结果来说是没有用的，所以一个 Date 类型的 parser 是要将这个字符串解析成 <code>PLIST.date(date)</code>, date 为 2017-08-05T14:25:14Z 通过 format 得到。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _date = string(<span class="string">"&lt;date&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/date&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.date(<span class="type">String</span>($<span class="number">0</span>).date!) &#125;</div><div class="line">_date.parse(<span class="string">"&lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;"</span>)</div><div class="line"></div><div class="line"><span class="comment">/// UTC Date</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> date: <span class="type">Date</span>? &#123;</div><div class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</div><div class="line">        formatter.dateFormat = <span class="string">"yyyy-MM-dd'T'HH:mm:ss'Z'"</span></div><div class="line">        <span class="keyword">return</span> formatter.date(from: <span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Data-Parser"><a href="#Data-Parser" class="headerlink" title="Data Parser"></a>Data Parser</h3><p>Plist 中的 Data 类型存储的是 Base64 编码后的数据，所以实现一个 Data Parser 和 Date Parser 差不多，区别是 tag 和 Data 类型初始化。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _data = string(<span class="string">"&lt;data&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/data&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.data(<span class="type">Data</span>(base64Encoded: <span class="type">String</span>($<span class="number">0</span>))!) &#125;</div><div class="line"><span class="keyword">let</span> dataString = _data.parse(<span class="string">"&lt;data&gt;VGVzdFZhbHVl&lt;/data&gt;"</span>)</div></pre></td></tr></table></figure>
<h3 id="Number-Parser"><a href="#Number-Parser" class="headerlink" title="Number Parser"></a>Number Parser</h3><p>Plist 中的 Number 的存储实际上分两种。一种是整型，一种是浮点型。整型的 <code>tag</code> 是 <code>integer</code>，浮点型是 <code>real</code>。</p>
<p>先看 Integer Parser：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _integer = string(<span class="string">"&lt;integer&gt;"</span>) *&gt; manyTill(_digit, string(<span class="string">"&lt;/integer&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.number(<span class="type">Int</span>(<span class="type">String</span>($<span class="number">0</span>))!) &#125;</div></pre></td></tr></table></figure>
<h3 id="String-Parser"><a href="#String-Parser" class="headerlink" title="String Parser"></a>String Parser</h3><p>String Parser 和 Date Parser 以及 Data Parser 对比起来更简单，实际上就是去掉了最后转换的那一步。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _string = string(<span class="string">"&lt;string&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/string&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.string(<span class="type">String</span>($<span class="number">0</span>)) &#125;</div><div class="line">_string.parse(<span class="string">"&lt;string&gt;The String&lt;/string&gt;"</span>)</div></pre></td></tr></table></figure>
<h3 id="Tag-Parser"><a href="#Tag-Parser" class="headerlink" title="Tag Parser"></a>Tag Parser</h3><p>通过对比上面几种除了 Bool Parser 之外不同类型的 Parser，可以发现实现的方式很相似。</p>
<ul>
<li>closed tag，成对存在。</li>
<li>中间存储的都是字符串，最后把字符串转为具体类型。</li>
</ul>
<p>把这些相似的 Parser 进行抽象，将相同部分封装成一个函数，不同的部分用传参的形式来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tag</span>&lt;A&gt;<span class="params">(<span class="number">_</span> tag: String, <span class="number">_</span> p: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> string(<span class="string">"&lt;<span class="subst">\(tag)</span>&gt;"</span>) *&gt; manyTill(p, string(<span class="string">"&lt;/<span class="subst">\(tag)</span>&gt;"</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> _date1 = tag(<span class="string">"&lt;date&gt;"</span>, _any) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.date(<span class="type">String</span>($<span class="number">0</span>).date!) &#125;</div><div class="line">_date1.parse(<span class="string">"&lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;"</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> _string1 = tag(<span class="string">"string"</span>, _any) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.string(<span class="type">String</span>($<span class="number">0</span>)) &#125;</div><div class="line">_string1.parse(<span class="string">"&lt;string&gt;The String&lt;/string&gt;"</span>)</div></pre></td></tr></table></figure>
<h3 id="Array-Parser"><a href="#Array-Parser" class="headerlink" title="Array Parser"></a>Array Parser</h3><p>Array Parser 和 Dictionary Parser 相对比较复杂，因为它们是容器类型，里面可以是任意的 PLIST 类型，包括它们本身。对于 Enum PLIST 来说，可以使用 <code>indirect</code> 关键字来表示这种情况，但是在定义 parser 的时候，确没有这些魔法。</p>
<p>但是通过利用 Swift 的一些特性，还是很容易解决这个递归的问题。先忽略 Dictionary 类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _plist = plist()</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">plist</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">PLIST</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> _bool &lt;|&gt; _string &lt;|&gt; _integer &lt;|&gt; _date &lt;|&gt; _data &lt;|&gt; _array</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> _array = tag(<span class="string">"array"</span>, _plist) &lt;&amp;&gt; &#123;</div><div class="line">    <span class="type">PLIST</span>.array($<span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Dictionary-Parser"><a href="#Dictionary-Parser" class="headerlink" title="Dictionary Parser"></a>Dictionary Parser</h3><p>Dictionary Parser 的递归问题和 Array Parser 一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _plist = plist()</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">plist</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">PLIST</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> _bool &lt;|&gt; _string &lt;|&gt; _integer &lt;|&gt; _date &lt;|&gt; _data &lt;|&gt; _array &lt;|&gt; _dict</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> _dict = tag(<span class="string">"dict"</span>, ?) &lt;&amp;&gt; &#123;</div><div class="line">   <span class="comment">/// 转换为 PLIST.dict</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但 Dictionary 和 Array 不一样的地方在于，Array 里面是多个 Plist 的元素，而 Dictionary 是 key-value 对，且必须是 key-value 对，也就是 <code>tag(&quot;dict&quot;, _keyValue)</code>。</p>
<p>先实现一个 Key-Value Parser：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _key = string(<span class="string">"&lt;key&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/key&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</div><div class="line"><span class="keyword">let</span> _keyValue = (&#123; a <span class="keyword">in</span> &#123; b <span class="keyword">in</span> (a, b) &#125;&#125; &lt;^&gt; _key &lt;*&gt; (value))</div></pre></td></tr></table></figure>
<p>然后就可以得到 Dictionary Parser：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _dict = tag(<span class="string">"dict"</span>, _keyValue) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.dict(atod($<span class="number">0</span>)) &#125;</div><div class="line"><span class="comment">/// Tuple Array to Dictionary</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">atod</span>&lt;Key: Hashable, Value&gt;<span class="params">(<span class="number">_</span> tuples: [<span class="params">(Key, Value)</span></span></span>]) -&gt; [<span class="type">Key</span>: <span class="type">Value</span>] &#123;</div><div class="line">    <span class="keyword">var</span> dict: [<span class="type">Key</span>: <span class="type">Value</span>] = [:]</div><div class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> tuples &#123;</div><div class="line">        dict[key] = value</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dict</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者换一种写法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _kv = _keyValue &lt;&amp;&gt; &#123; ttod($<span class="number">0</span>) &#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> _dict1 = tag(<span class="string">"dict"</span>, _kv) &lt;&amp;&gt; &#123;</div><div class="line">    <span class="type">PLIST</span>.dict(</div><div class="line">    		$<span class="number">0</span>.flatMap &#123; $<span class="number">0</span> &#125;</div><div class="line">        .<span class="built_in">reduce</span>([<span class="type">String</span>: <span class="type">PLIST</span>]()) &#123; d, kv <span class="keyword">in</span></div><div class="line">            <span class="keyword">var</span> dict = d</div><div class="line">            dict.updateValue(kv.value, forKey: kv.key)</div><div class="line">            <span class="keyword">return</span> dict</div><div class="line">        &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">ttod</span>&lt;Key: Hashable, Value&gt;<span class="params">(<span class="number">_</span> tuple: <span class="params">(Key, Value)</span></span></span>) -&gt; [<span class="type">Key</span>: <span class="type">Value</span>] &#123;</div><div class="line">    <span class="keyword">return</span> [tuple.<span class="number">0</span>: tuple.<span class="number">1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Plist-Parser"><a href="#Plist-Parser" class="headerlink" title="Plist Parser"></a>Plist Parser</h3><p>最后</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _plist = _bool &lt;|&gt; _string &lt;|&gt; _integer &lt;|&gt; _date &lt;|&gt; _data &lt;|&gt; _array &lt;|&gt; _dict</div><div class="line"></div><div class="line"><span class="keyword">let</span> result = _plist.parse(plist)</div><div class="line"><span class="built_in">dump</span>(result)</div></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zh.wikipedia.org/zh-hans/属性列表" target="_blank" rel="external">属性列表</a><br><a href="http://blessingsoft.com/2017/05/28/parser-combinator/">Parser Combinator</a><br><a href="https://github.com/nixzhu/dev-blog/blob/master/2017-04-12-json-parser.md" target="_blank" rel="external">解析组合子</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/12/group-theory-and-category-theory/" itemprop="url">Group Theory and Category Theory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T22:53:27+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想理解函数式编程中的一些高大上的概念，比如 Functor, Monad 等，必须要先理解范畴论。</p>
<h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><blockquote>
<p>群，是一种代数结构，由一个集合（G）以及一个二元运算符（·）所组成。<a href="https://zh.wikipedia.org/wiki/群" target="_blank" rel="external">wikipedia</a></p>
</blockquote>
<p>一个群必须满足一些称为 <em>群公理</em> 的条件，也就是 <strong>封闭性</strong>、<strong>结合律</strong>、<strong>单位元</strong> 和 <strong>逆元</strong>。如整数配备上加法运算就形成一个群。</p>
<ul>
<li>封闭性（Closure）：对于任意 a,b∈G，a·b∈G。</li>
<li>结合律（Associativity）：对于任意 a,b,c∈G，(a·b)·c = a·(b·c)。</li>
<li>单位元（Identity）：G 中存在一个元素 e，使得任意 a∈G，a·e = e·a = a。</li>
<li>逆元：对于任意 a∈G，存在 b∈G，使得 a·b = b·a = e。</li>
</ul>
<p>群并不要求这个二元运算符（·）具体做什么，它只要求这个二元运算符存在，所以很多数学结构都是群。比如我们可以把整数当作一个群，把 <code>+</code> 作为二元运算符。</p>
<ul>
<li>封闭性：对于任意两个整数 a,b，a+b 依然是一个整数。</li>
<li>结合律：对于任意整数 a,b,c，(a+b)+c = a+(b+c)。</li>
<li>单位元：存在元素 0，使得 a+0 = 0+a = a。</li>
<li>逆元：对于任意整数 a，当 b=-a 时，a+b = b+a = e。</li>
</ul>
<p>所以我们可以说 <code>(整数, +)</code> 是一个群。如果把 <code>*</code> 当作二元运算符，把 <code>1</code> 作为单位元的时候，整数就形成了另一个群。</p>
<p>除了整数，还有很多数学结构是群。</p>
<h3 id="Semigroup"><a href="#Semigroup" class="headerlink" title="Semigroup"></a>Semigroup</h3><p>满足封闭性和结合律的群，称为半群（semigroup）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;&gt;: <span class="type">AdditionPrecedence</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> lhs + rhs</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Array, rhs: Array)</span></span> -&gt; <span class="type">Array</span> &#123;</div><div class="line">        <span class="keyword">return</span> lhs + rhs</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 折叠 fold</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;S: Semigroup&gt;<span class="params">(<span class="number">_</span> xs: [S], <span class="number">_</span> initial: S)</span></span> -&gt; <span class="type">S</span> &#123;</div><div class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(initial, &lt;&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>半群的结合律特性使得我们可以进行并行运算，<code>1 &lt;&gt; 2 &lt;&gt; 3 &lt;&gt; 4</code>。</p>
<h3 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h3><p>在抽象代数中，有一类简单的抽象结构被称为 Monoid（幺半群）。许多数学结构都是幺半群，因为成为幺半群的要求非常低。</p>
<p>存在单位元的半群，称为含幺半群，或者幺半群，或者单群，或者独异点（monoid）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Monoid</span>: <span class="title">Semigroup</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Monoid</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e = <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Monoid</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Array</span> &#123;</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;M: Monoid&gt;<span class="params">(<span class="number">_</span> xs: [M])</span></span> -&gt; <span class="type">M</span> &#123;</div><div class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(<span class="type">M</span>.e, &lt;&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>concat</code> 是对 Monoid 的一种应用，它可以利用 Monoid 的定义（ 二元操作 <code>&lt;&gt;</code> 和 单位元 <code>e</code> ）进行折叠操作。</p>
<h2 id="Category-Theory"><a href="#Category-Theory" class="headerlink" title="Category Theory"></a>Category Theory</h2><blockquote>
<p>范畴论是数学的一门学科，以抽象的方法来处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。<a href="https://zh.wikipedia.org/wiki/范畴论" target="_blank" rel="external">wikipedia</a></p>
</blockquote>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>一个范畴 C 包括：</p>
<ul>
<li>一个由对象（object）组成的类 ob(C)。（注：这里把“物件”成为“对象“更有助于从计算机的角度理解</li>
<li>对象间态射（morphism，-&gt;）组成的类 hom(C)：每个态射 f 都只有一个「源对象」a 以及一个「目标对象」b（其中 a,b 都在 ob(C) 内），称之为 <strong>从 a 到 b 的态射</strong>，记为 f: a-&gt;b。（注：identity 态射即自己映射到自己的特殊态射，f: a-&gt;a，简单记为 id[a]）</li>
<li>一个二元运算符（·），用于态射组合，如 h=g·f。</li>
</ul>
<p>满足公理：</p>
<ul>
<li>结合律：f: a-&gt;b, g: b-&gt;c, h: c-&gt;d，h·(g·f) = (h·g)·f。</li>
<li>单位元：id[a]·f = id[b]·f = f。</li>
<li>封闭性：f: a-&gt;b, g: b-&gt;c, h: a-&gt;c, h = f·g。</li>
</ul>
<p>范畴举例：</p>
<ul>
<li>范畴 C 有 Int 类型和 String 类型对象。</li>
<li>存在态射 f: Int-&gt;String。</li>
</ul>
<p>划重点：幺半群可以视为一类特殊的范畴。幺半群运算满足的公理同于范畴中 <strong>从一个对象到自身的态射</strong>。换言之：<br>幺半群实质上是只有单个对象的范畴。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><blockquote>
<p>在范畴论中，函子是范畴间的一类映射。函子也可以解释为小范畴为成员的范畴内的态射。 <a href="https://zh.wikipedia.org/wiki/函子" target="_blank" rel="external">wikipedia</a></p>
</blockquote>
<p>在当代数学中，函子被用来描述各种范畴间的关系。对范畴论者来说，函子则是个特别类型的函数。</p>
<p>设 C 和 D 为范畴，从 C 至 D 的函子为一映射 F:</p>
<ul>
<li>将每个对象 x∈C 映射至一对象 F(x)∈D 上。</li>
<li>将每个态射 f: x-&gt;y∈C 映射至一态射 F(f): F(x)-&gt;F(y)∈D 上，</li>
</ul>
<p>使之满足：</p>
<ul>
<li>对任何对象 x∈C，恒有 F(id[x]) = id[F(x)]。</li>
<li>对任何态射 f: x-&gt;y, g: y-&gt;z，恒有 F(f·g) = F(f)·F(g)。</li>
</ul>
<p>换言之，函子会保持单位态射与态射的复合。<br>一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
<h4 id="可以把范畴当作一组类型的集合"><a href="#可以把范畴当作一组类型的集合" class="headerlink" title="可以把范畴当作一组类型的集合"></a>可以把范畴当作一组类型的集合</h4><p>如范畴 C 有 <code>Int</code> 类型和 <code>String</code> 类型对象，以及 <code>Int -&gt; String</code> 的态射；范畴 D 有 <code>Array&lt;Int&gt;</code> 类型和 <code>Array&lt;String&gt;</code> 类型对象，以及 <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code> 的态射。两个范畴之间的映射 F：</p>
<ul>
<li><code>Int</code> 映射至 <code>Array&lt;Int&gt;</code> 上，<code>String</code> 映射至 <code>Array&lt;String&gt;</code> 上。</li>
<li>态射 <code>Int -&gt; String</code> 映射至 <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code> 上。</li>
</ul>
<p>翻译成代码：C: <code>Int</code>, <code>String</code>, f: <code>Int -&gt; String</code>, D: <code>Array&lt;Int&gt;</code>, <code>Array&lt;String&gt;</code>, f: <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code>。</p>
<ul>
<li>x: <code>Int</code> -&gt; F(x): <code>Array&lt;Int&gt;</code>，<code>String</code> -&gt; F(x): <code>Array&lt;String&gt;</code></li>
<li>f: <code>(Int -&gt; String)</code> -&gt; F(f): <code>(Array&lt;Int&gt; -&gt; Array&lt;String&gt;)</code></li>
</ul>
<p>范畴是不涉及具体类型的，所以用泛型表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tmap</span>&lt;T&gt;<span class="params">(x: T)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">T</span>&gt;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmap</span>&lt;A, B&gt;<span class="params">(f: A -&gt; B)</span></span> -&gt; (<span class="type">F</span>&lt;<span class="type">A</span>&gt; -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;)</div></pre></td></tr></table></figure>
<p>简化一下变成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 中把 Int 映射到 Array&lt;Int&gt; 由 Array 的初始化方法提供，</span></div><div class="line"><span class="comment">// 所以可以不写。</span></div><div class="line"><span class="comment">// 由于 fmap 实际上是 (F&lt;A&gt;, A -&gt; B) -&gt; F&lt;B&gt; 的 currying 版本，</span></div><div class="line"><span class="comment">// 所以两者是等价的。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;, f: A -&gt; B)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</div></pre></td></tr></table></figure>
<p>再来看看 Swift 中的 <code>Array</code> 和 <code>Optional</code>。如果把 Swift 中所有的类型 <code>A, B</code> 当作对象，以及 Swift 中所有的函数当作态射 <code>A -&gt; B</code>，那么这些类型和函数就组成一个范畴 A。把 <code>Array</code> 类型当作对象 <code>Array&lt;A&gt;, Array&lt;B&gt;</code>，<code>Array</code> 上所有的函数当作态射 <code>Array&lt;A&gt; -&gt; Array&lt;B&gt;</code>，那么也组成一个范畴 B。而 A 到 B 之间的函子是 <code>Array</code>，因为函子 <code>Array</code> 能将任意类型 <code>T</code> 转换为 <code>Array&lt;T&gt;</code>。<code>Optional</code> 同理。</p>
<p>很多库对 <code>Functor</code> 的支持直接在类型构造器（Type Constructor）的定义中实现 <code>map</code> 方法，比如 Swift 中的 <code>Array</code> 和 <code>Optional</code> 就是需要一个泛型作为参数来构建具体类型的类型构造器，它在定义中实现了 <code>map</code> 方法。这些类型构造器相当于同时具备了类型和函数的映射。在 Haskell 里把这个行为称为 <code>Lift</code>，相当于把类型和函数放到容器里面。所以一个带有 <code>map</code> 方法的类型构造器就是一个函子。</p>
<p>范畴与高阶类型：如果忽略范畴中的态射，范畴其实就是对特定类型的抽象，即高阶类型（类型构造器）。对于范畴 D，它的所有类型都是 <code>Array&lt;T&gt;</code> 的特定类型。而对于范畴 C，可以看作是一个 Identity 类型的构造器（id[T] = T）。</p>
<p>注意⚠️：函子不是容器，函子不是容器，函子不是容器。<br>如 <code>typealias Parser&lt;A&gt; = (String) -&gt; (A, String)?</code> 我们可以实现 <code>func map&lt;A, B&gt;(x: Parser&lt;A&gt;, f: (A) -&gt; B) -&gt; Parser&lt;B&gt;</code> 函数，所以我们可以说 <code>Parser&lt;A&gt;</code> 是一个函子，但它不是容器。</p>
<h3 id="Endofunctor"><a href="#Endofunctor" class="headerlink" title="Endofunctor"></a>Endofunctor</h3><blockquote>
<p>A functor that maps a category to itself。一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
</blockquote>
<p>先看自函数的概念：将一个类型映射到自身类型，如 <code>Int -&gt; Int</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</div></pre></td></tr></table></figure>
<p>单位函数（Identity Function）的概念：什么都不做，传入什么就返回什么。属于自函数的特例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">id</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x &#125;</div></pre></td></tr></table></figure>
<p><strong>自函子不是单位函子（Identity Functor）</strong>。还是上面的范畴 C，为了区分自函子和单位函子，多加一种态射 g: <code>String -&gt; Int</code>，那么：</p>
<p>自函子：对于函子 F，对于 <code>F(Int)</code> 结果是 <code>String</code>，<code>F(String)</code> 结果是 <code>Int</code>，对于 <code>F(f: Int -&gt; String)</code> 结果是 g: <code>String -&gt; Int</code>。那么这个函子就是自函子。</p>
<p>单位函子（Identity Functor）：对于函子 F，对于 <code>F(Int)</code> 结果还是 <code>Int</code>，对于 <code>F(String)</code> 结果还是 <code>String</code>，对于 <code>F(f: Int -&gt; String)</code> 结果还是 <code>f: Int -&gt; String</code>，对于 <code>F(g: String -&gt; Int)</code> 结果还是 g: <code>String -&gt; Int</code>。那么这个函子就是单位函子。 </p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><blockquote>
<p>An applicative is a monoid in the category of endofunctors, what’s the problem?</p>
</blockquote>
<p>虽然在 Haskell 中 Monad 是 Applicative 的一种，但是 Applicative 的出现却在 Monad 之后。</p>
<p><a href="https://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/" target="_blank" rel="external">Applicative</a></p>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><blockquote>
<p>A monad is a monoid in the category of endofunctors – Philip Wadler</p>
</blockquote>
<p>自函子说穿了就是把一个范畴映射到自身的函子，自函子范畴说穿了就是从小范畴映射到自身的函子所构成的以自函子为对象以自然变换为态射的范畴，幺半群说穿了就是只有单个对象的范畴，给定了一个幺半群则可构造出一个仅有单个对象的小范畴使其态射由幺半群的元素给出而合成由幺半群的运算给出，而单子说穿了就是自函子范畴上的这样一个幺半群。（这都不理解么亲连这种最基本的概念都不理解还学什么编程！</p>
<p>一系列 Endofunctor 组成的范畴，成为 <strong>自函子范畴</strong>。</p>
<ul>
<li>X 上的自函子：F：<code>X -&gt; X</code></li>
<li>单位自函子 id[X] 到函子 F 的自然转换：<code>id[X] -&gt; F</code> (pure</li>
<li>函子 F 的张量积 F⊗F 到函子 F 的自然转换：<code>F⊗F -&gt; F</code> (join</li>
</ul>
<p>代码表示：</p>
<ul>
<li><code>func unit&lt;T&gt;(x: T) -&gt; F&lt;T&gt; // x = id[x]</code> </li>
<li><code>func join&lt;T&gt;(a: F&lt;F&lt;T&gt;&gt;) -&gt; F&lt;T&gt;</code></li>
</ul>
<p>此处函子的张量积 ⊗ 可以看作为组合（Composition）；<br>注意结合 Monoidal Category 理解，<code>unit</code> 和 <code>join</code> 满足 Monoid 的定律，所有形成了 Monoid。</p>
<p>也就是说：单子（Monad）是自函子的 Monoidal 范畴上的一个幺半群，该 Monoidal 范畴的张量积（Tensor Product，⊗：F×F -&gt; F）是自函子的复合（Composition），单位元是 Id Functor。</p>
<p><code>bind</code> 或者说 <code>flatMap</code> 或者 <code>&gt;&gt;=</code> 其实等于 <code>map + join</code>。（见 <a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a> 中的 <code>stdlib/public/core/FlatMap.swift</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;=&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;, f: A -&gt; F&lt;B&gt;)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</div><div class="line"><span class="comment">// Currying 前的样子</span></div><div class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;=&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;)</span></span> -&gt; (f: <span class="type">A</span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Too much</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/28/parser-combinator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/28/parser-combinator/" itemprop="url">Parser Combinator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T16:50:04+08:00">
                2017-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</p>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>将一个数据流解析成结构化的数据的工具，我们称为解析器。比如我们需要将用户输入的表达式字符串解析成 AST，我们就可以使用解析器来达到我们的目的。</p>
<p><code>( 4 + 3  )</code> 就是一个表达式语句，它由字符 <code>(</code>  <code>4</code> <code>空格</code> <code>+</code> <code>3</code> 和 <code>)</code> 组成。我们可以将这个表达式解析成一种 <em>表达式树</em> (AST 的一种)。</p>
<p>所以我们的解析器简单的用一个函数来描述就是：<br><code>func parser(_ string: String) -&gt; AST</code></p>
<p>我们不是用正则表达式来解析输入的表达式字符串，为了得到表达式树里面的节点，我们需要一步步的解析，每次解析得到不同的节点。所以我们需要将解析器的定义变成解析成功的话，会返回结果值和剩下的字符串。</p>
<p><code>func parser(_ string: String) -&gt; (AST, String)</code></p>
<p>表达式树的节点都是一些 <code>4</code> <code>+</code> 这种不同类型的数据，所以为了表示解析 <code>4</code> 成功和解析 <code>+</code> 成功，我们的返回值可以定义为泛型。并且表达出解析失败的情况，我们可以使用可选值。最终解析器函数就变成了：</p>
<p><code>func parser&lt;T&gt;(_ string: String) -&gt; (T, String)?</code></p>
<p>所以解析第一个数字 4 的解析器函数为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">String</span>)? &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = string.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="type">Optional</span>.some((<span class="number">4</span>, <span class="type">String</span>(string.characters.<span class="built_in">dropFirst</span>())))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Combinator"><a href="#Combinator" class="headerlink" title="Combinator"></a>Combinator</h2><blockquote>
<p>One of the distinguishing features of functional programming is the widespread use of combinators to construct programs. <em>A combinator is a function which builds program fragments from program fragments</em>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. – John Hughes</p>
</blockquote>
<p>其实 Combinator 很容易理解，就像字面意思那样 —— 组合子。首先定义一系列原子操作，然后定义组合的规则，然后根据组合的规则把这些原子操作组合起来。</p>
<h2 id="Parser-Combinator"><a href="#Parser-Combinator" class="headerlink" title="Parser Combinator"></a>Parser Combinator</h2><p>回到开头的话：<em>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</em> 所以我们需要重新定义一下我们的解析器，把它变成一个解析组合子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">let</span> parse: (<span class="type">String</span>) -&gt; (<span class="type">A</span>, <span class="type">String</span>)?</div><div class="line">    <span class="comment">// (input) -&gt; (result, remaining)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个解析字符串的解析器，我们把这个函数放到一个结构体 <code>Parser</code> 中，作为一个 <code>parse</code> 变量。当然我们也可以用类型别名 <code>typealias Parser&lt;Result&gt; = (String) -&gt; (Result, String)?</code>。</p>
<p>当然解析组合子不仅仅能解析字符串，所以可以用泛型来把它变得更通用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">let</span> parse: (<span class="type">I</span>) -&gt; (<span class="type">O</span>, <span class="type">I</span>)?</div><div class="line">    <span class="comment">// (input) -&gt; (output, remaining input)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以解析数字字符 <code>4</code> 的解析器就变成了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">character4</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="string">"4"</span>, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以根据 <code>func character4() -&gt; Parser&lt;Character&gt;</code> 很容易得到一个能够解析任何字符的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">character</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == character <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 的区别，很容易又得到能够解析任何数字的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">digit</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, <span class="string">"0"</span>...<span class="string">"9"</span> ~= head <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 相同和不同，我们可以进一步抽象，把相同部分进行封装，把不同部分作为参数，得到新的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">satisfy</span><span class="params">(<span class="number">_</span> condition: @escaping <span class="params">(Character)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, condition(head) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以解析数字：</p>
<p><code>(satisfy { &quot;0&quot;...&quot;9&quot; ~= $0 }).parse(&quot;1abc&quot;)</code></p>
<p>解析空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSpace</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">String</span>(character).trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines).isEmpty</div><div class="line">&#125;</div><div class="line">(satisfy(isSpace)).parse(<span class="string">" abc"</span>)</div></pre></td></tr></table></figure>
<p>所以我们只需要给 <code>satisfy</code> 函数传入一个是否属于 X 的函数，就可以得到一个能够解析 x 的解析器。</p>
<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>最基本的 <code>character</code> 有了，<code>digit</code> 有了，当我们需要解析一个字符串 <code>alex</code> 的时候，我们只需要把 <code>alex</code> 看成 <code>a</code> <code>l</code> <code>e</code> <code>x</code> 4 个字符，然后不断的用 <code>character</code> 进行解析，最后把每一步返回的结果合并起来就行了。考虑到解析一个字符串是一个基本功能，为了不用每次写重复的代码，把它封装成用来解析 <code>string</code> 的解析器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> parsers = str.characters.<span class="built_in">map</span> &#123; character($<span class="number">0</span>) &#125;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">for</span> parser <span class="keyword">in</span> parsers &#123;</div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = parser.parse(stream) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">            &#125;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="type">String</span>(results), stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察 parse 函数类型 <code>(String) -&gt; (A, String)</code>，解析成功的返回值是解析结果和 <strong>剩余</strong> 的字符串，所以解析 <code>alex</code> 的时候：</p>
<ol>
<li>“alex”: ‘a’ -&gt; (‘a’, “lex”)</li>
<li>“lex”: ‘l’ -&gt; (‘l’, “ex”)</li>
<li>“ex”: ‘e’ -&gt; (‘e’, “x”)</li>
<li>“x”: ‘x’ -&gt; (‘x’, “”)</li>
<li>Parser&lt;”alex”&gt;</li>
</ol>
<p>可以看到这几步做的事情除了参数不一样，内部逻辑是一样的，而且很容易看出是一个递归的过程，<strong>每次解析成功就 <code>吃掉</code> 第一个字符</strong>（留意这句话），然后解析剩下的字符串。</p>
<p>所以我们写一个递归的版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 0. 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 1. 先解析第一个字符</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = character(head).parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. 然后解析剩下的所有</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder2) = string1(<span class="type">String</span>(tail)).parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. 返回("结果", "剩余的字符串")</span></div><div class="line">        <span class="keyword">return</span> (str, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncons</span>&lt;C: Collection&gt;<span class="params">(<span class="number">_</span> xs: C)</span></span> -&gt; (<span class="type">C</span>.<span class="type">Iterator</span>.<span class="type">Element</span>, <span class="type">C</span>.<span class="type">SubSequence</span>)? &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = xs.first <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (head, xs.suffix(from: xs.index(after: xs.startIndex)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察 1 和 2，在这两步中，我们都没有使用解析的 <strong>结果</strong>，这两步实现的仅仅是 <strong>每次解析成功就 <code>吃掉</code> 结果</strong>！最后在第 3 步一次将结果返回。也就是说我们 1 和 2 这两本并不关心结果，只关心这些要解析道字符存在就行了。</p>
<p>我们把解析成功吃掉结果这一步封装一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只保留右边的解析器的结果 result2，没有 result1</span></div><div class="line">        <span class="keyword">return</span> (result2, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>discarding</code> 函数会 <strong>吃掉</strong> 左边第一个参数 <code>x</code> 的解析结果，返回值中只保留右边 <code>y</code> 的解析结果。用 <code>discarding</code> 函数重写一下上面的 <code>string</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 1 吃掉 character(head) 的结果</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder) = discarding(character(head), string2(<span class="type">String</span>(tail))).parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2 返回 ("结果", "剩余的字符串")</span></div><div class="line">        <span class="keyword">return</span> (str, remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次改版的 <code>string</code> 里面第 1 步中的解析结果还是被忽略了，所以是否可以继续用 <code>discarding</code> 来简化？但是 <code>discarding</code> 函数需要两个解析器，但函数内只有 <code>lift</code> 返回的一个解析器，所以没办法继续简化了？</p>
<p>仔细看 <code>string</code> 函数体的第一行 <code>return Parser {}</code> 就是一个解析器，能否把这个解析器利用上呢？<code>discarding</code> 是在 <code>Parser {}</code> 里面的，所以只要能想办法把它展平，那么就能再次利用上 <code>lift</code>，而且展平后的解析器需要做为 <code>string</code> 函数的返回值，所以它肯定是做为 <code>discarding</code> 的右边的参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> lhs = <span class="type">Parser</span> &#123;&#125;</div><div class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;&#125;</div><div class="line">    <span class="keyword">return</span> lift(x, y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据第 2 步的 <code>return (str, remainder)</code> 可以知道，最终的返回结果是 <code>(输入的，lhs 吃剩的)</code>，所以很容易得到 <code>let rhs = Parser&lt;String&gt; { (str, $0) }</code>。所以可以推出 lhs 要做的只是负责吃掉一部分。也就是上面的第 1 步所做的。所以：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">        <span class="keyword">return</span> (<span class="string">""</span>, input)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2 吃掉</span></div><div class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</div><div class="line">    <span class="comment">// 3 结果和剩下的</span></div><div class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</div><div class="line">    <span class="comment">// 4 返回</span></div><div class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的返回值是 <code>Parser</code>，由于外面没有 Parser {} ，展开后 1 那里需要返回一个 <code>Parser</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">        <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (<span class="string">""</span>, $<span class="number">0</span>) &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>明眼人可以看到 1 和 3 只有 <code>&quot;&quot;</code> 和 <code>str</code> 不一样，剩下的一模一样，虽然代码不长，但我们还是把它相同部分封装成一个函数，然后把不同的部分做为参赛。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></div><div class="line">        <span class="keyword">return</span> pure(<span class="string">""</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    <span class="keyword">let</span> rhs = pure(str)</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Lift a value</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pure</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: A)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123; (x, $<span class="number">0</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以封装一个简洁的 <code>string</code> 解析器，花了很多功夫，但抛开性能，它比迭代的版本更简洁易懂。</p>
<h2 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h2><p>观察表达式 <code>( 4 + 3  )</code>，里面 <code>(</code> 和 <code>4</code> 之间有 1 个空格，数字 <code>3</code> 和 <code>)</code> 中间是有 2 个空格，在做加法运算的时候，这些 <em>many</em> 个空格是没有意义的，所以需要 <em>skip</em> 掉。</p>
<h4 id="Many"><a href="#Many" class="headerlink" title="Many"></a>Many</h4><p>首先需要解析空格的解析器，前面已经有实现过：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">space</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> satisfy(isSpace)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于空格数量未知，可能有 <em>many</em> 个，假如有一个解析器，能够解析 <em>many</em> 个 parser。用一个 loop 不断去解析就能实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">many</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">var</span> results: [<span class="type">A</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (results, stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任意个空格就是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many(space())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>spaces</code> 得到的是一个 <code>Parser&lt;[Character]&gt;</code> 类型的 parser，但是按照理解更希望得到一个 <code>Parser&lt;String&gt;</code> 类型的 parser。在 Swift 中，<code>String([Character])</code> 就能够将 <code>[Character]</code> 拍扁成 <code>String</code> 类型。所以把 <code>many</code> 稍微修改一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">many</span>&lt;Character&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;Character&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="type">String</span>(results), stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为不是任何泛型 A 类型，都能用 String 拍扁，也不一定能通过其他类型进行拍扁，所以这里把泛型 A 去掉，直接用 Character 代替。但是这样做并不理想，因为 <code>many</code> 解析器从一个泛型解析器，变成了一个只能解析 Character 类型的解析器，变成了 <code>manyCharacter</code>。后面考虑解析这个问题，重新把 <code>many</code> 变成通用的解析器。</p>
<h4 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h4><p>接着实现一个通用的 <code>skip</code> 解析器，它要做的事情很简单，输入什么吃掉什么，返回剩下的，和上面吃掉左边的 <code>discarding</code> 很像，不一样的是 <code>skip</code> 只有一个参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">skip</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Void</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> ((), input)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> ((), remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把 <code>skip</code> 和 <code>spaces</code> 进行组合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">skipSpaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Void</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> skip(spaces)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Many1"><a href="#Many1" class="headerlink" title="Many1"></a>Many1</h4><p>前面实现的 <code>digit</code> 解析器，它只能解析个位数，这是没有什么卵用的。相比 <code>digit</code>，更加需要的是一个 <code>number</code> 解析器。一个 <em>number</em> 实际上也是由 <em>many</em> 个 <em>digit</em> 组成。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many(digit())</div><div class="line">&#125;</div><div class="line"></div><div class="line">number().parse(<span class="string">"123abc"</span>) <span class="comment">// (["1", "2", "3"], "abc")</span></div><div class="line">number().parse(<span class="string">"abc"</span>) <span class="comment">// ([], "abc")</span></div></pre></td></tr></table></figure>
<p>等等！<code>number().parse(&quot;abc&quot;)</code> 也解析成功了，结果是空数组。这并不是想要的结果，一个 <em>string</em> 可以是空的，<em>space</em> 甚至也可以是空的，但一个 <em>number</em> 不能是空的。所以需要另外一个只是有一个的 <code>many</code>。这其实很常见，比如正则表达式中有 <code>*</code> 和 <code>+</code>，一个 {0, +} 一个是 {1, +}。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">many1</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="comment">// 多加一个判断，第一个值必须满足条件</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> results: [<span class="type">A</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (results, stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以正确的 <code>number</code> 解析器就变成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many1(digit())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>number</code> 解析器和 <code>spaces</code> 解析器遇到了同样的问题，<code>number</code> 解析器的结果应该是 <code>Int</code>（暂不考虑浮点数），而不是 <code>[Character]</code>。解决方法可以类似 <code>manyCharacter</code>，但是这显示是很有问题的，抽象抽象抽象！</p>
<p>程序员要有抽象思维，要学会用更高的层次的思维去看待问题，发现不同问题的共同点。<code>[Character]</code> 可以用 <code>String([Character])</code> 变成一个 <code>String</code>。对于 <code>digit</code> character，同样的也是用 <code>String([Character])</code> 拍扁，然后用 <code>Int(String)</code> 得到一个 <code>number</code>。</p>
<p>结合 Swift 的 OOP（面向协议编程），可以定义一个协议，暂且叫做 <code>Combinable</code> :D</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Combinable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">Self</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Combinable</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Int</span>(<span class="type">String</span>(describing: xs))!</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">Combinable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: xs)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">many1</span>&lt;A: Combinable&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;Character&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</div><div class="line">        <span class="keyword">var</span> stream = input</div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</div><div class="line">            results.append(result)</div><div class="line">            stream = remainder</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="type">A</span>.combine(results), stream)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就可以得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many1(digit())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> many1(space()) <span class="comment">// 忽略 spaces 可以为空的情况</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上 <code>skipSpaces</code> 还可以用另外一个角度来拆分，上面先解析 <em>many</em> 个空格，然后一次 <em>skip</em> 掉。还可以每次 <em>skip</em> 一个空格，然后进行 <em>many</em> 次。不同的地方是 <code>skip</code> 和 <code>many</code> 两个 parser 的调用次序不一样，甚至还可以定义一个叫做 <code>skipMany</code> 的解析器，这也说明了 <strong>Combinator</strong> 的强大。通过定义一系列基础的 parser，进行不同的排列组合操作，最后覆盖所有的 case。（理想状态</p>
<h4 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h4><p>合并两个 parser 的解析器 <code>zip</code> 的实现也很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">zip</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;(<span class="type">A</span>, <span class="type">B</span>)&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ((result1, result2), remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Choice"><a href="#Choice" class="headerlink" title="Choice"></a>Choice</h4><p>接下来还需要解析几个简单的一元运算符 <code>+</code> <code>-</code> <code>*</code> <code>/</code>。去掉空格后，两个数中间必须是其中一个运算符那么表达式就是合法的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">opt</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> opts = [<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>].<span class="built_in">map</span> &#123; character($<span class="number">0</span>.characters.first!) &#125;</div><div class="line">    <span class="keyword">return</span> choice(opts)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 也可以叫 one(of:)</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice</span>&lt;A, S: Sequence&gt;<span class="params">(<span class="number">_</span> xs: S)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(empty(), &#123; $<span class="number">0</span> &lt;|&gt; $<span class="number">1</span> &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span>&lt;A&gt;<span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">nil</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>上面利用 Protocol 实现的 <code>number</code> 和 <code>space</code> 解析器其实并不是很优雅，费了很大劲把 <code>many</code> 变得 <del>通用</del>，结果却并不是很 <strong>通用</strong>，因为要求结果的类型必须实现 <code>Combinable</code> 协议。但它做的工作却很少，只是把传入的 <code>Parser&lt;A&gt;</code> 循环解析得到的结果 <code>[A]</code> 在 <code>many</code> <strong>内部</strong> 组合成最终的类型，实现把 <code>Parser&lt;[A]</code> 转换为 <code>Parser&lt;B&gt;</code>。正由于它是在 <code>many</code> 内部做的操作，所以依赖于传入的类型，使得 <code>many</code> 不再那么通用。</p>
<p>再看 <code>func character(_ character: Character) -&gt; Parser&lt;Character&gt;</code> 的定义，假如调用 <code>character(&quot;4&quot;)</code>，那么返回的是一个 <code>Parser&lt;Character&gt;</code> 类型的解析器，这个解析器调用 <code>parse</code> 方法，返回的结果是 <code>Character</code> 类型的值。在解析表达式 <code>4 + 3</code> 的时候，需要将解析到的 <code>4</code> 和 <code>3</code> 当作一个整数然后相加，才能得到最终的结果，所以不想要 <code>Character</code> 类型的值，而是想要 <code>Int</code> 类型的值，那么需要将 <code>Parser&lt;Character&gt;</code> 转换为 <code>Parser&lt;Int&gt;</code> 解析器。</p>
<p>所以，假如能实现一个函数，可以将任意 <code>Parser&lt;A&gt;</code> 转换为 <code>Parser&lt;B&gt;</code> 解析器，就完美了。<code>many</code> 只负责将 <code>Parser&lt;A&gt;</code> 解析得到 <code>Parser&lt;[A]&gt;</code>，然后由 <code>number</code> 自己将 <code>Parser&lt;[A]&gt;</code> 转换为 <code>Parser&lt;Int&gt;</code>。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><p>回忆 Swift 中 Optional 类型中的 map 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt; = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> b: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = a.<span class="built_in">map</span> &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</div></pre></td></tr></table></figure>
<p>它将一个 <code>Optional&lt;Int&gt;</code> 转换为 <code>Optional&lt;String&gt;</code>，仔细一看，把 <code>Optional</code> 换成 <code>Parser</code>，就是我们所需要的转换解析器的方法。</p>
<p><code>Optional</code> 的函数签名是 <code>func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; U?</code>，所以依葫芦画瓢，我们可以得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;B&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = <span class="keyword">self</span>.parse(input) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">            <span class="keyword">return</span> (transform(result), remainder)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像上面的 <code>satisfy</code> 和其他函数一样，把 <code>map</code> 方法从结构图内移出来，则得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: @escaping <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = x.parse(input)<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (f(result), remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于值是在 <code>Parser</code> 中包裹着的，想把返回的 <code>Parser&lt;Character</code> 变成 <code>Parser&lt;Int&gt;</code>，需要把 <code>Parser&lt;Character&gt;</code> 解开取出里面<character>的值，然后把它变成<int>类型，然后重现包装起来。对于不同的类型转换，解包重新包装的步骤是一样的，不同的地方是把结果从一种类型变成另一种类型，函数的作用就是把相同的封装起来，把不同做为参赛传进去，所以在 <code>map</code> 函数的实现中，只需要在返回前，给外部将这个结果进行一次转换机会，所以需要一个参赛，能够将解开后得到的值变成另一种类型的值，也就是提供一个函数 <code>(Character) -&gt; Int</code>。</int></character></p>
<p>重新实现 <code>number</code> 和 <code>spaces</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Int</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(many1(digit()), &#123; <span class="type">Int</span>(<span class="type">String</span>($<span class="number">0</span>))! &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(many(space()), &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种不同的结构体 <code>Optional&lt;T&gt;</code> 和 <code>Parser&lt;A&gt;</code>，都可以给它实现一个 <code>map</code> 方法，使得它变成一个不同类型的结构体。而支持这种 <code>map</code> 方法的结构体，我们称把它为 <code>Functor</code>。</p>
<blockquote>
<p>简单来说，所谓的 <code>Functor</code> 就是可以把一个函数应用于一个 <strong>封装过的值</strong> 上，得到一个新的 <strong>封装过的值</strong></p>
</blockquote>
<p><code>Functor</code> 最早出自于代数拓扑，这里说的 <code>Functor</code> 一般是指范畴论（Category Theory）中的 <code>Functor</code>，它被用来描述各种范畴间的关系。更多 Functor 的理解 <a href="http://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">Group Theory and Category Theory</a>。</p>
<h3 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pure</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: A)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123; (x, $<span class="number">0</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上前面的 <code>pure</code> 和 <code>discarding</code> 函数就是一种 Applicative。像 <code>discarding</code> 一样有时候只关心这些要解析道字符存在就行了，上面定义的 <code>discarding</code> 解析器作用是忽略第一个 parser 参数的解析结果，同样地，可以定义一个忽略第二个 parser 参数的解析器。比如当解析出现在右边的 symbol 的时候就很有用，<code>discarding2(parser, string(&quot;)&quot;))</code> 的作用就是确保存在闭合的右括号 “)”。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 吃掉右边的结果</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding2</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只保留左边的解析器的结果 result1，没有 result2</span></div><div class="line">        <span class="keyword">return</span> (result1, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 吃掉左边的结果</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding1</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只保留右边的解析器的结果 result2，没有 result1</span></div><div class="line">        <span class="keyword">return</span> (result2, remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个 <code>discarding</code> 函数长的很像，如果有办法把它们抽象一下，把相似的地方提取出来就好了。</p>
<p>对于两个结果，忽略其中一个，实际上很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 忽略 B</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">A</span> &#123;</div><div class="line">    <span class="keyword">return</span> a</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 忽略 A</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">B</span> &#123;</div><div class="line">    <span class="keyword">return</span> b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 吃掉左边的结果</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">left</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">discarding</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">A</span> &#123;</div><div class="line">        <span class="keyword">return</span> b</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (discarding(result1, result2), remainder2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后这个函数并没有卵用。</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>观看 <code>map</code> 函数 <code>func map&lt;A, B&gt;(_ x: Parser&lt;A&gt;, _ f: (A) -&gt; B) -&gt; Parser&lt;B&gt;</code></p>
<p>它要求传入两个参数，一个是 <code>Parser&lt;A&gt;</code>，一个是函数 <code>A -&gt; B</code>，第二个参数对标题中的 <strong>Combinator</strong> 并不是很友好，<strong>Parser Combinator</strong> 的思想是组合一系列的 <code>Parser</code> 得到结果。上面定义了有很多小的 parser，比如 <code>func string(_ str: String) -&gt; Parser&lt;String&gt;</code>，函数签名是 <code>(String) -&gt; Parser&lt;String&gt;</code>，由于 <code>map</code> 函数的第二个参数的签名是 <code>(A) -&gt; B</code>，而非 <code>(A) -&gt; Parser&lt;B&gt;</code>，所以假如存在一个与 <code>map</code> 功能相似，但第二个参数的签名是 <code>(A) -&gt; Parser&lt;B&gt;</code>，则能够使得之前定义的很多小的 <code>parser</code> 能够直接作为一个参数，直接得到一个新类型的 <code>Parser</code>，大概这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: <span class="params">(A)</span></span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;</div></pre></td></tr></table></figure>
<p>使用的时候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> parser = flatMap(stringParser, string(<span class="string">"alex"</span>))</div></pre></td></tr></table></figure>
<p>具体实现与 <code>map</code> 也很像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: @escaping <span class="params">(A)</span></span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = x.parse(input)<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> f(result).parse(remainder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">Group Theory and Category Theory</a></p>
<h3 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span>&lt;A&gt;<span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">nil</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></div><div class="line">        <span class="keyword">return</span> x.parse(input) ?? y.parse(input)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Alternative 类似于 <code>Swift Standard Library</code> 中定义的运算符 <code>??</code>，它有两个同类型的参数，第一个参数是偏爱的 <code>parser</code>，第二个参数是默认的 <code>parser</code>。它首先尝试使用第一个 <code>parser</code> 来进行解析，如果成功，则返回。如果不成功，则使用默认的 <code>parser</code> 进行解析。它的返回值类型也是同类型的 <code>Parser</code>。</p>
<p>作用是假如有 Int, String, Bool 三个类型的 <code>parser</code>，而一个 scalar 类型的 <code>parser</code> 只要能够解析 Int, String, Bool 任意一种类型，则算解析成功。换句话说就是 scalar 是 Int, String, Bool 的父集。一种简单的从 <code>Parser&lt;Int&gt;</code>, <code>Parser&lt;String&gt;</code>, <code>Parser&lt;Bool&gt;</code> 三种已有实现的 parser 得到 <code>Parser&lt;Scalar&gt;</code> 的方法是逐个进行 parse，如果成功则马上返回。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> scalar = parserInt &lt;|&gt; parserString &lt;|&gt; parserBool</div></pre></td></tr></table></figure>
<p>从这个例子看有点 one of 的意思，但实际上更加准确的说法是 choice。</p>
<h3 id="Applicative-amp-Monad"><a href="#Applicative-amp-Monad" class="headerlink" title="Applicative &amp; Monad"></a>Applicative &amp; Monad</h3><p>Applicative 和 Monad 的区别在于：</p>
<p>Applicative 的两个 parser 是相互独立的，组合后的新 parser 是可以静态分析其行为的。而对于 Monad，在不知道输入的情况下，是不能确定其行为，也就是说 Monad 是依赖于计算结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">alex</span><span class="params">(<span class="number">_</span> x: Parser&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(<span class="string">"alex.huo"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> af: <span class="type">Parser</span>&lt;(<span class="type">String</span>) -&gt; <span class="type">String</span>&gt; = pure(id)</div><div class="line"><span class="keyword">let</span> ax = string(<span class="string">"alex"</span>)</div><div class="line">alex(af &lt;*&gt; ax) <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> mf: (<span class="type">String</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; = &#123; string($<span class="number">0</span>) &#125;</div><div class="line"><span class="keyword">let</span> mx = string(<span class="string">"alex"</span>)</div><div class="line">alex(mx &gt;&gt;- mf) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/hlian/jiffy" target="_blank" rel="external">Jiffy</a><br><a href="https://news.realm.io/news/tryswift-yasuhiro-inami-parser-combinator/" target="_blank" rel="external">Parser combinators</a><br><a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf" target="_blank" rel="external">Monadic Parser Combinators</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/20/cherry-blessing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/cherry-blessing/" itemprop="url">Cherry Blessing</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T12:37:36+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to Cherry Blessing.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Xspyhack" />
          <p class="site-author-name" itemprop="name">Xspyhack</p>
           
              <p class="site-description motion-element" itemprop="description">Why join the navy if you can be a pirate?</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xspyhack</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
