<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="Why join the navy if you can be a pirate?">
<meta property="og:type" content="website">
<meta property="og:title" content="Cherry Blessing">
<meta property="og:url" content="https://blessingsoft.com/index.html">
<meta property="og:site_name" content="Cherry Blessing">
<meta property="og:description" content="Why join the navy if you can be a pirate?">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cherry Blessing">
<meta name="twitter:description" content="Why join the navy if you can be a pirate?">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blessingsoft.com/">





  <title>Cherry Blessing</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cherry Blessing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">A monad is a monoid in the category of endofunctors</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2020/04/25/http-chunked-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/25/http-chunked-2/" itemprop="url">HTTP Streaming/Chunked 2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-25T20:00:00+08:00">
                2020-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/networking/" itemprop="url" rel="index">
                    <span itemprop="name">networking</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>一个非常悲伤的消息是，<code>Azure</code> 和 <code>Cocoa</code> 的配合还是出了问题，原因出在 <code>chunk</code> 的实现上。这个锅应该由 <code>Cocoa</code> 来背，<code>HTTP/1.1</code> 给出的 <code>chunk</code> 的格式中，每一个 <code>chunk</code> 的结尾应该是 <code>CRLF</code>，而 <code>Cocoa</code> 的实现（可能是为了实现上的方便）把这个 <code>CRLF</code> 放在了下一个 <code>chunk</code> 的开头。对于连续的 <code>chunk</code> 来说看起好像没有什么区别，但是在我们的场景中，使用第一个 <code>chunk</code> 来建立连接，建立完成之后才会发信令的 <code>chunk</code>，也就是第一个 <code>chunk</code> 和后续的 <code>chunk</code> 不会连续。然而 <code>Azure</code> 在收到第一个 <code>chunk</code> 后，发现结尾还没有收到 <code>CRLF</code>（虽然此时已经收到了正确长度的数据），然后进入继续等待状态，不会把数据包转发给后台数据服务器，这样后台数据服务器就没法和 <code>downlink</code> 匹配并且建立连接。</p>
<h2 id="Chunked-Transfer-Encoding"><a href="#Chunked-Transfer-Encoding" class="headerlink" title="Chunked Transfer Encoding"></a>Chunked Transfer Encoding</h2><p>首先根据 <code>HTTP/1.1</code> 的 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html" target="_blank" rel="noopener">RFC</a> 对于 <code>Chunked Transfer Encoding</code> 规定。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Chunked-Body</span>   <span class="string">=</span> <span class="meta">*chunk</span></span><br><span class="line">                <span class="string">last-chunk</span></span><br><span class="line">                <span class="string">trailer</span></span><br><span class="line">                <span class="string">CRLF</span></span><br><span class="line"><span class="string">chunk</span>          <span class="string">=</span> <span class="string">chunk-size</span> <span class="string">[</span> <span class="string">chunk-extension</span> <span class="string">]</span> <span class="string">CRLF</span></span><br><span class="line">                <span class="string">chunk-data</span> <span class="string">CRLF</span></span><br><span class="line"><span class="string">chunk-size</span>     <span class="string">=</span> <span class="number">1</span><span class="meta">*HEX</span></span><br><span class="line"><span class="string">last-chunk</span>     <span class="string">=</span> <span class="number">1</span><span class="string">*("0")</span> <span class="string">[</span> <span class="string">chunk-extension</span> <span class="string">]</span> <span class="string">CRLF</span></span><br><span class="line"><span class="string">chunk-extension=</span> <span class="string">*(</span> <span class="string">";"</span> <span class="string">chunk-ext-name</span> <span class="string">[</span> <span class="string">"="</span> <span class="string">chunk-ext-val</span> <span class="string">]</span> <span class="string">)</span></span><br><span class="line"><span class="string">chunk-ext-name</span> <span class="string">=</span> <span class="string">token</span></span><br><span class="line"><span class="string">chunk-ext-val</span>  <span class="string">=</span> <span class="string">token</span> <span class="string">|</span> <span class="string">quoted-string</span></span><br><span class="line"><span class="string">chunk-data</span>     <span class="string">=</span> <span class="string">chunk-size(OCTET)</span></span><br><span class="line"><span class="string">trailer</span>        <span class="string">=</span> <span class="string">*(entity-header</span> <span class="string">CRLF)</span></span><br></pre></td></tr></table></figure>
<p>重点部分为 <code>chunk</code> 的格式，可以看到每一个 <code>chunk</code> 应该由一个 16 进制的 <code>chunk-size</code> 开始，然后接着一个 <code>CRLF</code>，然后是 <code>chunk-data</code>，末尾是一个 <code>CRLF</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">chunk</span>          <span class="string">=</span> <span class="string">chunk-size</span> <span class="string">[</span> <span class="string">chunk-extension</span> <span class="string">]</span> <span class="string">CRLF</span></span><br><span class="line">                <span class="string">chunk-data</span> <span class="string">CRLF</span></span><br></pre></td></tr></table></figure>
<p>再看 <code>Cocoa</code> 的实现 <a href="https://opensource.apple.com/source/CFNetwork/CFNetwork-128.2/HTTP/CFHTTPFilter.c.auto.html" target="_blank" rel="noopener">CFHTTPFilter.c</a>，虽然它在源码里面也贴了上边 <code>RFC</code> 中的结构，可是它的实现中并不那么回事。看第一行注释就暴露了它的每个 <code>chunk header</code> 中除了 <code>first chunk</code> 之外，其他的都会出现两个 <code>CRLF</code>，其中一个叫做 <code>leading CRLF</code>，也就是开头说的，它是在下一个 <code>chunk</code> 的头部，插入一个 <code>CRLF</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CFIndex &lt;= uint64 so no more than 16 characters to encode + 2 for CRLF + 2 for leading CRLF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CHUNK_HEADER_SIZE (20)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> sendChunkHeader(<span class="built_in">CFWriteStreamRef</span> stream, <span class="built_in">CFIndex</span> chunkLength, Boolean firstChunk, <span class="built_in">CFStreamError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// hex representation of chunkLength, followed by CRLF</span></span><br><span class="line">    <span class="built_in">UInt8</span> writeBuffer[MAX_CHUNK_HEADER_SIZE];</span><br><span class="line">    <span class="built_in">UInt8</span> *writeBase;</span><br><span class="line">    <span class="built_in">CFIndex</span> bytesWritten;</span><br><span class="line">    error-&gt;error = <span class="number">0</span>;</span><br><span class="line">    writeBuffer[MAX_CHUNK_HEADER_SIZE - <span class="number">1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">    writeBuffer[MAX_CHUNK_HEADER_SIZE - <span class="number">2</span>] = <span class="string">'\r'</span>;</span><br><span class="line">    writeBase = &amp;(writeBuffer[MAX_CHUNK_HEADER_SIZE<span class="number">-3</span>]); </span><br><span class="line">    <span class="keyword">while</span> (chunkLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextDigit = chunkLength &amp; <span class="number">0xF</span>;</span><br><span class="line">        *writeBase = nextDigit &lt; <span class="number">10</span> ? <span class="string">'0'</span> + nextDigit : <span class="string">'A'</span> + nextDigit - <span class="number">10</span>;</span><br><span class="line">        writeBase --;</span><br><span class="line">        chunkLength = chunkLength &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (firstChunk) &#123;</span><br><span class="line">        writeBase ++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *writeBase = <span class="string">'\n'</span>;</span><br><span class="line">        writeBase --;</span><br><span class="line">        *writeBase = <span class="string">'\r'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (writeBase &lt; writeBuffer + MAX_CHUNK_HEADER_SIZE) &#123;</span><br><span class="line">        bytesWritten = <span class="built_in">CFWriteStreamWrite</span>(stream, writeBase, writeBuffer + MAX_CHUNK_HEADER_SIZE - writeBase);</span><br><span class="line">        <span class="keyword">if</span> (bytesWritten &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            *error = <span class="built_in">CFWriteStreamGetError</span>(stream);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesWritten == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Premature EOF; can we come up with a better error code?</span></span><br><span class="line">            error-&gt;domain = kCFStreamErrorDomainHTTP;</span><br><span class="line">            error-&gt;error = kCFStreamErrorHTTPParseFailure;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeBase += bytesWritten;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合理的样子是</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span><span class="string">\r\n</span></span><br><span class="line"><span class="string">Chunk_1\r\n</span></span><br><span class="line"><span class="number">7</span><span class="string">\r\n</span></span><br><span class="line"><span class="string">Chunk_2\r\n</span></span><br></pre></td></tr></table></figure>
<p>而 <code>Cocoa</code> 是这样子的</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span><span class="string">\r\n</span></span><br><span class="line"><span class="string">Chunk_1</span></span><br><span class="line"><span class="string">\r\n</span></span><br><span class="line"><span class="number">7</span><span class="string">\r\n</span></span><br><span class="line"><span class="string">Chunk_2</span></span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然 <code>Cocoa</code> 的实现不符合 <code>Azure</code> 的要求，那么有没有办法来 <strong>绕过</strong> 一下呢？既能让 <code>Azure</code> 转发第一个 <code>chunk</code>，也能让后端数据服务器正确识别。</p>
<h3 id="自己添加一个-CRLF"><a href="#自己添加一个-CRLF" class="headerlink" title="自己添加一个 CRLF"></a>自己添加一个 CRLF</h3><p>既然 <code>Azure</code> 会等待 <code>CRLF</code>，那么在第一个 <code>chunk</code> 结尾多加一个 <code>CRLF</code> 行不行？肯定不行，因为 <code>CRLF</code> 是不算在 <code>chunk-size</code> 里面的。并且会导致下一个 <code>chunk</code> 到来的时候，出现连续的 <code>CRLFCRLF</code>，虽然按要求最后一个 <code>chunk</code> 是 <code>0CRLFCRLF</code>，但有些服务器会兼容只有 <code>CRLFCRLF</code> 的情况。</p>
<h3 id="多发一个-chunk"><a href="#多发一个-chunk" class="headerlink" title="多发一个 chunk"></a>多发一个 chunk</h3><p>不能多加一个 <code>CRLF</code>，那么我们在建立 <code>name_channel</code> 的时候，多发一个 <code>chunk</code>，那么 <code>Azure</code> 收到的数据将会是这样的。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">C\r\n</span></span><br><span class="line"><span class="string">name_channel</span></span><br><span class="line"></span><br><span class="line"><span class="string">\r\n</span></span><br><span class="line"><span class="number">2</span><span class="string">\r\n</span></span><br><span class="line"><span class="string">OK</span></span><br></pre></td></tr></table></figure>
<p>上面的格式是为了方便区分两个 <code>chunk</code>，其实真正的数据是没有换行的，因为已经把 <code>\r\n</code> 写出来了。换一个写法。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">C\r\nname_channel\r\n2\r\nOK</span></span><br></pre></td></tr></table></figure>
<p>那么 <code>Azure</code> 收到这样的数据包之后，就会认为第一个 <code>chunk</code> （<code>C\r\nname_channel\r\n</code>）已经完整收到了，但第二个 <code>chunk</code> 还需要等待最后的 <code>CRLF</code>。这时 <code>Azure</code> 就会将 <code>name_channel</code> 这个 <code>chunk</code> 转发给后台服务器，然后就能正常的建立起连接了。当然后天服务器需要处理多发的那个包。</p>
<p>后续信令的 <code>chunk</code> 还需不需要每次都多发一个 <code>chunk</code>？在我们的场景中不需要也没有什么影响，因为后续的信令，是源源不断的发送出去的，所以不会出现等待下一个包的情况。即使是用户没有操作了，那么也会有心跳包，和 <code>ack</code> 的包，唯一影响的是后台服务器收到最后一个 <code>ack</code> 包的时间间隔会长一点。</p>
<h3 id="libcurl"><a href="#libcurl" class="headerlink" title="libcurl"></a>libcurl</h3><p>这个方案很简单，因为 <code>libcurl</code> 的实现，是跟我们预想中的那样的，每个 <code>chunk</code> 结尾都是一个 <code>CRLF</code>。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>A 和 B 在一起没问题，B 和 C 在一起没问题，C 和 A 在一起也没问题，但当 A 和 C 在一起的时候，出现了问题，并不能说明这是 A 的问题或者说是 C 的问题。</p>
<p>在测试环境中，上面多发一个 <code>chunk</code> 的方式是没有任何问题的。但是当部署到线上环境时，问题依然存在，后台服务器依然收不到请求包。除了一个是 <code>http</code> 一个是 <code>https</code> 之外，各种配置完全一样，<code>Azure CDN</code> 没法调试也没有日志可以打，这个问题暂时没有办法解决。</p>
<p>绝望之余，我看到了一种叫做 <a href="https://en.wikipedia.org/wiki/HTTP_request_smuggling" target="_blank" rel="noopener">HTTP request smuggling - Wikipedia</a> 的攻击手段，能给绕过 <code>Azure</code> 不能转发的问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2020/04/15/http-chunked/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/15/http-chunked/" itemprop="url">HTTP Streaming/Chunked</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-15T20:00:00+08:00">
                2020-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/networking/" itemprop="url" rel="index">
                    <span itemprop="name">networking</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>使用 <code>Cocoa Foundation</code> 框架来实现 <code>HTTP Streaming/Chunked</code> 的时候，底层会将设置的 <code>Transfer-Encoding: chunked</code> 的值改成大写的 <code>Chunked</code> 发出去，如果后端不支持，那么必须通过比如 <code>hook</code> 的方式不让底层对这个值进行修改并发送出去。其次就是如果服务器已经返回了数据但是框架没有给任何回调，可能是因为服务器返回的 <code>Content-Type</code> 为 <code>text/html</code>，导致框架等待 <code>first 512 bytes</code> 数据，改用其他的类型即可。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>提供全球服务的能音视频通话的 IM 产品，大多数都是以 <strong>自定义信令</strong> 为基础来提升网络性通信能以及防止被封禁。</p>
<p>常见的几种通信方式有：</p>
<ul>
<li>IP/Port (TCP)</li>
<li>TLS (TLS Resumption or TLS Verify)</li>
<li>GCM (FCM)</li>
<li>WebSocket</li>
<li>HTTP Persistent Connection</li>
</ul>
<p>前面几种都是其实都是通过 <code>IP/Port</code> 的方式来建立连接，那么一旦 IP 被封禁了，那么就只能通过其他手段下发 IP 地址然后不断的更换 IP 来绕过。 <code>GCM</code>(<a href="https://firebase.google.com/docs/cloud-messaging/" target="_blank" rel="noopener">FCM</a>) 是谷歌提供的信令通道。<code>WebSocket</code> 需要服务器的支持，<code>Nginx</code> 和 <code>Amazon Cloudfront</code> 是支持的，但是 <code>Azure</code> 和 <code>Azure Domain Fronting</code> 不支持。所以最近为了进一步完善网络通信的建设，决定增加 HTTP 长链接的通道作为候补。</p>
<h2 id="HTTP-Persistent-Connection"><a href="#HTTP-Persistent-Connection" class="headerlink" title="HTTP Persistent Connection"></a>HTTP Persistent Connection</h2><p>HTTP Persistent Connection 也叫 HTTP Connection Reuse 或者其他的 Keep Alive 等。像 IM 类型应用，如果每一次通信都使用普通的 HTTP(s) 的话，那么由于每次建立 TCP 都需要三次握手，外加上 SSL/TLS 握手，可能需要 10+ 个 RTT，这对于 IM 来说是难以接受的。优化的方向也很明显，就是尽量避免 HTTPS 建立和关闭所带来的性能消耗，最好就是整个生命周期内，只建立一次关闭一次。</p>
<p>HTTP 1.1 中默认使用 <code>Keep-Alive</code> ，来达到连接复用，但仅仅是这个对于 IM 应用来说，还是太捉襟见肘了。然后对比 <code>Long Poll</code> 的方式，显然 <code>Streaming</code> 的方式性能会更加好。</p>
<blockquote>
<p>HTTP 2.0 也由于服务器不支持的原因，暂时不可行。</p>
</blockquote>
<h2 id="Streaming-Chunked"><a href="#Streaming-Chunked" class="headerlink" title="Streaming/Chunked"></a>Streaming/Chunked</h2><p>HTTP 1.1 中支持了 chunked message （见 <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding" target="_blank" rel="noopener">Chunked transfer encoding - Wikipedia</a>）。利用这个特性，我们可以通过 chunked 的方式，来避免重复建立连接。</p>
<p>网络请求包含了上行和下行，所以我们调研了两种方案：</p>
<ol>
<li>利用一条 URL 同时上下行 chunked 数据，发现 <code>cloudfront</code> 是支持的，但 <code>Azure</code> 不支持。Azure cdn 在收到第一个下行包时，会在上行包中插入 chunked 结束符，并不再转发上行包，但下行包仍然会被转发到客户端。❌</li>
<li>利用两条 URL 来实现，一条s用于发送信令，一条用于读取信令。✅</li>
</ol>
<h3 id="How-to"><a href="#How-to" class="headerlink" title="How to"></a>How to</h3><p>既然是 HTTP 协议，那么首先想到的就是使用 <code>Foundation</code> 中的 <code>URLSession</code> 来实现。为了方便我们先把上行的 URL 叫做 <code>uplink</code> ，下行专用的 URL  叫做 <code>downlink</code>。</p>
<p>首先按照 <code>HTTP 1.1</code> 的标准，将 <code>uplink</code> 的请求头 <code>Transfer-Encoding</code> 设为 <code>chunked</code>。为了能给异步持续的将信令数据发送到服务器，需要利用 <code>Bound Pair Stream</code>，将 <code>InputStream</code> 连上 <code>httpBody</code>，然后持有 <code>OutputStream</code>，每次有数据需要发送的时候，就将数据从 <code>OutputStream</code> 写入，然后数据就会流到 <code>InputStream</code> 去，<code>URLSession</code> 就会不断的读取数据并发送到服务器。</p>
<p>至于 <code>downlink</code>，只需要服务器在 response 的时候，将 <code>Transfer-Encoding</code> 设为 <code>chunked</code> 即可，这样我们就可以通过 <code>delegate</code> 方法 <code>func urlSession(_:dataTask:didReceive:)</code> 源源不断的读取下行数据。</p>
<p>除此之外，后端还需要对 <code>uplink</code> 和 <code>downlink</code> 进行配对，进行密钥交换等步骤。成功之后才能够开始发送和接收普通的信令消息。举例比如我们配对的步骤叫做 <code>name channel</code>，首先是 <code>uplink</code> 发送第一个 <code>name channel</code> 的包，将加密方式、密钥和 <code>Connection ID</code> 等发送给服务器，然后进入等待状态。然后 <code>downlink</code> 发起请求，将 <code>name channel</code> 的数据发送给服务器，服务器通过对比 <code>Connection ID</code> 配对成功后，通过 <code>downlink</code> 返回第一个包，通知客户端已经连接建立完成，后续可以开始发送普通信令。</p>
<h3 id="But"><a href="#But" class="headerlink" title="But"></a>But</h3><p>但往往理想很丰满，现实却很骨感。</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h4><p>按照前面的流程建立连接，<code>uplink</code> 在发送第一个 chunk 数据的时候，服务端马上就返回了 <code>Server 500</code> 的错误。这个错误和 <code>Transfer-Encoding</code> 有关，通过抓包能看到请求的 <code>header</code> 和 <code>body</code> 都很普通。之前调研时使用 <code>python</code> 写的测试代码，已经证明了这个方案是没问题的。但到了 iOS 这一端，服务器却发生了错误。</p>
<p>通过连调，发现 <code>uplink</code> 走到了普通 <code>Post</code> 的流程，而不是应该的 <code>Stream</code> 流程。如果将 <code>Transfer-Encoding</code> 去掉，却不会 <code>Server 500</code>，连接正常结束了。得出结论是当存在 <code>Tranfer-Encoding</code> 为 <code>Chunked</code> 时，后端走到了 <code>Post</code> 流程，然后用 <code>Post</code> 流程的方式去获取 <code>body</code> 的时候，数据异常导致了 <code>Server 500</code>，简单来说也就是 <code>Transfer-Encoding</code> 和 <code>body</code> 不匹配。</p>
<p>根据抓包的数据对比，iOS 端的包和正常的 python 的包，<strong>唯一</strong> 的区别是 <code>Chunked</code> 和 <code>chunked</code>，一个大写一个小写。并且 <a href="https://www.wireshark.org" target="_blank" rel="noopener">Wireshark</a> 中也会提示 <code>[Expert Info (Warning/Undecoded): Unknown transfer coding name in Transfer-Encoding header]</code>。而我们在设置 <code>Transfer-Encoding</code> 的时候，其实也是使用小写的 <code>chunked</code>，但经过 <code>URLSession</code> 后会变成了大写。HTTP RFC 规定 header field 大小写不敏感，但没有对 value 进行规定。对比用的 python 的框架，则会将 <code>Transfer-Encoding</code> 处理成小写。这个问题和迷幻，但我们可以得到结论就是后端所使用的服务，并不支持大写的 <code>Chunked</code>。</p>
<p>解决办法就是通过 Hook 的方式，禁止底层将 <code>header</code> 中的 <code>Transfer-Encoding</code> 进行更改。</p>
<blockquote>
<p>实际操作中其实还有更多问题，比如 <code>URLSessionDataTask</code> 进行处理 <code>orignalRequest</code> 的时候，会把 <code>currentRequest</code> 的 <code>Transfer-Encoding</code> 的值设为 <code>nil</code>。</p>
</blockquote>
<h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h4><p>在 <code>downlink</code> 发送完 <code>name channel</code> 之后，一直等待不到返回，直到超时后才返回第一个包，<code>HTTP/1.1 200 OK</code>，并马上结束连接。由于 <code>downlink</code> 其实就是一个普通的 <code>POST</code> 请求，需要的参数也比较少，<code>name channel</code> 的数据也很容易确定是否正确，并且返回的第一个包 <code>header</code> 和 <code>body</code> 除了 <code>Transfer-Encoding</code> 为 <code>Identity</code> 外并无异常。</p>
<p>首先还是进行抓包，发现其实在请求刚发出去不久，服务器就马上返回了，并且 <code>header</code> 和 <code>body</code> 所有的数据都很正常，包括 <code>Transfer-Encoding</code> 为 <code>chunked</code>。问题来了，为什么服务器返回给 <code>URLSession</code> 了，<code>URLSession</code> 却没有通过 <code>delegate</code> 回调给我们呢，它连 <code>func urlSession(_:dataTask:didReceive, completionHandler:</code>，明明 <code>header</code> 和第一个 <code>chunk</code> 的 <code>body</code> 都已经返回了。</p>
<p>这个问题比问题 1 还迷，虽然它把 <code>Transfer-Encoding</code> 从 <code>chunked</code> 改为了 <code>Identity</code> 还能接受，因为我们还可以通过查看 <code>header</code> 中没有 <code>Content-Length</code> 来判断，它其实就是 <code>chunked</code> 的方式。</p>
<p>这个问题的解决过程比较曲折，首先我发现不等待 <code>downlink</code> 返回 <code>name channel</code> 成功，继续通过 <code>uplink</code> 发送信令时，<code>downlink</code> 就能够返回 <code>name channel</code> 成功的 <code>chunk</code> 以及后续信令的 <code>chunk</code>，<code>downlink</code> 不会超时断开。但是我们的整个流程是必须要等 <code>name channel</code> 成功之后才能发生消息，中间牵扯着很多 <code>seq</code> 和 <code>ack</code> 的问题。不能发送普通的信令，那么就尝试多发送一次 <code>name channel</code> 的时候，发现也还是不行。</p>
<p>发送普通信令可以，发送 <code>name channel</code> 却不行。后来尝试了其他信令，看看是否是偶然问题，最终发现了主要的问题：<strong> <code>URLSession</code> 会等待第一个 512 bytes 数据，只有当 buffer 大于 512 bytes 后才会返回 response 和 data</strong>。</p>
<p>通过以 <code>first 512 bytes</code> 为关键词搜索时，在 <a href="https://dev.w3.org/html5/cts/html5-type-sniffing.html" target="_blank" rel="noopener">HTML 5 rules for determining content types</a> 发现 H5 对 <code>first 512 bytes</code> 有一定的要求。猜想原因和 <code>Content-Type</code> 为 <code>text/html</code> 有关，后来验证了这个猜想。</p>
<p>反过来一想，也很难说 <code>URLSession</code> 的实现是否有问题，但没有任何文档说明确认给人带来不少困扰。对比起来 <code>Java</code> 和 <code>Python</code> 都没有遇到这个问题。至于为什么服务器返回的是 <code>text/html</code>，而不是做客户端常用的 <code>application/json</code> 之类的，大概是因为后端用的服务框架是一个标准对 <code>web</code> 框架吧。</p>
<p>到这里解决方式就很简单了，<strong> 把该死的 <code>Content-Type</code> 改为符合场景的 <code>application/octet-stream</code> </strong>。</p>
<h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h4><p>其实是最初遇到的问题，就是 <code>Proxy</code> 的影响。首先 <code>Proxy</code> 看到的数据，是否可信的问题，其次就是 <code>Proxy</code> 对 <code>header</code> 带来的影响，比如 <code>End-to-end headers</code> 和 <code>Hop-by-hop headers</code>。(<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" rel="noopener">HTTP headers - HTTP | MDN</a>）</p>
<p>开发过程中，早期使用 <code>Charles</code> 和 <code>ProxyMan</code> 来抓 <code>HTTPS</code> 的包，没有遇到问题 1 <code>Server 500</code> 的问题，某一次重启电脑后，没有打开 <code>Proxy</code>，然后才发现会稳定出现 <code>Server 500</code>。</p>
<p>还有值得一提的就是代码服务器的问题，在开发过程中也遇到过直连和通过代理服务器后出现不一致的问题，虽然后端说代理服务器不会做任何处理，只是将数据进行透传。</p>
<h4 id="其他的方案"><a href="#其他的方案" class="headerlink" title="其他的方案"></a>其他的方案</h4><p>在解决上面的几个问题时，由于文档和相关的讨论都比较少，并且没有看到有人遇到这些问题，在确定问题出在 <code>URLSession</code> 及其底层实现上的情况下，在没头绪的时候还尝试过 <code>libcurl</code> 的方案。</p>
<p>由于 apple 为了建设 Swift 的生态，提供了一个开源版的 <a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">Foundation</a>，其中就包含有 <a href="https://github.com/apple/swift-corelibs-foundation/tree/master/Sources/FoundationNetworking/URLSession" target="_blank" rel="noopener">URLSession</a> 的实现。在使用过程中发现它在处理 <code>body</code> 的时候，是有问题的： <code>当 Body 为 Stream 的情况下，根据 libcurl 的 read function 来读取 body 数据，每次读取一个指定大小的 chunk，当读取的时候，发现 inputStream 已经没有数据了，就认为是读取完所有数据了。</code> 这显然与我们的要求，以及 iOS 上的 <code>URLSession</code> 的行为不一致，<code>input stream</code> 在读的时候没读到数据，有可能 <code>output stream</code> 还在写或者即将写，并不代表整个流已经完成。最简单来说就是为了性能考虑，<code>Output stream</code> 并不是用循环的方式进行写数据的，它有一个有限大小的 <code>buffer</code>，必须要等到有足够空间的时候才能成功写入数据。所以一般的方式也是 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Streams/Streams.html#//apple_ref/doc/uid/10000188-SW1" target="_blank" rel="noopener">官方推荐</a> 的方式，都是使用 <code>RunLoop</code> 。</p>
<p>所以我们需要将这部分的实现改一下，改为 <code>RunLoop</code> 的方式，当 <code>read function</code> 要读取数据时，发现 <code>input stream</code> 还没有数据，那么就返回 <code>retryLater</code>，告诉 <code>libcurl</code> 的 <code>read socket</code> 暂停发送数据，先等待。当 <code>RunLoop</code> 告诉我们有数据了 <code>hasBytesAvailable</code> 的时候，再让 <code>read socket</code> 进行 <code>resume</code>。可以参考 <code>File</code> 类型的 <code>Body</code> 的实现。</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>如果想用 <code>Cocoa Foundation</code> 实现 <code>Streaming/Chunked</code>，可能并不会那么顺利。有些问题在其他平台没有暴露出来，也不代表着一定就是 <code>Cocoa Foundation</code> 的锅，要善于用可靠的方式从一个更 low level 的角度找到不同平台不同实现直接的差异。当没有文档资料对问题有帮助的时候，「思考 -&gt; 猜测 -&gt; 验证」，可能是最佳的解决问题的方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2019/06/05/existential/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/05/existential/" itemprop="url">∃ Existential</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-05T20:00:00+08:00">
                2019-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最初看到 <strong>existential</strong> 这个词，是在 <a href="http://www.russbishop.net/swift-associated-types-cont" target="_blank" rel="noopener">Swift Associated Types, cont.</a> 这篇文章中（第一次知道 <code>typealias Any = protocol&lt;&gt;</code> 也是在这篇文章），但当时并没有对这个陌生名称留下什么深刻印象。</p>
<p>后来陆陆续续应该也看到过一些，比如 <a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance - WWDC 2016</a>。</p>
<p>真正的想要去了解它，是之前写 <a href="http://blessingsoft.com/2018/08/26/pats/">PATs</a> 的时候，那时候 <strong>existential</strong> 这个词很高频的出现，甚至是和 PATs 息息相关，所以进行了一个初步的了解。</p>
<p>但是呢，只是片面的了解，而没有建立起立体的认识，记忆很快就会开始模糊，直到最后忘记掉。所以才有了这次的 <strong>existential</strong> 认知之旅。</p>
<blockquote>
<p>注：这篇大多数概念、观点、片段都来自于官方文档或者参考文章，小部分自己的认知理解，并且不保证理解的正确。</p>
</blockquote>
<h2 id="Existential-Type"><a href="#Existential-Type" class="headerlink" title="Existential Type"></a>Existential Type</h2><p>想理解 <strong>existential</strong>，必须要先了解 <strong>existential values</strong>, <strong>existential containers</strong> 和 <strong>witness tables</strong> 的概念。</p>
<p>在类型论中， <a href="https://en.wikipedia.org/wiki/Type_system#Existential_types" target="_blank" rel="noopener">existential type</a> 描述了抽象类型的接口。当对象的类型是 <code>protocol</code> 时，就会用到 <strong>existential type</strong>，因为存储或传递一个 <code>protocol</code> 类型的对象意味着对象在运行时的真实类型是不透明的（也就是编译期不可知的，因此我们也无法确定这类对象的布局）。</p>
<p>一个遵从了特定 <code>protocol</code> 的类型一定包含其约定的所有方法，但是这些方法的地址是无法在编译期确定的，因为我们只有在运行时，才能确定这个 <code>protocol</code> 对应的真实类型。这和 <code>non-final class</code> 引用是类似的（因为可能被 override），因此也使用了 <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md#method-dispatch" target="_blank" rel="noopener">类似的技术手段</a> 来解决。<code>Protocol</code> 中约定的每一个被实现的方法的地址，都被保存在 <strong>witness table</strong> 中。</p>
<h3 id="Existential-Value"><a href="#Existential-Value" class="headerlink" title="Existential Value"></a>Existential Value</h3><p>显然的，<strong>existential type</strong> 的值，就是 <strong>existential value</strong>。:P</p>
<h3 id="Existential-Container"><a href="#Existential-Container" class="headerlink" title="Existential Container"></a>Existential Container</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foos: [<span class="type">Foo</span>] = ... <span class="comment">// What's the memory storage looks like?</span></span><br></pre></td></tr></table></figure>
<p>简单来说 <strong>existential of a protocol</strong> 就是一个编译器生成的盒子 box，用来存放遵从这个 <code>protocol</code> 的值，这个盒子，也叫做 <strong>Existential Container</strong>，盒子里面的东西，就叫做 <strong>witness</strong>。</p>
<p>关于 <strong>existential container</strong> 的内存布局，这些值怎么存储，要分几种情况来说。因为值类型和引用类型的处理方式不一样，值比较小和比较大也可以为了性能用不同的策略。<a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance - WWDC 2016</a> 和 <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" target="_blank" rel="noopener">ABIStabilityManifesto · GitHub</a> 中都有详细的描述。</p>
<p>简单来说就是 5 个字节的大小，前三个连续的字节叫做 <em>value buffer</em>，用来存放对象的值或者指针。值类型如果放得下，就直接内联放在 <em>value buffer</em> 里面，如果放不下，就在存放在堆上，把指针地址存放在 <em>value buffer</em> 里；引用类型直接放指针。<br>第四个字节存放 <code>vwt</code> (<em>value witness table</em>) 指针。<br>第五个字节存放 <code>pwt</code> (<em>protocol witness table</em>) 指针。</p>
<p>对于那些限定了只能是 <code>class</code> 实现的 <code>protocol</code>，<code>containers</code> 中则会忽略 <code>vwt</code> 指针（因为对象自身包含指向自己类型信息的指针）以及多余的内连 buffer。并且，这里还有一个特例 <code>Any</code>，由于它没有遵从任何 <code>protocol</code>，因此 <code>Any</code> 对象的 <code>containers</code> 中没有 <em>witness table</em> 指针。（没错，<code>Any</code> 也是一个 <strong>existential</strong> ！即使 Swift 3 之后把 <code>Any</code> 当作了 keyword，但估计和之前的 <code>protocol &lt;&gt;</code> 差不多的实现，所以依然是 <strong>existential</strong> 。）</p>
<h3 id="VWT"><a href="#VWT" class="headerlink" title="VWT"></a>VWT</h3><p>每一个具体类型（concrete type）都有一张 <em>value witness table</em>，用来存放这个类型的有关内存布局和操作它的值的信息。当一个值类型具有不透明布局的时候，因为值编译的时候没办法知道实际类型，所以只能通过查询这个表来知道这些有关信息（metadata）。</p>
<h3 id="PWT"><a href="#PWT" class="headerlink" title="PWT"></a>PWT</h3><p><em>Protocol witness table</em> 是 <code>protocol</code> 接口的一张函数表。如果有 associated type，它还会存储 associated type 的 metadata。</p>
<blockquote>
<p>所以什么是 <strong>existential</strong> 是什么？就是一个 <code>protocol</code> 类型的值。</p>
</blockquote>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>当一个 <code>protocol</code> 作为类型而不是具体的类型约束的时候，它就是一个 <strong>existential</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span>&lt;T: Foo&gt;<span class="params">(<span class="number">_</span> foo: T)</span></span> &#123;&#125; <span class="comment">// This requires a concrete T that conforms to Foo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">baz</span><span class="params">(<span class="number">_</span> foo: Foo)</span></span> &#123;&#125; <span class="comment">// This requires a variable of type Foo (pedantically: "a Foo existential")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo: <span class="type">Foo</span> = ... <span class="comment">// existential of protocol `Foo`</span></span><br><span class="line">bar(foo) <span class="comment">// 😢 Protocol type 'Foo' cannot conform to 'Foo' because only concrete types can conform to protocols</span></span><br><span class="line">baz(foo) <span class="comment">// 😊</span></span><br></pre></td></tr></table></figure>
<p>所以当看到 “a protocol doesn’t conform to itself” 的时候，它实际上是指 “the existential of a protocol doesn’t conform to that protocol”。 </p>
<h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p><strong>Existentials</strong> 不是真正的泛型（<code>generic</code>），但由于它们相互依赖于 <code>protocol</code>，这两个系统紧密地交织在一起。</p>
<blockquote>
<p>While protocols create existential (“there exists”) types, generics create universal (“for all”) types. </p>
</blockquote>
<p>先回顾一下泛型的一些常见概念：</p>
<ul>
<li>泛型函数 <code>func swap&lt;T&gt;(_ a: inout T, _ b: inout T)</code></li>
<li>类型参数 <code>&lt;T&gt;</code></li>
<li>泛型类型 <code>Queue&lt;T&gt;</code></li>
<li>类型约束 <code>&lt;T: Protocol, U: Class&gt;</code></li>
<li>关联类型 <code>associatedtype T</code></li>
<li>泛型从句 <code>func foo&lt;T: P, U: P&gt;(_ a: T, _ b: T) where T: Equatable, T.Item == U.Item</code></li>
</ul>
<p>当使用泛型作为类型约束的时候，会涉及到 <strong>existentials</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span>&lt;T: Foo&gt;<span class="params">(<span class="number">_</span> foo: T)</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo: <span class="type">Foo</span> = ...</span><br><span class="line">bar(foo) <span class="comment">// Protocol type 'Foo' cannot conform to 'Foo' because only concrete types can conform to protocols</span></span><br></pre></td></tr></table></figure>
<h2 id="PATs"><a href="#PATs" class="headerlink" title="PATs"></a>PATs</h2><p>既然有 <strong>existentials</strong> 了，那为什么还需要 <strong>type eraser</strong> 呢？</p>
<p>先回过头来看看之前在 <a href="http://blessingsoft.com/2018/08/26/pats/">PATs</a> 中遇到的几个问题。</p>
<blockquote>
<p>Protocol ‘Caching’ can only be used as generic constraint because it has Self or associated type requirements</p>
</blockquote>
<p>它的意思是，<code>Caching</code>  这个 PATs 没有（无法自动生成）一个 <strong>existential</strong>.</p>
<blockquote>
<p>Using ‘Logging’ as a concrete type conforming to protocol ‘Hashable’ is no supported</p>
</blockquote>
<p>它的意思是，这个 <code>Logging</code> 的 <strong>existential</strong> 没有实现 <code>Hashable</code> 这个协议。</p>
<p>为什么无法为 PATs 生成一个 <strong>existential</strong> 呢？实际上是可以的，但它很复杂。它可以通过一种叫做 <strong>generalized existentials</strong> 的技术，生成一个 <strong>implicit existential</strong>。即使这样，它还有很多问题需要解决。</p>
<p>对于 <strong>existential</strong> 的自动生成，首先 <strong>existential</strong> 是运行时的（泛型 <code>generic</code> 是编译时的），它是通过在运行时，把 <code>protocol</code> 的一些信息存放在 <strong>existential container</strong> 里面。当 <code>protocol</code> 里面存在有 <em>associated types</em> 或者有 <code>Self</code> 约束的时候，它没办法针对任意类型（Any）自动生成填充这个 <strong>existential container</strong>。（Swift 是静态语言，对于泛型需要在编译时就进行泛型特化，<strong>generic specialization</strong>，除非把泛型当作是 <code>Any</code> 来处理。还有一种方式就是对 PATs 进行约束，<code>let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>，也就是 <code>AnySequence&lt;String&gt;</code> ）</p>
<p>理解这一点非常重要，可能会有点晕，再来捋一下。首先编译器把存储或者传递的  <code>protocol</code> 类型，先替换成 <code>existential container</code>（生成代码），然后再编译成目标代码。当编译器发现这个 <code>protocol</code> 是 PATs 时，它如果不通过 <em>generic specialization</em> 的话，无法生成不带泛型的代码。那为什么说 <strong>existential</strong> 是运行时的呢？因为存储或传递一个 <code>protocol</code> 类型的对象意味着对象在运行时的真实类型是不透明的（也就是编译期不可知的，因此我们也无法确定这类对象的布局）。</p>
<p>还有一些类型是不适合自动生成 <strong>existential</strong> 的，编译器没法满足有 <code>init</code> 和 <code>static</code> 的要求。比如 <code>Decodable</code> 这样的没有实例方法的协议，<strong>existential</strong> 没有任何意义。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span>: <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(<span class="number">_</span> decodable: Decodable)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> decodable: <span class="type">Decodable</span> = <span class="type">Model</span>(x: <span class="string">"x"</span>)</span><br><span class="line">decode(decodable)</span><br><span class="line"><span class="comment">// 上面对代码编译起来没有任何问题，也就是能自动生成 *existential*</span></span><br><span class="line"><span class="comment">// 但对于 decode(_:) 函数，根本无从下手，因为 Decoder 需要的是一个遵守 Decodable 协议的类型，而不是值。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(<span class="number">_</span> type: Decodable.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> decodable = <span class="type">JSONDecoder</span>().decode(type, from: data)</span><br><span class="line">    <span class="comment">// let decodable = JSONDecoder().decode(Decodable.self, from: data)</span></span><br><span class="line">    <span class="comment">// Protocol type 'Decodable' cannot conform to 'Decodable' because only concrete types can conform to protocols</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终还是那个 `Protocol type 'Decodable' cannot conform to 'Decodable' because only concrete types can conform to protocols`</span></span><br></pre></td></tr></table></figure>
<p>其实 <strong>type eraser</strong> 和 <strong>existentials</strong> 这两种是对偶的（ duals ），泛型（ generic ）的 <code>Any&lt;T&gt;</code> 等同于 协议（ protocol ）的一种 <strong>explicit existential</strong>。</p>
<h2 id="Existential-in-Other-Language"><a href="#Existential-in-Other-Language" class="headerlink" title="Existential in Other Language"></a>Existential in Other Language</h2><h3 id="Existential-type-in-Java"><a href="#Existential-type-in-Java" class="headerlink" title="Existential type in Java"></a>Existential type in Java</h3><p>Java 泛型中的 <strong>Wildcards</strong> 其实就是一种 existential type，比如 <code>java.util.List&lt;?&gt;</code>。</p>
<p>在 Java 中由于有<a href="h">类型擦除</a> 的存在，泛型的参数类型信息在运行时会丢失，在运行时无法根据已知的类型信息区分 <code>List[Int]</code> 和 <code>List[String]</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List foo = <span class="keyword">new</span> ArrayList();</span><br><span class="line">foo.add(<span class="string">"foo"</span>);</span><br><span class="line">foo.get(<span class="number">0</span>); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<p>当没有给出类型参数的时候，通过使用 existential 来解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;</span><br><span class="line">List&lt;? extends Number&gt;</span><br><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Existential-type-in-Kotlin"><a href="#Existential-type-in-Kotlin" class="headerlink" title="Existential type in Kotlin"></a>Existential type in Kotlin</h3><p>Kotlin 中没有 <strong>existential type</strong>。它有一个概念叫着 <strong>The Existential</strong> 的概念。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dogBar: Bar&lt;Dog&gt; = Bar()</span><br><span class="line"><span class="keyword">var</span> animalBar: Bar&lt;Animal&gt; = dogBar <span class="comment">// 😢</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dogBar: Bar&lt;Dog&gt; = Bar()</span><br><span class="line"><span class="keyword">var</span> animalBar: Bar&lt;Animal&gt; = dogBar <span class="comment">// 😊</span></span><br></pre></td></tr></table></figure>
<h3 id="Existential-type-in-Scala"><a href="#Existential-type-in-Scala" class="headerlink" title="Existential type in Scala"></a>Existential type in Scala</h3><p><code>ArrayList() == List[]</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Trait</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(seq: <span class="type">Seq</span>[<span class="type">String</span>]): <span class="type">Seq</span>[<span class="type">String</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(seq: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">Seq</span>[<span class="type">Int</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error, have the same type after erasure</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span>[_] <span class="comment">// List[T] forSome &#123; type T &#125;</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[+<span class="type">T</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="Existential-type-in-Rust"><a href="#Existential-type-in-Rust" class="headerlink" title="Existential type in Rust"></a>Existential type in Rust</h3><p> <code>fn foo() -&gt; impl Trait</code></p>
<p>核心在于 <code>impl Trait</code>，和 Swift 5.1 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md" target="_blank" rel="noopener">Opaque Result Types</a> 中的 <code>func foo() -&gt; some P</code> 一样。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><strong>Existential</strong> 是什么？<strong>Existential</strong> 就是 <code>protocol</code> 类型的值。这是编译层面相关的概念，平时写代码不需要知道它意味着什么或者是什么，只需要知道它会跟你想象中一样 work 就行了。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://www.russbishop.net/swift-associated-types-cont" target="_blank" rel="noopener">Swift Associated Types, cont. - Russ Bishop</a><br><a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" target="_blank" rel="noopener">ABIStabilityManifesto · GitHub</a><br><a href="https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md" target="_blank" rel="noopener">GenericsManifesto · GitHub</a><br><a href="https://forums.swift.org/t/improving-the-ui-of-generics/22814" target="_blank" rel="noopener">Improving the UI of generics - Swift Forums</a><br><a href="http://robnapier.net/existential-spelling" target="_blank" rel="noopener">Protocols III: Existential Spelling - Cocoaphony</a><br><a href="https://en.wikipedia.org/wiki/Type_system#Existential_types" target="_blank" rel="noopener">Existential types - Wikipedia</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance - WWDC 2016</a><br><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md" target="_blank" rel="noopener">0244-opaque-result-types - GitHub</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2018/11/19/from-result-to-error-handling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/from-result-to-error-handling/" itemprop="url">From Result to Error Handling</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T20:00:00+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近关于 <a href="swift-evolution/0235-add-result.md at master · apple/swift-evolution · GitHub">Add Result to the Standard Library</a> 的提案正在激烈的<a href="SE-0235 - Add Result to the Standard Library - Proposal Reviews - Swift Forums">讨论中</a>，讨论的内容从命名到异步错误处理，再到是否应该有一个 <code>Either</code> 类型等等。</p>
</blockquote>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>对于在项目中使用过 Swift 的人来说，<code>Result</code> 类型应该再熟悉不过了，在 community 中有着非常广泛的应用。最早看到对于 <code>Result</code> 的应用是在<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a> 中，然后是有订阅的博客开始介绍 <code>Result</code> 是如何帮忙解决非必要的错误值/可选值检查，明确的区分成功和失败。再后来就是大家都开始在项目中使用 <code>Result</code> 类型来进行 <strong>异步错误处理</strong>。</p>
<p>为什么说 <strong>异步错误处理</strong> 呢，因为最早接触到 <code>Result</code> 这个类型的使用案例，就是用来处理异步错误的，并且它非常的适合，如果不从语言设计上考虑的话，它可以说是非常完美，因为它和 <code>Optional</code> 一样是个 Monad。虽然 <code>Result</code> 只是一个非常简单的数据结构，它和同步异步一点关系都没有，它只跟错误处理有关。</p>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>错误处理按执行顺序上可以分为同步（synchronization）和异步（concurrency）两种。</p>
<p>同步错误处理在 Cocoa 中有两种，一种是 <code>throw</code> + <code>try catch</code>，遇到异常的时候函数内部通过 <code>throw</code>/<code>raise</code>等关键词把异常信息抛出，调用方通过 <code>try catch</code> 进行捕获。另一种是古老的 C 中的 Error 指针，调用方通过把 Error 指针作为参数传到函数内部，当遇到错误时，给 Error 指针赋值，以达到把错误信息往外传递的目的。</p>
<p>异步错误处理在 Cocoa 中一般是通过 block, delegate 或者 notification 等方式进行传递，但大多数接口通常会把正常结果回调和异常结果回调合并一起进行回调，好处在于不需要两个 block 或者两个 delegate 函数或者 notification，缺点也就是上面的 <code>Result</code> 解决的问题。除此之外也有一些比较少见的方式，比如 <a href="https://developer.apple.com/documentation/avfoundation/avassetexportsession" target="_blank" rel="noopener">AVAssetExportSession</a>，它的 <code>completionHandler</code> 是 <code>@escaping () -&gt;  Void</code>，并不携带任何正常和错误的信息，而是通过 <code>var status: AVAssetExportSession.Status</code> 和 <code>var error: Error?</code> 等属性来提供。</p>
<p>抛开遥遥无期的 async/await 不谈，对于异步错误处理来说，可能由于网络库之类的接触的太多，所以平时去设计 API 的时候都非常的顺手的就写出来了，要么 <code>completionHandler: (Value?, Error?) -&gt; Void</code>，要么 <code>completionHandler: (Result&lt;Value&gt;) -&gt; Void</code>。但是对于同步错误处理却不是这样。</p>
<p>首先在 Swift 中推荐的错误处理是 <code>throw</code> + <code>try catch</code>，所以 Error 指针是不需要再讨论的。但不知道是因为 <code>throw</code> + <code>try catch</code> 难用，还是因为懒，一般的项目中其实很少见到 <code>throw/throws/rethrows</code> 这样的关键词（ObjC 中很少见到 throw/raise 同理）。</p>
<p>注：异步中是无法直接使用 <code>throw</code> + <code>try catch</code>，下面的两种写法都是不合法的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(forKey key: StoreKey)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    queue.async &#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="keyword">try</span> disk.url(atPath: path(forKey: key), <span class="keyword">in</span>: directory)</span><br><span class="line">        <span class="keyword">try</span> disk.remove(at: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(forKey key: StoreKey)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> queue.async &#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="keyword">try</span> disk.url(atPath: path(forKey: key), <span class="keyword">in</span>: directory)</span><br><span class="line">        <span class="keyword">try</span> disk.remove(at: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="万恶的-return"><a href="#万恶的-return" class="headerlink" title="万恶的 return"></a>万恶的 return</h3><p>一个当前在做的 Alligator 项目中的代码片段：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 视频导出</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter asset: 要导出的视频资源</span></span><br><span class="line"><span class="comment">/// - Parameter outputURL: 指定的导出地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">export</span><span class="params">(asset: AVAsset, to outputURL: URL)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> outputURL.isFileURL <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">"output url must be file url."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> exportSession = <span class="type">AVAssetExportSession</span>(asset: asset, presetName: <span class="type">AVAssetExportPresetHighestQuality</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exportSession.outputURL = outputURL</span><br><span class="line">    exportSession.outputFileType = .mp4</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的大概功能是进行配置和导出视频到文件，看起来是不是很熟悉？有参赛合法性的判断，提供开发调试帮助的 assertion，<code>guard</code> 的使用也很合理。</p>
<p>再看一段：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VideoProcessor.swift</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> videoWriterInput = </span><br><span class="line">    <span class="keyword">let</span> audioWriterInput = </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> videoWriter = <span class="keyword">try</span>? <span class="type">AVAssetWriter</span>(outputURL: outputURL, fileType: .mp4) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> videoWriter.canAdd(videoWriterInput) &#123;</span><br><span class="line">        videoWriter.add(videoWriterInput)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">"can't add video writer input"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> videoWriter.canAdd(audioWriterInput) &#123;</span><br><span class="line">        videoWriter.add(audioWriterInput)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">"can't add audio writer input"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似这样的代码在 project 中应该非常常见，但是却有着非常大的问题，那就是 <strong>故意的忽略异常</strong>。只处理了一切正常执行的分支，当遇到异常的时候，直接 return 或是加上 assertion 信息。这样写大多数情况下都没有什么问题，功能也正常，即使是遇到了异常情况，也不会引起 crash，但却有着很大的缺陷。（甚至有很多人连 assertion 都不用，替而代之的是 <code>print</code> :P</p>
<p>在这个例子中这些视频处理的逻辑实际上是相对比较独立的，功能也比较”单一”，这些异常一旦出现，后续的逻辑基本都是不可用，并且大多数的异常在实际应用中是需要被调用方知道并处理的，比如体现在 UI 上。</p>
<p>一个带异常处理（滑稽）的视频处理的示例代码片段：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVAsset+Processor.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Alligator</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">AVAsset</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Merge the given video asset and audio asset</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - videoAsset: the given video asset</span></span><br><span class="line">    <span class="comment">///   - audioAsset: the given audio asset</span></span><br><span class="line">    <span class="comment">/// - Returns: the merged asset</span></span><br><span class="line">    <span class="comment">/// - Throws: throws error when the given asset is invalid. e.g. video asset without video tracks.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(videoAsset: AVAsset, audioAsset: AVAsset)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">AVAsset</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> mixComposition = <span class="type">AVMutableComposition</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> mixComposition.agt.add(.video, from: videoAsset)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> videoDuration = mixComposition.duration</span><br><span class="line">        <span class="keyword">try</span> mixComposition.agt.add(.audio, from: audioAsset, maxBounds: videoDuration)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mixComposition</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Merge the given assets one by one</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - segments: given assets, it can't be empty</span></span><br><span class="line">    <span class="comment">///   - isMuted: if true, it will passthrough audio tracks</span></span><br><span class="line">    <span class="comment">/// - Returns: merged asset</span></span><br><span class="line">    <span class="comment">/// - Throws: throws error when segments is empry, or some segment is invalid.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(segments: [AVAsset], isMuted: Bool)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">AVAsset</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !segments.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.segmentsEmpty</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> segments.<span class="built_in">count</span> &gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> mixComposition = <span class="type">AVMutableComposition</span>()</span><br><span class="line">            <span class="keyword">try</span> mixComposition.agt.add(segments, isMuted: isMuted)</span><br><span class="line">            <span class="keyword">return</span> mixComposition</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> segments[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无脑的-Optional"><a href="#无脑的-Optional" class="headerlink" title="无脑的 Optional"></a>无脑的 Optional</h3><p>无脑的 Optional 指的是，对于一个有明确返回值类型 <code>T</code> 的函数，有可能出现某个入参不符合要求的情况，就把返回值改成 <code>T?</code>，用 <code>return nil</code> 来处理异常。如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Format a string, replace invalid symbol with empty character</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameter string: string needs to be format</span></span><br><span class="line">    <span class="comment">/// - Returns: formatted string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> string.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> string.replacingOccurrences(of: <span class="string">"\n"</span>, with: <span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该大多数人都试过这样，并且甚至有人一直都是这样，不经思索。有人会觉得这样写并没有什么问题。那么再看：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Format a string, replace invalid symbol with empty character. If it is empty or contains `@`, `#`, return nil.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameter string: string needs to be format</span></span><br><span class="line">    <span class="comment">/// - Returns: formatted string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> string.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> !string.<span class="built_in">contains</span>(<span class="string">"@"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> !string.<span class="built_in">contains</span>(<span class="string">"#"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> string.replacingOccurrences(of: <span class="string">"\n"</span>, with: <span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写有没有问题呢？或者说有没有更好的方案呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> emptyString</span><br><span class="line">        <span class="keyword">case</span> containsHashtag</span><br><span class="line">        <span class="keyword">case</span> containsMention</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Format a string, replace invalid symbol with empty character</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameter string: string needs to be format</span></span><br><span class="line">    <span class="comment">/// - Returns: formatted string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(<span class="number">_</span> string: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> string.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.emptyString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> !string.<span class="built_in">contains</span>(<span class="string">"@"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.containsMention</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> !string.<span class="built_in">contains</span>(<span class="string">"#"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.containsHashtag</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> string.replacingOccurrences(of: <span class="string">"\n"</span>, with: <span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个问题可以归为，<strong>对于同步 API 的异常处理，什么时候应该使用 throw？，什么时候可以返回 nil？</strong></p>
<p>这是一个很大的话题，并且大多数情况下需要根据场景来选择。通过对比这两种设计，可以简单的理解为如果希望使用方以更加合适的方式来处理错误，错误信息分类清晰详细，那么应该使用 <code>throw</code>。是否需要隐藏异常，交给使用方来决定。如果错误比较单一明确，可以考虑使用 <code>Optional</code>。</p>
<h3 id="混淆的人为错误和程序错误"><a href="#混淆的人为错误和程序错误" class="headerlink" title="混淆的人为错误和程序错误"></a>混淆的人为错误和程序错误</h3><p>简单来说对于人为错误，应该通过 <code>assertion</code>, <code>precondition</code>, <code>fatalError</code> 等来帮助在开发测试阶段发现问题。而对于程序错误，应该根据同步或者异步来区分处理，使得程序能继续正常的工作。</p>
<p>人为错误一般是指手误参数传错这种，如果没有手误（比如拼错单词、下标越界等），从逻辑上说不可能发生这种情况。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">else</span> &#123;</span><br><span class="line">        fataError(<span class="string">"不应该啊兄弟"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序错误更多是指所有参数都没有错误，但还是遇到异常了，并且不能忽略，比如磁盘满了导致无法写入文件。</p>
<blockquote>
<p>最后值得一提的就是大多数人在写 ObjC 的时候都会选择性的忽略异常，经典的场景就是设计 API 的时候滥用 <code>id</code>，然后虽然在方法内部对参数类型进行了判断，但在出现参数类型不合法的时候，直接通过 <code>return</code> 来处理。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/apple/swift-package-manager/blob/master/Sources/Basic/Result.swift" target="_blank" rel="noopener">Swift Package Manager</a><br><a href="https://onevcat.com/2018/10/swift-result-error/" target="_blank" rel="noopener">Result&lt;T&gt; 还是 Result&lt;T, E: Error&gt;</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2018/08/26/logging-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/logging-system/" itemprop="url">How to design a lightweight Logging System</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T20:00:00+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>之前项目一直都是使用 <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a> 来定制 Log 系统，这次整个工程使用 Pure-Swift 来开发，而且作为一个初创项目，对于 Log 系统的需求并没有那么高，虽然 <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a> 在 Swift 项目中直接使用也比较友好，但是感觉还是 <del>太重了</del> 。所以为何不直接设计一个比较轻量级的日志系统呢？</p>
</blockquote>
<h2 id="Logging-System"><a href="#Logging-System" class="headerlink" title="Logging System"></a>Logging System</h2><p>在 iOS 中，可以用 Swift 中的 <code>print()</code> 和 <code>debugPrint()</code> 函数来向 Xcode Console 来打印信息，也可以使用 Foundation 中的 <code>NSLog()</code> 来打印，更新的就是 <a href="https://developer.apple.com/documentation/os/logging" target="_blank" rel="noopener">os_log</a> 了。这三种不同的方式有不同的特点。</p>
<ul>
<li><strong>print</strong>/<strong>debugPrint</strong>: Swift 语言层面提供的实现，可以输出到 Xcode Console，但不能输出到 Apple System Logs（Mac Console.app）。</li>
<li><strong>NSLog</strong>: Foundation 中的实现，除了能在 Xcode Console 中输出外，还会往 Console.app 发，并且有较大的性能损害。</li>
<li><strong>os_log</strong>: 待补充 <a href="https://developer.apple.com/videos/play/wwdc2016/721/" target="_blank" rel="noopener">Unified Logging and Activity Tracing - WWDC 2016 - Videos - Apple Developer</a> <a href="https://developer.apple.com/videos/play/wwdc2018/405/" target="_blank" rel="noopener">Measuring Performance Using Logging - WWDC 2018 - Videos - Apple Developer</a></li>
</ul>
<p>Xcode Console 和 Apple System Logs 都是需要物理接触设备才能看到 log。但是在项目中，如果想要看到线上用户的 log 信息，必须要把这些 log 写到本地文件中，或者实时/定时发到远端服务器上。这时候直接使用内置的 API 是无法满足需求的。</p>
<p>对于一个相对比较合理的日志系统，一般有几点要求：</p>
<ul>
<li>在 release 下禁止输出日志到 Xcode Console</li>
<li><del>在 release 下</del> 禁止输出日志到 Apple System Logs</li>
<li>提供输出日志到本地文件中的能力</li>
<li>能够方便的扩展，如直接输出到 Web</li>
<li>对于日志根据重要性划分为不同的等级</li>
<li>可以根据日志等级，过滤日志</li>
</ul>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h3><p>Level 有两个作用：</p>
<ul>
<li>定义一条日志的重要性</li>
<li>对日志进行过滤，比如过滤掉某个等级以下的日志（实际是有包含的关系</li>
</ul>
<p>这里通过两个类型来实现 level 的作用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Level</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> off = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> error = <span class="number">1</span> <span class="comment">// Flag.error | Level.off</span></span><br><span class="line">    <span class="keyword">case</span> warning = <span class="number">3</span> <span class="comment">// Flag.warning | Level.error</span></span><br><span class="line">    <span class="keyword">case</span> info = <span class="number">7</span> <span class="comment">// Flag.info | Level.warning</span></span><br><span class="line">    <span class="keyword">case</span> debug = <span class="number">15</span> <span class="comment">// Flag.debug | Level.info</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Flag</span>: <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> rawValue: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> error = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> warning = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> info = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> debug = <span class="type">Flag</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">3</span>) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rawValue = rawValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Message-amp-Formatter"><a href="#Message-amp-Formatter" class="headerlink" title="Message &amp; Formatter"></a>Message &amp; Formatter</h3><p>一条日志如果只有正文部分，很难帮助定位具体的位置和发生的时间点，所以一条更加有意义的日志，会带上所在的文件、函数、行数以及时间戳等信息。</p>
<p>首先定义一个 <code>Message</code> 的数据结构来定义一条日志，这些信息最终具体如何 format 成一条字符串，需要提供一个 <code>Formatter</code> 来实现。</p>
<p>既然是 Pure-Swift，所以这里 <code>Message</code> 使用 <code>struct</code> （Value Type），而不是 <code>class</code> （Reference Type）。（<code>Codable</code>, <code>CustomStringConvertible</code>, <code>Equatable</code> 什么的暂时不需要考虑。</p>
<p>对于 <code>Formatter</code>，可能不同的 logger 需要不同的 format，比如输出到本地文件的 logger 需要更详细的信息，比如时间戳，才好帮助日后还原 app 当时运行的情况，而输出到 Xcode Console 的日志一般是在开发的时候看的，所以时间戳可能就没那么重要。（为什么 <code>Formatter</code> 使用 <code>protocol</code>？可以先想想，后面再解释。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> level: <span class="type">Level</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> flag: <span class="type">Flag</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> context: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> file: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> function: <span class="type">StaticString</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> line: <span class="type">UInt</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> timestamp: <span class="type">Date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(message: Message)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>根据日志输出的目标不同，可以划分为不同类型的 logger，比如 <code>ConsoleLogger</code>、<code>FileLogger</code> 以及 <code>WebLogger</code> 等。每一种不同的 logger 都有一些同样的接口，所以第一反应有两种不同的方式来实现类型的划分以及相同接口（行为）的约束。</p>
<p>使用面向对象的思想，通过继承来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> console</span><br><span class="line">        <span class="keyword">case</span> file</span><br><span class="line">        <span class="keyword">case</span> web</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .console</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"must override this method in subclass."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span>: <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .console</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span>: <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .file</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用面向协议的思想，通过协议来约束行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Type</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogger</span>: <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .console</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileLogger</span>: <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .file</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种不同的实现，体现的是两种不同的思想：</p>
<ul>
<li>一种是使用面向对象的思想，通过一个基类来提供相同的接口，然后子类重写这些接口来提供不同的能力；</li>
<li>另一种是使用面向协议的思想，通过一个协议来对接口进行约束，每一个具体的实现都必须实现这些接口来提供不同都能力。</li>
</ul>
<p>而对于不同类型的 logger 都共有的行为，前一种方式可以直接在基类中实现，后一种方式可以通过 <code>protocol extension</code> 来提供默认实现。</p>
<p>两种方式各有优缺点，如果你也不喜欢前一种 <strong>需要运行时才能知道子类必须重写父类的某个方法</strong>，完全不能体现出 Swift 作为一门有着强大类型安全的静态语言的优势，那么这里毫不犹豫的选择后一种方式。（不解释</p>
<p>对于这里的 <code>Type</code>，虽然使用 <code>enum</code> 有着很好的强类型信息，但这样写有着很大的约束，就是一开始就必须定义好所有的 Type，对于扩展性来说，非常不友好。</p>
<p>所以综合可扩展性和 <code>Type</code> 的作用考虑，这里通过添加一个 <code>String</code> 类型的属性 <code>name</code> 来简单的区分。（很方便于 debug</p>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>最终得到一整个 Logging 相关的接口定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> formatter: <span class="type">Formatter</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> level: <span class="type">Level</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message: Message)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flush</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unified"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flush</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>前面定义了每个不同 <code>logger</code> 的接口（行为），但是使用的时候，如果需要手动调用每个 <code>logger</code> 的 <code>log(message:)</code> 方法，那就太没有意义了。所以需要一个数据结构，来管理所有的 <code>logger</code>，并且将消息转发到每一个 <code>logger</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Logger</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.xspyhack.logger.queue"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> loggers: <span class="type">Set</span>&lt;<span class="type">AnyLogger</span>&gt; = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        loggers.forEach &#123;</span><br><span class="line">            $<span class="number">0</span>.teardown()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        loggers = []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> logger: Logging)</span></span> &#123;</span><br><span class="line">        loggers.update(with: logger)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message: Message, asynchronous: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> work = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.loggers.forEach &#123; logger <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> message.flag.rawValue &amp; logger.level.rawValue != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                logger.log(message: message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> asynchronous &#123;</span><br><span class="line">            queue.async(execute: work)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queue.sync(execute: work)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        loggers.forEach &#123;</span><br><span class="line">            $<span class="number">0</span>.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flush</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> work = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.loggers.forEach &#123; logger <span class="keyword">in</span></span><br><span class="line">                logger.flush()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.sync(execute: work)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是比较粗糙的实现，很多细节还没有处理，比如 <code>loggers</code> 的线程安全问题、以及 <code>logger</code> 的删除等等。</p>
<h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p>有了 <code>Logging</code> 来定义每一种不同作用的 <code>logger</code>，以及一个管理所有 <code>logger</code> 的管理器 <code>Logger</code>（至于这个让人懵逼的命名，实际是因为懒，取一个别的名字比较适合，比如 <del>Charmander</del>），还需要考虑最终如何简单的使用这个 Logging System。</p>
<p>现在如果要使用这个系统，首先需要实现自己的多种 <code>loggers</code> 和对应的 <code>Formatter</code>，然后添加到 <code>Logger</code> 里面，然后在需要打 log 的地方，初始化 一个 <code>Message</code>，调用 <code>Logger.shared.log(message:)</code> 方法。</p>
<p>这里每次初始化一个 <code>Message</code> 太麻烦了。如何简化？默认参数啊。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="number">_</span> message: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>, level: <span class="type">Level</span>, flag: <span class="type">Flag</span>, context: <span class="type">Int</span> = <span class="number">0</span>, file: <span class="type">String</span> = #file, function: <span class="type">StaticString</span> = #function, line: <span class="type">UInt</span> = #line, asynchronous: <span class="type">Bool</span> = <span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> message = <span class="type">Message</span>(message: message(), level: level, flag: flag, context: context, file: file, function: function, line: line, timestamp: <span class="type">Date</span>())</span><br><span class="line"></span><br><span class="line">    <span class="type">Logger</span>.shared.log(message: message, asynchronous: asynchronous)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>level</code> 和 <code>flag</code> 如果能提供默认参数，那么在调用的时候，就可以像 <code>print</code> 一样，直接只关注要 log 的内容就好了。一个比较简单直接的方法，就是针对这几种 <code>level</code> 暴露多个方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Log</span>.d(<span class="string">"This is a debug level log"</span>)</span><br><span class="line"><span class="type">Log</span>.i(<span class="string">"This is an info level log"</span>)</span><br><span class="line"><span class="type">Log</span>.w(<span class="string">"This is a warning level log"</span>)</span><br><span class="line"><span class="type">Log</span>.e(<span class="string">"This is an error level log"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个思考，上面的 <code>log</code> 函数中参数 message 的类型为什么使用 <code>@autoclosure</code>？</p>
</blockquote>
<blockquote>
<p>第二个思考，<code>Swift.print</code> 函数的定义你知道吗？</p>
</blockquote>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p><a href="https://github.com/xspyhack/Keldeo" target="_blank" rel="noopener">GitHub - xspyhack/Keldeo: A lightweight logging library written in Swift.</a></p>
<h3 id="Why-AnyLogger"><a href="#Why-AnyLogger" class="headerlink" title="Why AnyLogger"></a>Why AnyLogger</h3><p>对于引入 <code>AnyLogger</code>，是因为我希望能够提供移除一个 <code>logger</code> 的能力，用处就是当我在脱离 Xcode 的时候，可以通过一种可以输出到浏览器的 <code>logger</code> 来实时看到日志输出。而这个名为 <code>WebLogger</code> 的 <code>logger</code> 平时并不会用到，所以它是需要的时候才添加进去，用完之后便移除，所以就涉及到 <code>logger</code> 必须实现 <code>Equatable</code>，实现从 <code>loggers</code> 里面移除它。</p>
<blockquote>
<p>Why <code>protocol Logging: Equatable {}</code> needs <code>AnyLogger</code>？见另一篇 <a href="http://blessingsoft.com/2018/08/26/pats/">PATs</a></p>
</blockquote>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">GitHub - CocoaLumberjack/CocoaLumberjack: A fast &amp; simple, yet powerful &amp; flexible logging framework for Mac and iOS</a></li>
<li><a href="https://github.com/onevcat/Kingfisher/blob/master/Sources/ImageCache.swift" target="_blank" rel="noopener">Kingfisher/ImageCache.swift at master · onevcat/Kingfisher · GitHub</a></li>
<li><a href="https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/AnyHashable.swift" target="_blank" rel="noopener">swift/AnyHashable.swift at swift-3.0-branch · apple/swift · GitHub</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2018/08/26/pats/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/pats/" itemprop="url">PATs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T20:00:00+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/advanced-swift/" itemprop="url" rel="index">
                    <span itemprop="name">advanced swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>更新：随着 Swift 中一些新的提案（如 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md" target="_blank" rel="noopener">SE-0309</a> 和 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0335-existential-any.md" target="_blank" rel="noopener">SE-0335</a>）的提出，大大的简化了 Swift 中的 Protocol 的使用，文中的一些概念或者观点抑或是写法已经显得落后而不适用。–2022.01.01</p>
</blockquote>
<blockquote>
<p>很久没有写 Swift 了，闲着写几行玩玩的时候，遇到了一个之前没有接触过的问题——Protocol with Associated Types</p>
</blockquote>
<h2 id="Protocol-Oriented-Programming"><a href="#Protocol-Oriented-Programming" class="headerlink" title="Protocol-Oriented Programming"></a>Protocol-Oriented Programming</h2><p>首先 Swift 是一个 <strong>支持</strong> 面向协议编程思想的语言，并且 <a href="https://github.com/apple/swift" target="_blank" rel="noopener">Standard Library</a> 也是大量使用这种思想来实现很多的特性。（这里删掉介绍 POP 以及对应优缺点的几千字</p>
<p>先看看用 POP 的思想，来实现一个 Cache：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryCache</span>: <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Memory Cache"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DiskCache</span>: <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Disk Cache"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> memory: <span class="type">Caching</span> = <span class="type">MemoryCache</span>() <span class="comment">// 🙂️</span></span><br><span class="line"><span class="keyword">let</span> disk: <span class="type">Caching</span> = <span class="type">DiskCache</span>() <span class="comment">// 🙂️</span></span><br><span class="line"><span class="keyword">let</span> caches: [<span class="type">Caching</span>] = [memory, disk] <span class="comment">// 🙂️</span></span><br></pre></td></tr></table></figure>
<p>到这里，一切都是很熟悉的样子，也能正常的 work，类似这样的<strong>用一个 <em>protocol</em> 来进行接口（行为）约束</strong>的代码估计写的也不少。</p>
<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><blockquote>
<p>作为一个现代语言，泛型是必须支持的。作为一个现代程序员，泛型也是必须会使用的。</p>
</blockquote>
<p>Cache  是用来缓存数据的，但有很多数据类型都适合被缓存，比如一张图片，一个视频等等。如果希望不同类型的数据有不同的缓存策略，使用的时候也能直接获取某一种类型的缓存，不需要各种 <code>as? XXX</code>，立马想到的就是泛型。</p>
<p>泛型还不简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Object</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(<span class="number">_</span> object: Object, forKey key: String)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">retrieve</span><span class="params">(forKey key: String)</span></span> -&gt; <span class="type">Object?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryCache</span>: <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Object</span> = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(<span class="number">_</span> object: Object, forKey key: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">retrieve</span><span class="params">(forKey key: String)</span></span> -&gt; <span class="type">Object?</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DiskCache</span>: <span class="title">Caching</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Object</span> = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(<span class="number">_</span> object: Object, forKey key: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">retrieve</span><span class="params">(forKey key: String)</span></span> -&gt; <span class="type">Object?</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> memory: <span class="type">Caching</span> = <span class="type">MemoryCache</span>() <span class="comment">// 🙃</span></span><br><span class="line"><span class="keyword">let</span> disk: <span class="type">Caching</span> = <span class="type">DiskCache</span>() <span class="comment">// 🙃</span></span><br><span class="line"><span class="keyword">let</span> caches: [<span class="type">Caching</span>] = [memory, disk] <span class="comment">// 🙃</span></span><br></pre></td></tr></table></figure>
<p>然后 Xcode 就好很无情的提示你：</p>
<blockquote>
<p>❗️Protocol ‘Caching’ can only be used as generic constraint because it has Self or associated type requirements</p>
</blockquote>
<p>WTF?</p>
<h2 id="What-is-Protocol-with-Associated-Types"><a href="#What-is-Protocol-with-Associated-Types" class="headerlink" title="What is Protocol with Associated Types?"></a>What is Protocol with Associated Types?</h2><p>看到这个错误提示，有经验的 Swift  程序员一般会想到，<code>Caching</code> 里面关联了一个类型，如果不指定这个关联的类型的具体类型是什么，作为一门静态语言，那可能就无法知道内存是怎么布局的。</p>
<p>既然需要指定类型，马上想到的就是 <em>泛型参数</em>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache: <span class="type">Caching</span>&lt;<span class="type">UIImage</span>&gt; =  ...</span><br><span class="line"><span class="comment">// ❗️Protocol 'Caching' can only be used as generic constraint because it has Self or associated type requirements</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Caching</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ❗️Protocols do not allow generic parameters; use associated types instead</span></span><br></pre></td></tr></table></figure>
<p>WTF？</p>
<h2 id="Protocol-as-Types"><a href="#Protocol-as-Types" class="headerlink" title="Protocol as Types"></a>Protocol as Types</h2><p>突然发现自己好像一点都不了解 protocol，看看文档介绍<a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" target="_blank" rel="noopener">Protocols — The Swift Programming Language (Swift 4.2)</a>。里面 Protocol as Types 一节有一段话：</p>
<blockquote>
<p>Protocols don’t actually implement any functionality themselves. Nonetheless, any protocol you create will become a fully-fledged type for use in your code.<br>Because it’s a type, you can use a protocol in many places where other types are allowed, including:</p>
<ul>
<li>As a parameter type or return type in a function, method, or initializer</li>
<li>As the type of a constant, variable, or property</li>
<li>As the type of items in an array, dictionary, or other container</li>
</ul>
</blockquote>
<p>为什么 protocol + generic 就这么难用？应该怎么用？</p>
<h2 id="PATs-in-Swift-Standard-Library"><a href="#PATs-in-Swift-Standard-Library" class="headerlink" title="PATs in Swift Standard Library"></a>PATs in Swift Standard Library</h2><p>既然不会用，那么看看 Standard Library 里面是如何使用的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The type of element traversed by the iterator.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// - Returns: The next element in the underlying sequence, if a next element</span></span><br><span class="line">    <span class="comment">///   exists; otherwise, `nil`.</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// A type representing the sequence's elements.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A type that provides the sequence's iteration interface and</span></span><br><span class="line">    <span class="comment">/// encapsulates its iteration state.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span> : <span class="type">IteratorProtocol</span> <span class="keyword">where</span> <span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns an iterator over the elements of this sequence.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后又发现有一个叫 <code>AnyIterator</code> 和 <code>AnySequence</code> 的东西。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AnyIterator</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> _box: _AnyIteratorBoxBase&lt;<span class="type">Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">I</span> : <span class="type">IteratorProtocol</span>&gt;(<span class="number">_</span> base: <span class="type">I</span>) <span class="keyword">where</span> <span class="type">I</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _IteratorBox(base)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> body: @escaping () -&gt; <span class="type">Element?</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _IteratorBox(_ClosureBasedIterator(body))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(_box: _AnyIteratorBoxBase&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _box</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AnyIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _box.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AnySequence</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> _box: _AnySequenceBox&lt;<span class="type">Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">I</span> : <span class="type">IteratorProtocol</span>&gt;(<span class="number">_</span> makeUnderlyingIterator: @escaping () -&gt; <span class="type">I</span>) <span class="keyword">where</span> <span class="type">I</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(_ClosureBasedSequence(makeUnderlyingIterator))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(_box: _AnySequenceBox&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _box</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AnySequence</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Iterator</span> = <span class="type">AnyIterator</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">S</span> : <span class="type">Sequence</span>&gt;(<span class="number">_</span> base: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _SequenceBox(_base: base)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是什么鬼，先看看文档：</p>
<blockquote>
<p>This iterator forwards its next() method to an arbitrary underlying iterator having the same Element type, hiding the specifics of the underlying IteratorProtocol. —<a href="https://developer.apple.com/documentation/swift/anyiterator" target="_blank" rel="noopener">AnyIterator - Swift Standard Library | Apple Developer Documentation</a></p>
</blockquote>
<blockquote>
<p>An instance of AnySequence forwards its operations to an underlying base sequence having the same Element type, hiding the specifics of the underlying sequence. —<a href="https://developer.apple.com/documentation/swift/anysequence" target="_blank" rel="noopener">AnySequence - Swift Standard Library | Apple Developer Documentation</a></p>
</blockquote>
<p>说白了就是包装一层，转发一下，它有个术语叫做 <strong>Type Erasure</strong></p>
<h2 id="What-is-Type-Erasure"><a href="#What-is-Type-Erasure" class="headerlink" title="What is Type Erasure?"></a>What is Type Erasure?</h2><p>首先 Swift 的类型系统里面，有两种类型：</p>
<ul>
<li>Concrete Type: Int, Bool…</li>
<li>Abstract Type: associatedType, <t></t></li>
</ul>
<p>对于抽象类型来说，编译器无法知道这个类型的确切功能。当编译器处理抽象类型的时候，它无法知晓其所占的空间大小；甚至可能会认为这个类型是不存在的。Swift 是静态语言。</p>
<blockquote>
<p>Type erasure is a process in code that makes abstract types concrete.</p>
</blockquote>
<p>具体看看 Swift Standard Library 里面，是怎么做到的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. abstract base</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">_AnyIteratorBoxBase</span>&lt;<span class="title">Element</span>&gt; : <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123; _abstract() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. private box</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_IteratorBox</span>&lt;<span class="title">Base</span> : <span class="title">IteratorProtocol</span>&gt; : <span class="title">_AnyIteratorBoxBase</span>&lt;<span class="title">Base</span>.<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123; <span class="keyword">self</span>._base = base &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Base</span>.<span class="type">Element?</span> &#123; <span class="keyword">return</span> _base.next() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _base: <span class="type">Base</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. public wrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AnyIterator</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> _box: _AnyIteratorBoxBase&lt;<span class="type">Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">I</span> : <span class="type">IteratorProtocol</span>&gt;(<span class="number">_</span> base: <span class="type">I</span>) <span class="keyword">where</span> <span class="type">I</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _IteratorBox(base)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> body: @escaping () -&gt; <span class="type">Element?</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _IteratorBox(_ClosureBasedIterator(body))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(_box: _AnyIteratorBoxBase&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>._box = _box</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模式概括起来就是三个步骤：</p>
<ul>
<li>an abstract base class</li>
<li>a private box class</li>
<li>a public wrapper class</li>
</ul>
<p>（想了解更多相关的理论知识？<em>Existential</em> 了解一下</p>
<h2 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h2><p>到这里，我以为我已经掌握了如何用 PATs 了，然后有一天，我开始写一个轻量级的日志系统。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Logging</span>: <span class="title">Hashtable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> loggers: <span class="type">Set</span>&lt;<span class="type">Logging</span>&gt; = []</span><br><span class="line"><span class="comment">// ❗️Using 'Logging' as a concrete type conforming to protocol 'Hashable' is no supported</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> logger: Logging)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ❗️Protocol 'Logging' can only be used as generic constraint because it has Self or associated type requirements</span></span><br></pre></td></tr></table></figure>
<p>看到这熟悉的错误，马上就想到 <code>Hashable</code> 其实是继承 <code>Equatable</code> 的，然后这个 <code>Equatable</code> 的几个方法里面，用了 <code>Self</code> 来占位，它其实也是 PATs 的一种。意不意外，惊不惊喜。（其实一点都不意外</p>
<p>然后就是 type erasure 了，真正根据上面的三个步骤来写的时候，发现好像跟之前的又有点不太一样，因为它没有关联别的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. abstract baes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnyLoggerBoxBase</span>&lt;<span class="title">T</span>&gt; : <span class="title">Logging</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. private box</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoggerBox</span>&lt;<span class="title">Base</span> : <span class="title">Logging</span>&gt; : <span class="title">_AnyLoggerBoxBase</span> &lt;<span class="title">Base</span>.<span class="title">Self</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. public wrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnyLogger</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">L</span> : <span class="type">Logging</span>&gt;(<span class="number">_</span> base: <span class="type">L</span>) <span class="keyword">where</span> <span class="type">L</span>.<span class="type">Self</span> == <span class="type">Self</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三步里面的泛型参数像是多出来的，根本无从下手。</p>
<blockquote>
<p>遇到不懂，首先看源码总是不会有错。— 圣人</p>
</blockquote>
<p>了解 Swift 的都知道，有一个叫做 <code>AnyHashable</code> 的东西。（一顿抄，完事</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://www.youtube.com/watch?v=XWoNjiSPqI8&amp;t=2391s" target="_blank" rel="noopener">Alexis Gallagher - Protocols with Associated Types - YouTube</a></li>
<li><a href="https://academy.realm.io/posts/tryswift-gwendolyn-weston-type-erasure/" target="_blank" rel="noopener">Keep Calm and Type Erase On</a></li>
<li><a href="https://developer.apple.com/documentation/swift/anysequence" target="_blank" rel="noopener">AnySequence - Swift Standard Library | Apple Developer Documentation</a></li>
<li><a href="https://github.com/apple/swift/blob/master/stdlib/public/core/ExistentialCollection.swift.gyb" target="_blank" rel="noopener">swift/ExistentialCollection.swift.gyb at master · apple/swift · GitHub</a></li>
<li><a href="https://github.com/apple/swift/blob/master/stdlib/public/core/AnyHashable.swift" target="_blank" rel="noopener">swift/AnyHashable.swift at master · apple/swift · GitHub</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/08/10/plist-parser/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/plist-parser/" itemprop="url">Plist Parser</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T20:00:00+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Plist 是 Apple 家平台上一种很常见的配置文件，常见的存储格式是常见的 XML 格式（还有 Binary 格式），不同于 HTML 的复杂，Plist 只包含了比较少的几种标签（tag），所以实现使用 functional 的 parser combinator 来实现一个简单的 plist parser 也是一件很有意思的事情。</p>
<h2 id="Plist"><a href="#Plist" class="headerlink" title="Plist"></a>Plist</h2><p>一个 Plist 文件内容长这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;number&lt;/key&gt;</span><br><span class="line">    &lt;integer&gt;0&lt;/integer&gt;</span><br><span class="line">    &lt;key&gt;date&lt;/key&gt;</span><br><span class="line">    &lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;</span><br><span class="line">    &lt;key&gt;data&lt;/key&gt;</span><br><span class="line">    &lt;data&gt;VGVzdFZhbHVl&lt;/data&gt;</span><br><span class="line">    &lt;key&gt;boolean&lt;/key&gt;</span><br><span class="line">    &lt;true/&gt;</span><br><span class="line">    &lt;key&gt;array&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;string&gt;string&lt;/string&gt;</span><br><span class="line">        &lt;false/&gt;</span><br><span class="line">        &lt;integer&gt;0&lt;/integer&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line"> &lt;/dict&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://zh.wikipedia.org/zh-hans/属性列表" target="_blank" rel="noopener">wikipedia</a> 上列出了一个详细的 <code>XML</code> 标签和 macOS/iOS 中的类型关系以及存储格式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Foundation 类</th>
<th style="text-align:left">Core Foundation 类型</th>
<th style="text-align:left">XML 标签</th>
<th style="text-align:left">储存格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NSString</td>
<td style="text-align:left">CFString</td>
<td style="text-align:left">&lt;string&gt;</td>
<td style="text-align:left">UTF-8 编码的字符串</td>
</tr>
<tr>
<td style="text-align:left">NSNumber</td>
<td style="text-align:left">CFNumber</td>
<td style="text-align:left">&lt;real&gt;, &lt;integer&gt;</td>
<td style="text-align:left">十进制数字符串</td>
</tr>
<tr>
<td style="text-align:left">NSNumber</td>
<td style="text-align:left">CFBoolean</td>
<td style="text-align:left">&lt;true/&gt;, or &lt;false/&gt;</td>
<td style="text-align:left">无数据（只有标签）</td>
</tr>
<tr>
<td style="text-align:left">NSDate</td>
<td style="text-align:left">CFDate</td>
<td style="text-align:left">&lt;date&gt;</td>
<td style="text-align:left">ISO 8601 格式的日期字符串</td>
</tr>
<tr>
<td style="text-align:left">NSData</td>
<td style="text-align:left">CFData</td>
<td style="text-align:left">&lt;data&gt;</td>
<td style="text-align:left">Base64 编码的数据</td>
</tr>
<tr>
<td style="text-align:left">NSArray</td>
<td style="text-align:left">CFArray</td>
<td style="text-align:left">&lt;array&gt;</td>
<td style="text-align:left">可以包含任意数量的子元素</td>
</tr>
<tr>
<td style="text-align:left">NSDictionary</td>
<td style="text-align:left">CFDictionary</td>
<td style="text-align:left">&lt;dict&gt;</td>
<td style="text-align:left">交替包含 &lt;key&gt; 标签和 plist 元素标签</td>
</tr>
</tbody>
</table>
<p>根据这个表格，我们可以定义出 Plist 的数据结构。</p>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The plist data model</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PLIST</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// &lt;true/&gt; or &lt;false/&gt;</span></span><br><span class="line">    <span class="keyword">case</span> bool(<span class="type">Bool</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 2017-08-05T14:25:14Z</span></span><br><span class="line">    <span class="keyword">case</span> date(<span class="type">Date</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;data&gt;VGVzdFZhbHVl&lt;/data&gt; (&lt;54657374 56616c75 65&gt;</span></span><br><span class="line">    <span class="keyword">case</span> data(<span class="type">Data</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;integer&gt;233&lt;/integer&gt; or &lt;real&gt;2.33&lt;/real&gt;</span></span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;string&gt;string&lt;/string&gt;</span></span><br><span class="line">    <span class="keyword">case</span> string(<span class="type">String</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;array&gt;&lt;string&gt;The String&lt;/string&gt;&lt;/array&gt;</span></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> array([<span class="type">PLIST</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// &lt;dict&gt;&lt;key&gt;The Key&lt;/key&gt;&lt;string&gt;The String&lt;/string&gt;&lt;/dict&gt;</span></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> dict([<span class="type">String</span>: <span class="type">PLIST</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>根据 Plist data model，想要解析一个 Plist 字符串 得到 <code>PLIST</code> 类型，只需要一个 <code>parser</code>。</p>
<p>没错，只需要一个 parser，这个 parser 大概长这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parser: <span class="type">Parser</span>&lt;<span class="type">PLIST</span>&gt;</span><br><span class="line"><span class="keyword">let</span> result = parser.parse(<span class="string">"plist"</span>)</span><br></pre></td></tr></table></figure>
<p>这个 <code>let parser: Parser&lt;PLIST&gt;</code> 的实现才是最关键的。一个 <code>PLIST</code> 是由 <code>Bool</code> <code>Date</code> <code>Data</code> <code>Number</code> <code>String</code> 5 种简单的类型和 <code>Array&lt;PLIST&gt;</code> <code>Dictionary&lt;PLIST&gt;</code> 2 种容器（nested）类型组成，所以一个 <code>Parser&lt;PLIST&gt;</code> 也是由对应的 <code>Parser&lt;Bool&gt;</code> <code>Parser&lt;Date&gt;</code> <code>Parser&lt;Data&gt;</code> <code>Parser&lt;Number&gt;</code> <code>Parser&lt;String&gt;</code> 5 中简单的 parser 和 <code>Parser&lt;Array&gt;</code> <code>Parser&lt;Dictionary&gt;</code> 2 种容器类型 parser 组成。</p>
<h3 id="Bool-Parser"><a href="#Bool-Parser" class="headerlink" title="Bool Parser"></a>Bool Parser</h3><p>在 Plist 中，Bool 类型由两种形式 <code>&lt;true/&gt;</code> 和 <code>&lt;false/&gt;</code>，所以一个 Bool 类型的 parser 也就是能够解析字符串 <code>&lt;true/&gt;</code> 和 <code>&lt;false/&gt;</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _true = string(<span class="string">"&lt;true/&gt;"</span>) &lt;&amp;&gt; const(<span class="type">PLIST</span>.bool(<span class="literal">true</span>))</span><br><span class="line"><span class="keyword">let</span> _false = string(<span class="string">"&lt;false/&gt;"</span>) &lt;&amp;&gt; const(<span class="type">PLIST</span>.bool(<span class="literal">false</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _bool = _true &lt;|&gt; _false</span><br><span class="line">_bool.parse(<span class="string">"&lt;false/&gt;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Date-Parser"><a href="#Date-Parser" class="headerlink" title="Date Parser"></a>Date Parser</h3><p>Plist 中的 Date 类型存储的是 UTC 字符串，如 <code>&lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;</code>。字符串中的开始标签 <code>&lt;date&gt;</code> 和结束标签 <code>&lt;/date&gt;</code> 对于解析的结果来说是没有用的，所以一个 Date 类型的 parser 是要将这个字符串解析成 <code>PLIST.date(date)</code>, date 为 2017-08-05T14:25:14Z 通过 format 得到。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _date = string(<span class="string">"&lt;date&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/date&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.date(<span class="type">String</span>($<span class="number">0</span>).date!) &#125;</span><br><span class="line">_date.parse(<span class="string">"&lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// UTC Date</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> date: <span class="type">Date?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        formatter.dateFormat = <span class="string">"yyyy-MM-dd'T'HH:mm:ss'Z'"</span></span><br><span class="line">        <span class="keyword">return</span> formatter.date(from: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-Parser"><a href="#Data-Parser" class="headerlink" title="Data Parser"></a>Data Parser</h3><p>Plist 中的 Data 类型存储的是 Base64 编码后的数据，所以实现一个 Data Parser 和 Date Parser 差不多，区别是 tag 和 Data 类型初始化。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _data = string(<span class="string">"&lt;data&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/data&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.data(<span class="type">Data</span>(base64Encoded: <span class="type">String</span>($<span class="number">0</span>))!) &#125;</span><br><span class="line"><span class="keyword">let</span> dataString = _data.parse(<span class="string">"&lt;data&gt;VGVzdFZhbHVl&lt;/data&gt;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Number-Parser"><a href="#Number-Parser" class="headerlink" title="Number Parser"></a>Number Parser</h3><p>Plist 中的 Number 的存储实际上分两种。一种是整型，一种是浮点型。整型的 <code>tag</code> 是 <code>integer</code>，浮点型是 <code>real</code>。</p>
<p>先看 Integer Parser：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _integer = string(<span class="string">"&lt;integer&gt;"</span>) *&gt; manyTill(_digit, string(<span class="string">"&lt;/integer&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.number(<span class="type">Int</span>(<span class="type">String</span>($<span class="number">0</span>))!) &#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-Parser"><a href="#String-Parser" class="headerlink" title="String Parser"></a>String Parser</h3><p>String Parser 和 Date Parser 以及 Data Parser 对比起来更简单，实际上就是去掉了最后转换的那一步。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _string = string(<span class="string">"&lt;string&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/string&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.string(<span class="type">String</span>($<span class="number">0</span>)) &#125;</span><br><span class="line">_string.parse(<span class="string">"&lt;string&gt;The String&lt;/string&gt;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Tag-Parser"><a href="#Tag-Parser" class="headerlink" title="Tag Parser"></a>Tag Parser</h3><p>通过对比上面几种除了 Bool Parser 之外不同类型的 Parser，可以发现实现的方式很相似。</p>
<ul>
<li>closed tag，成对存在。</li>
<li>中间存储的都是字符串，最后把字符串转为具体类型。</li>
</ul>
<p>把这些相似的 Parser 进行抽象，将相同部分封装成一个函数，不同的部分用传参的形式来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tag</span>&lt;A&gt;<span class="params">(<span class="number">_</span> tag: String, <span class="number">_</span> p: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> string(<span class="string">"&lt;\(tag)&gt;"</span>) *&gt; manyTill(p, string(<span class="string">"&lt;/\(tag)&gt;"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _date1 = tag(<span class="string">"&lt;date&gt;"</span>, _any) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.date(<span class="type">String</span>($<span class="number">0</span>).date!) &#125;</span><br><span class="line">_date1.parse(<span class="string">"&lt;date&gt;2017-08-05T14:25:14Z&lt;/date&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _string1 = tag(<span class="string">"string"</span>, _any) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.string(<span class="type">String</span>($<span class="number">0</span>)) &#125;</span><br><span class="line">_string1.parse(<span class="string">"&lt;string&gt;The String&lt;/string&gt;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Array-Parser"><a href="#Array-Parser" class="headerlink" title="Array Parser"></a>Array Parser</h3><p>Array Parser 和 Dictionary Parser 相对比较复杂，因为它们是容器类型，里面可以是任意的 PLIST 类型，包括它们本身。对于 Enum PLIST 来说，可以使用 <code>indirect</code> 关键字来表示这种情况，但是在定义 parser 的时候，确没有这些魔法。</p>
<p>但是通过利用 Swift 的一些特性，还是很容易解决这个递归的问题。先忽略 Dictionary 类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _plist = plist()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plist</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">PLIST</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> _bool &lt;|&gt; _string &lt;|&gt; _integer &lt;|&gt; _date &lt;|&gt; _data &lt;|&gt; _array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _array = tag(<span class="string">"array"</span>, _plist) &lt;&amp;&gt; &#123;</span><br><span class="line">    <span class="type">PLIST</span>.array($<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dictionary-Parser"><a href="#Dictionary-Parser" class="headerlink" title="Dictionary Parser"></a>Dictionary Parser</h3><p>Dictionary Parser 的递归问题和 Array Parser 一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _plist = plist()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plist</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">PLIST</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> _bool &lt;|&gt; _string &lt;|&gt; _integer &lt;|&gt; _date &lt;|&gt; _data &lt;|&gt; _array &lt;|&gt; _dict</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _dict = tag(<span class="string">"dict"</span>, ?) &lt;&amp;&gt; &#123;</span><br><span class="line">   <span class="comment">/// 转换为 PLIST.dict</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 Dictionary 和 Array 不一样的地方在于，Array 里面是多个 Plist 的元素，而 Dictionary 是 key-value 对，且必须是 key-value 对，也就是 <code>tag(&quot;dict&quot;, _keyValue)</code>。</p>
<p>先实现一个 Key-Value Parser：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _key = string(<span class="string">"&lt;key&gt;"</span>) *&gt; manyTill(_any, string(<span class="string">"&lt;/key&gt;"</span>)) &lt;&amp;&gt; &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> _keyValue = (&#123; a <span class="keyword">in</span> &#123; b <span class="keyword">in</span> (a, b) &#125;&#125; &lt;^&gt; _key &lt;*&gt; (value))</span><br></pre></td></tr></table></figure>
<p>然后就可以得到 Dictionary Parser：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _dict = tag(<span class="string">"dict"</span>, _keyValue) &lt;&amp;&gt; &#123; <span class="type">PLIST</span>.dict(atod($<span class="number">0</span>)) &#125;</span><br><span class="line"><span class="comment">/// Tuple Array to Dictionary</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">atod</span>&lt;Key: Hashable, Value&gt;<span class="params">(<span class="number">_</span> tuples: [<span class="params">(Key, Value)</span></span></span>]) -&gt; [<span class="type">Key</span>: <span class="type">Value</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> dict: [<span class="type">Key</span>: <span class="type">Value</span>] = [:]</span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> tuples &#123;</span><br><span class="line">        dict[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dict</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者换一种写法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _kv = _keyValue &lt;&amp;&gt; &#123; ttod($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _dict1 = tag(<span class="string">"dict"</span>, _kv) &lt;&amp;&gt; &#123;</span><br><span class="line">    <span class="type">PLIST</span>.dict(</span><br><span class="line">    		$<span class="number">0</span>.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line">        .<span class="built_in">reduce</span>([<span class="type">String</span>: <span class="type">PLIST</span>]()) &#123; d, kv <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> dict = d</span><br><span class="line">            dict.updateValue(kv.value, forKey: kv.key)</span><br><span class="line">            <span class="keyword">return</span> dict</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">ttod</span>&lt;Key: Hashable, Value&gt;<span class="params">(<span class="number">_</span> tuple: <span class="params">(Key, Value)</span></span></span>) -&gt; [<span class="type">Key</span>: <span class="type">Value</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple.<span class="number">0</span>: tuple.<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Plist-Parser"><a href="#Plist-Parser" class="headerlink" title="Plist Parser"></a>Plist Parser</h3><p>最后</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _plist = _bool &lt;|&gt; _string &lt;|&gt; _integer &lt;|&gt; _date &lt;|&gt; _data &lt;|&gt; _array &lt;|&gt; _dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = _plist.parse(plist)</span><br><span class="line"><span class="built_in">dump</span>(result)</span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zh.wikipedia.org/zh-hans/属性列表" target="_blank" rel="noopener">属性列表</a><br><a href="http://blessingsoft.com/2017/05/28/parser-combinator/">Parser Combinator</a><br><a href="https://github.com/nixzhu/dev-blog/blob/master/2017-04-12-json-parser.md" target="_blank" rel="noopener">解析组合子</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/12/group-theory-and-category-theory/" itemprop="url">Group Theory and Category Theory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T20:00:00+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想理解函数式编程中的一些高大上的概念，比如 Functor, Monad 等，必须要先理解范畴论。</p>
<h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><blockquote>
<p>群，是一种代数结构，由一个集合（G）以及一个二元运算符（·）所组成。<a href="https://zh.wikipedia.org/wiki/群" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>
<p>一个群必须满足一些称为 <em>群公理</em> 的条件，也就是 <strong>封闭性</strong>、<strong>结合律</strong>、<strong>单位元</strong> 和 <strong>逆元</strong>。如整数配备上加法运算就形成一个群。</p>
<ul>
<li>封闭性（Closure）：对于任意 a,b∈G，a·b∈G。</li>
<li>结合律（Associativity）：对于任意 a,b,c∈G，(a·b)·c = a·(b·c)。</li>
<li>单位元（Identity）：G 中存在一个元素 e，使得任意 a∈G，a·e = e·a = a。</li>
<li>逆元：对于任意 a∈G，存在 b∈G，使得 a·b = b·a = e。</li>
</ul>
<p>群并不要求这个二元运算符（·）具体做什么，它只要求这个二元运算符存在，所以很多数学结构都是群。比如我们可以把整数当作一个群，把 <code>+</code> 作为二元运算符。</p>
<ul>
<li>封闭性：对于任意两个整数 a,b，a+b 依然是一个整数。</li>
<li>结合律：对于任意整数 a,b,c，(a+b)+c = a+(b+c)。</li>
<li>单位元：存在元素 0，使得 a+0 = 0+a = a。</li>
<li>逆元：对于任意整数 a，当 b=-a 时，a+b = b+a = e。</li>
</ul>
<p>所以我们可以说 <code>(整数, +)</code> 是一个群。如果把 <code>*</code> 当作二元运算符，把 <code>1</code> 作为单位元的时候，整数就形成了另一个群。</p>
<p>除了整数，还有很多数学结构是群。</p>
<h3 id="Semigroup"><a href="#Semigroup" class="headerlink" title="Semigroup"></a>Semigroup</h3><p>满足封闭性和结合律的群，称为半群（semigroup）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;&gt;: <span class="type">AdditionPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Semigroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Semigroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs + rhs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Semigroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;&gt;<span class="params">(lhs: Array, rhs: Array)</span></span> -&gt; <span class="type">Array</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs + rhs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折叠 fold</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;S: Semigroup&gt;<span class="params">(<span class="number">_</span> xs: [S], <span class="number">_</span> initial: S)</span></span> -&gt; <span class="type">S</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(initial, &lt;&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>半群的结合律特性使得我们可以进行并行运算，<code>1 &lt;&gt; 2 &lt;&gt; 3 &lt;&gt; 4</code>。</p>
<h3 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h3><p>在抽象代数中，有一类简单的抽象结构被称为 Monoid（幺半群）。许多数学结构都是幺半群，因为成为幺半群的要求非常低。</p>
<p>存在单位元的半群，称为含幺半群，或者幺半群，或者单群，或者独异点（monoid）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Monoid</span>: <span class="title">Semigroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Monoid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Monoid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> e: <span class="type">Array</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span>&lt;M: Monoid&gt;<span class="params">(<span class="number">_</span> xs: [M])</span></span> -&gt; <span class="type">M</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(<span class="type">M</span>.e, &lt;&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>concat</code> 是对 Monoid 的一种应用，它可以利用 Monoid 的定义（ 二元操作 <code>&lt;&gt;</code> 和 单位元 <code>e</code> ）进行折叠操作。</p>
<h2 id="Category-Theory"><a href="#Category-Theory" class="headerlink" title="Category Theory"></a>Category Theory</h2><blockquote>
<p>范畴论是数学的一门学科，以抽象的方法来处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。<a href="https://zh.wikipedia.org/wiki/范畴论" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>一个范畴 C 包括：</p>
<ul>
<li>一个由对象（object）组成的类 ob(C)。（注：这里把“物件”成为“对象“更有助于从计算机的角度理解</li>
<li>对象间态射（morphism，-&gt;）组成的类 hom(C)：每个态射 f 都只有一个「源对象」a 以及一个「目标对象」b（其中 a,b 都在 ob(C) 内），称之为 <strong>从 a 到 b 的态射</strong>，记为 f: a-&gt;b。（注：identity 态射即自己映射到自己的特殊态射，f: a-&gt;a，简单记为 id[a]）</li>
<li>一个二元运算符（·），用于态射组合，如 h=g·f。</li>
</ul>
<p>满足公理：</p>
<ul>
<li>结合律：f: a-&gt;b, g: b-&gt;c, h: c-&gt;d，h·(g·f) = (h·g)·f。</li>
<li>单位元：id[a]·f = id[b]·f = f。</li>
<li>封闭性：f: a-&gt;b, g: b-&gt;c, h: a-&gt;c, h = f·g。</li>
</ul>
<p>范畴举例：</p>
<ul>
<li>范畴 C 有 Int 类型和 String 类型对象。</li>
<li>存在态射 f: Int-&gt;String。</li>
</ul>
<p>划重点：幺半群可以视为一类特殊的范畴。幺半群运算满足的公理同于范畴中 <strong>从一个对象到自身的态射</strong>。换言之：<br>幺半群实质上是只有单个对象的范畴。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><blockquote>
<p>在范畴论中，函子是范畴间的一类映射。函子也可以解释为小范畴为成员的范畴内的态射。 <a href="https://zh.wikipedia.org/wiki/函子" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>
<p>在当代数学中，函子被用来描述各种范畴间的关系。对范畴论者来说，函子则是个特别类型的函数。</p>
<p>设 C 和 D 为范畴，从 C 至 D 的函子为一映射 F:</p>
<ul>
<li>将每个对象 x∈C 映射至一对象 F(x)∈D 上。</li>
<li>将每个态射 f: x-&gt;y∈C 映射至一态射 F(f): F(x)-&gt;F(y)∈D 上，</li>
</ul>
<p>使之满足：</p>
<ul>
<li>对任何对象 x∈C，恒有 F(id[x]) = id[F(x)]。</li>
<li>对任何态射 f: x-&gt;y, g: y-&gt;z，恒有 F(f·g) = F(f)·F(g)。</li>
</ul>
<p>换言之，函子会保持单位态射与态射的复合。<br>一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
<h4 id="可以把范畴当作一组类型的集合"><a href="#可以把范畴当作一组类型的集合" class="headerlink" title="可以把范畴当作一组类型的集合"></a>可以把范畴当作一组类型的集合</h4><p>如范畴 C 有 <code>Int</code> 类型和 <code>String</code> 类型对象，以及 <code>Int -&gt; String</code> 的态射；范畴 D 有 <code>Array&lt;Int&gt;</code> 类型和 <code>Array&lt;String&gt;</code> 类型对象，以及 <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code> 的态射。两个范畴之间的映射 F：</p>
<ul>
<li><code>Int</code> 映射至 <code>Array&lt;Int&gt;</code> 上，<code>String</code> 映射至 <code>Array&lt;String&gt;</code> 上。</li>
<li>态射 <code>Int -&gt; String</code> 映射至 <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code> 上。</li>
</ul>
<p>翻译成代码：C: <code>Int</code>, <code>String</code>, f: <code>Int -&gt; String</code>, D: <code>Array&lt;Int&gt;</code>, <code>Array&lt;String&gt;</code>, f: <code>Array&lt;Int&gt; -&gt; Array&lt;String&gt;</code>。</p>
<ul>
<li>x: <code>Int</code> -&gt; F(x): <code>Array&lt;Int&gt;</code>，<code>String</code> -&gt; F(x): <code>Array&lt;String&gt;</code></li>
<li>f: <code>(Int -&gt; String)</code> -&gt; F(f): <code>(Array&lt;Int&gt; -&gt; Array&lt;String&gt;)</code></li>
</ul>
<p>范畴是不涉及具体类型的，所以用泛型表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tmap</span>&lt;T&gt;<span class="params">(x: T)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmap</span>&lt;A, B&gt;<span class="params">(f: A -&gt; B)</span></span> -&gt; (<span class="type">F</span>&lt;<span class="type">A</span>&gt; -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>简化一下变成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 中把 Int 映射到 Array&lt;Int&gt; 由 Array 的初始化方法提供，</span></span><br><span class="line"><span class="comment">// 所以可以不写。</span></span><br><span class="line"><span class="comment">// 由于 fmap 实际上是 (F&lt;A&gt;, A -&gt; B) -&gt; F&lt;B&gt; 的 currying 版本，</span></span><br><span class="line"><span class="comment">// 所以两者是等价的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;, f: A -&gt; B)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</span><br></pre></td></tr></table></figure>
<p>再来看看 Swift 中的 <code>Array</code> 和 <code>Optional</code>。如果把 Swift 中所有的类型 <code>A, B</code> 当作对象，以及 Swift 中所有的函数当作态射 <code>A -&gt; B</code>，那么这些类型和函数就组成一个范畴 A。把 <code>Array</code> 类型当作对象 <code>Array&lt;A&gt;, Array&lt;B&gt;</code>，<code>Array</code> 上所有的函数当作态射 <code>Array&lt;A&gt; -&gt; Array&lt;B&gt;</code>，那么也组成一个范畴 B。而 A 到 B 之间的函子是 <code>Array</code>，因为函子 <code>Array</code> 能将任意类型 <code>T</code> 转换为 <code>Array&lt;T&gt;</code>。<code>Optional</code> 同理。</p>
<p>很多库对 <code>Functor</code> 的支持直接在类型构造器（Type Constructor）的定义中实现 <code>map</code> 方法，比如 Swift 中的 <code>Array</code> 和 <code>Optional</code> 就是需要一个泛型作为参数来构建具体类型的类型构造器，它在定义中实现了 <code>map</code> 方法。这些类型构造器相当于同时具备了类型和函数的映射。在 Haskell 里把这个行为称为 <code>Lift</code>，相当于把类型和函数放到容器里面。所以一个带有 <code>map</code> 方法的类型构造器就是一个函子。</p>
<p>范畴与高阶类型：如果忽略范畴中的态射，范畴其实就是对特定类型的抽象，即高阶类型（类型构造器）。对于范畴 D，它的所有类型都是 <code>Array&lt;T&gt;</code> 的特定类型。而对于范畴 C，可以看作是一个 Identity 类型的构造器（id[T] = T）。</p>
<p>注意⚠️：函子不是容器，函子不是容器，函子不是容器。<br>如 <code>typealias Parser&lt;A&gt; = (String) -&gt; (A, String)?</code> 我们可以实现 <code>func map&lt;A, B&gt;(x: Parser&lt;A&gt;, f: (A) -&gt; B) -&gt; Parser&lt;B&gt;</code> 函数，所以我们可以说 <code>Parser&lt;A&gt;</code> 是一个函子，但它不是容器。</p>
<h3 id="Endofunctor"><a href="#Endofunctor" class="headerlink" title="Endofunctor"></a>Endofunctor</h3><blockquote>
<p>A functor that maps a category to itself。一个由一范畴映射至其自身的函子称之为 <strong>自函子（Endofunctor）</strong>。</p>
</blockquote>
<p>先看自函数的概念：将一个类型映射到自身类型，如 <code>Int -&gt; Int</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>单位函数（Identity Function）的概念：什么都不做，传入什么就返回什么。属于自函数的特例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">id</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x &#125;</span><br></pre></td></tr></table></figure>
<p><strong>自函子不是单位函子（Identity Functor）</strong>。还是上面的范畴 C，为了区分自函子和单位函子，多加一种态射 g: <code>String -&gt; Int</code>，那么：</p>
<p>自函子：对于函子 F，对于 <code>F(Int)</code> 结果是 <code>String</code>，<code>F(String)</code> 结果是 <code>Int</code>，对于 <code>F(f: Int -&gt; String)</code> 结果是 g: <code>String -&gt; Int</code>。那么这个函子就是自函子。</p>
<p>单位函子（Identity Functor）：对于函子 F，对于 <code>F(Int)</code> 结果还是 <code>Int</code>，对于 <code>F(String)</code> 结果还是 <code>String</code>，对于 <code>F(f: Int -&gt; String)</code> 结果还是 <code>f: Int -&gt; String</code>，对于 <code>F(g: String -&gt; Int)</code> 结果还是 g: <code>String -&gt; Int</code>。那么这个函子就是单位函子。 </p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><blockquote>
<p>An applicative is a monoid in the category of endofunctors, what’s the problem?</p>
</blockquote>
<p>虽然在 Haskell 中 Monad 是 Applicative 的一种，但是 Applicative 的出现却在 Monad 之后。</p>
<p><a href="https://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/" target="_blank" rel="noopener">Applicative</a></p>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><blockquote>
<p>A monad is a monoid in the category of endofunctors – Philip Wadler</p>
</blockquote>
<p>自函子说穿了就是把一个范畴映射到自身的函子，自函子范畴说穿了就是从小范畴映射到自身的函子所构成的以自函子为对象以自然变换为态射的范畴，幺半群说穿了就是只有单个对象的范畴，给定了一个幺半群则可构造出一个仅有单个对象的小范畴使其态射由幺半群的元素给出而合成由幺半群的运算给出，而单子说穿了就是自函子范畴上的这样一个幺半群。（这都不理解么亲连这种最基本的概念都不理解还学什么编程！</p>
<p>一系列 Endofunctor 组成的范畴，成为 <strong>自函子范畴</strong>。</p>
<ul>
<li>X 上的自函子：F：<code>X -&gt; X</code></li>
<li>单位自函子 id[X] 到函子 F 的自然转换：<code>id[X] -&gt; F</code> (pure</li>
<li>函子 F 的张量积 F⊗F 到函子 F 的自然转换：<code>F⊗F -&gt; F</code> (join</li>
</ul>
<p>代码表示：</p>
<ul>
<li><code>func unit&lt;T&gt;(x: T) -&gt; F&lt;T&gt; // x = id[x]</code> </li>
<li><code>func join&lt;T&gt;(a: F&lt;F&lt;T&gt;&gt;) -&gt; F&lt;T&gt;</code></li>
</ul>
<p>此处函子的张量积 ⊗ 可以看作为组合（Composition）；<br>注意结合 Monoidal Category 理解，<code>unit</code> 和 <code>join</code> 满足 Monoid 的定律，所有形成了 Monoid。</p>
<p>也就是说：单子（Monad）是自函子的 Monoidal 范畴上的一个幺半群，该 Monoidal 范畴的张量积（Tensor Product，⊗：F×F -&gt; F）是自函子的复合（Composition），单位元是 Id Functor。</p>
<p><code>bind</code> 或者说 <code>flatMap</code> 或者 <code>&gt;&gt;=</code> 其实等于 <code>map + join</code>。（见 <a href="https://github.com/apple/swift" target="_blank" rel="noopener">apple/swift</a> 中的 <code>stdlib/public/core/FlatMap.swift</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;=&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;, f: A -&gt; F&lt;B&gt;)</span></span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</span><br><span class="line"><span class="comment">// Currying 前的样子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;=&lt;A, B&gt;<span class="params">(x: F&lt;A&gt;)</span></span> -&gt; (f: <span class="type">A</span> -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">F</span>&lt;<span class="type">B</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Too much</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/28/parser-combinator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/28/parser-combinator/" itemprop="url">Parser Combinator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T20:00:00+08:00">
                2017-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/functional-programming/" itemprop="url" rel="index">
                    <span itemprop="name">functional programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</p>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>将一个数据流解析成结构化的数据的工具，我们称为解析器。比如我们需要将用户输入的表达式字符串解析成 AST，我们就可以使用解析器来达到我们的目的。</p>
<p><code>( 4 + 3  )</code> 就是一个表达式语句，它由字符 <code>(</code>  <code>4</code> <code>空格</code> <code>+</code> <code>3</code> 和 <code>)</code> 组成。我们可以将这个表达式解析成一种 <em>表达式树</em> (AST 的一种)。</p>
<p>所以我们的解析器简单的用一个函数来描述就是：<br><code>func parser(_ string: String) -&gt; AST</code></p>
<p>我们不是用正则表达式来解析输入的表达式字符串，为了得到表达式树里面的节点，我们需要一步步的解析，每次解析得到不同的节点。所以我们需要将解析器的定义变成解析成功的话，会返回结果值和剩下的字符串。</p>
<p><code>func parser(_ string: String) -&gt; (AST, String)</code></p>
<p>表达式树的节点都是一些 <code>4</code> <code>+</code> 这种不同类型的数据，所以为了表示解析 <code>4</code> 成功和解析 <code>+</code> 成功，我们的返回值可以定义为泛型。并且表达出解析失败的情况，我们可以使用可选值。最终解析器函数就变成了：</p>
<p><code>func parser&lt;T&gt;(_ string: String) -&gt; (T, String)?</code></p>
<p>所以解析第一个数字 4 的解析器函数为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">String</span>)? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = string.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Optional</span>.some((<span class="number">4</span>, <span class="type">String</span>(string.characters.<span class="built_in">dropFirst</span>())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Combinator"><a href="#Combinator" class="headerlink" title="Combinator"></a>Combinator</h2><blockquote>
<p>One of the distinguishing features of functional programming is the widespread use of combinators to construct programs. <em>A combinator is a function which builds program fragments from program fragments</em>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. – John Hughes</p>
</blockquote>
<p>其实 Combinator 很容易理解，就像字面意思那样 —— 组合子。首先定义一系列原子操作，然后定义组合的规则，然后根据组合的规则把这些原子操作组合起来。</p>
<h2 id="Parser-Combinator"><a href="#Parser-Combinator" class="headerlink" title="Parser Combinator"></a>Parser Combinator</h2><p>回到开头的话：<em>解析组合子是由多个解析器为参数并返回一个解析器的高阶函数。</em> 所以我们需要重新定义一下我们的解析器，把它变成一个解析组合子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parse: (<span class="type">String</span>) -&gt; (<span class="type">A</span>, <span class="type">String</span>)?</span><br><span class="line">    <span class="comment">// (input) -&gt; (result, remaining)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个解析字符串的解析器，我们把这个函数放到一个结构体 <code>Parser</code> 中，作为一个 <code>parse</code> 变量。当然我们也可以用类型别名 <code>typealias Parser&lt;Result&gt; = (String) -&gt; (Result, String)?</code>。</p>
<p>当然解析组合子不仅仅能解析字符串，所以可以用泛型来把它变得更通用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parse: (<span class="type">I</span>) -&gt; (<span class="type">O</span>, <span class="type">I</span>)?</span><br><span class="line">    <span class="comment">// (input) -&gt; (output, remaining input)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以解析数字字符 <code>4</code> 的解析器就变成了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">character4</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == <span class="string">"4"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"4"</span>, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以根据 <code>func character4() -&gt; Parser&lt;Character&gt;</code> 很容易得到一个能够解析任何字符的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">character</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, head == character <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 的区别，很容易又得到能够解析任何数字的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digit</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, <span class="string">"0"</span>...<span class="string">"9"</span> ~= head <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 <code>character</code> 和 <code>digit</code> 相同和不同，我们可以进一步抽象，把相同部分进行封装，把不同部分作为参数，得到新的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">satisfy</span><span class="params">(<span class="number">_</span> condition: @escaping <span class="params">(Character)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = input.characters.first, condition(head) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (head, <span class="type">String</span>(input.characters.<span class="built_in">dropFirst</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以解析数字：</p>
<p><code>(satisfy { &quot;0&quot;...&quot;9&quot; ~= $0 }).parse(&quot;1abc&quot;)</code></p>
<p>解析空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSpace</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(character).trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines).isEmpty</span><br><span class="line">&#125;</span><br><span class="line">(satisfy(isSpace)).parse(<span class="string">" abc"</span>)</span><br></pre></td></tr></table></figure>
<p>所以我们只需要给 <code>satisfy</code> 函数传入一个是否属于 X 的函数，就可以得到一个能够解析 x 的解析器。</p>
<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>最基本的 <code>character</code> 有了，<code>digit</code> 有了，当我们需要解析一个字符串 <code>alex</code> 的时候，我们只需要把 <code>alex</code> 看成 <code>a</code> <code>l</code> <code>e</code> <code>x</code> 4 个字符，然后不断的用 <code>character</code> 进行解析，最后把每一步返回的结果合并起来就行了。考虑到解析一个字符串是一个基本功能，为了不用每次写重复的代码，把它封装成用来解析 <code>string</code> 的解析器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> parsers = str.characters.<span class="built_in">map</span> &#123; character($<span class="number">0</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">for</span> parser <span class="keyword">in</span> parsers &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = parser.parse(stream) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">String</span>(results), stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 parse 函数类型 <code>(String) -&gt; (A, String)</code>，解析成功的返回值是解析结果和 <strong>剩余</strong> 的字符串，所以解析 <code>alex</code> 的时候：</p>
<ol>
<li>“alex”: ‘a’ -&gt; (‘a’, “lex”)</li>
<li>“lex”: ‘l’ -&gt; (‘l’, “ex”)</li>
<li>“ex”: ‘e’ -&gt; (‘e’, “x”)</li>
<li>“x”: ‘x’ -&gt; (‘x’, “”)</li>
<li>Parser&lt;”alex”&gt;</li>
</ol>
<p>可以看到这几步做的事情除了参数不一样，内部逻辑是一样的，而且很容易看出是一个递归的过程，<strong>每次解析成功就 <code>吃掉</code> 第一个字符</strong>（留意这句话），然后解析剩下的字符串。</p>
<p>所以我们写一个递归的版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 0. 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 先解析第一个字符</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = character(head).parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 然后解析剩下的所有</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder2) = string1(<span class="type">String</span>(tail)).parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回("结果", "剩余的字符串")</span></span><br><span class="line">        <span class="keyword">return</span> (str, remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncons</span>&lt;C: Collection&gt;<span class="params">(<span class="number">_</span> xs: C)</span></span> -&gt; (<span class="type">C</span>.<span class="type">Iterator</span>.<span class="type">Element</span>, <span class="type">C</span>.<span class="type">SubSequence</span>)? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = xs.first <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (head, xs.suffix(from: xs.index(after: xs.startIndex)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 1 和 2，在这两步中，我们都没有使用解析的 <strong>结果</strong>，这两步实现的仅仅是 <strong>每次解析成功就 <code>吃掉</code> 结果</strong>！最后在第 3 步一次将结果返回。也就是说我们 1 和 2 这两本并不关心结果，只关心这些要解析道字符存在就行了。</p>
<p>我们把解析成功吃掉结果这一步封装一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只保留右边的解析器的结果 result2，没有 result1</span></span><br><span class="line">        <span class="keyword">return</span> (result2, remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>discarding</code> 函数会 <strong>吃掉</strong> 左边第一个参数 <code>x</code> 的解析结果，返回值中只保留右边 <code>y</code> 的解析结果。用 <code>discarding</code> 函数重写一下上面的 <code>string</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">""</span>, input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 吃掉 character(head) 的结果</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder) = discarding(character(head), string2(<span class="type">String</span>(tail))).parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 返回 ("结果", "剩余的字符串")</span></span><br><span class="line">        <span class="keyword">return</span> (str, remainder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次改版的 <code>string</code> 里面第 1 步中的解析结果还是被忽略了，所以是否可以继续用 <code>discarding</code> 来简化？但是 <code>discarding</code> 函数需要两个解析器，但函数内只有 <code>lift</code> 返回的一个解析器，所以没办法继续简化了？</p>
<p>仔细看 <code>string</code> 函数体的第一行 <code>return Parser {}</code> 就是一个解析器，能否把这个解析器利用上呢？<code>discarding</code> 是在 <code>Parser {}</code> 里面的，所以只要能想办法把它展平，那么就能再次利用上 <code>lift</code>，而且展平后的解析器需要做为 <code>string</code> 函数的返回值，所以它肯定是做为 <code>discarding</code> 的右边的参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lhs = <span class="type">Parser</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> lift(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据第 2 步的 <code>return (str, remainder)</code> 可以知道，最终的返回结果是 <code>(输入的，lhs 吃剩的)</code>，所以很容易得到 <code>let rhs = Parser&lt;String&gt; { (str, $0) }</code>。所以可以推出 lhs 要做的只是负责吃掉一部分。也就是上面的第 1 步所做的。所以：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">""</span>, input)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 吃掉</span></span><br><span class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</span><br><span class="line">    <span class="comment">// 3 结果和剩下的</span></span><br><span class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</span><br><span class="line">    <span class="comment">// 4 返回</span></span><br><span class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的返回值是 <code>Parser</code>，由于外面没有 Parser {} ，展开后 1 那里需要返回一个 <code>Parser</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (<span class="string">""</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> rhs = <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123; (str, $<span class="number">0</span>) &#125;</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明眼人可以看到 1 和 3 只有 <code>&quot;&quot;</code> 和 <code>str</code> 不一样，剩下的一模一样，虽然代码不长，但我们还是把它相同部分封装成一个函数，然后把不同的部分做为参赛。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = uncons(str.characters) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 把空字符解析器去解析任何字符串，都认为是解析成功</span></span><br><span class="line">        <span class="keyword">return</span> pure(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> lhs = discarding(character(head), string2(<span class="type">String</span>(tail)))</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> rhs = pure(str)</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> discarding(lhs, rhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lift a value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pure</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: A)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123; (x, $<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以封装一个简洁的 <code>string</code> 解析器，花了很多功夫，但抛开性能，它比迭代的版本更简洁易懂。</p>
<h2 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h2><p>观察表达式 <code>( 4 + 3  )</code>，里面 <code>(</code> 和 <code>4</code> 之间有 1 个空格，数字 <code>3</code> 和 <code>)</code> 中间是有 2 个空格，在做加法运算的时候，这些 <em>many</em> 个空格是没有意义的，所以需要 <em>skip</em> 掉。</p>
<h4 id="Many"><a href="#Many" class="headerlink" title="Many"></a>Many</h4><p>首先需要解析空格的解析器，前面已经有实现过：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">space</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> satisfy(isSpace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于空格数量未知，可能有 <em>many</em> 个，假如有一个解析器，能够解析 <em>many</em> 个 parser。用一个 loop 不断去解析就能实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">many</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">A</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (results, stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意个空格就是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many(space())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>spaces</code> 得到的是一个 <code>Parser&lt;[Character]&gt;</code> 类型的 parser，但是按照理解更希望得到一个 <code>Parser&lt;String&gt;</code> 类型的 parser。在 Swift 中，<code>String([Character])</code> 就能够将 <code>[Character]</code> 拍扁成 <code>String</code> 类型。所以把 <code>many</code> 稍微修改一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">many</span>&lt;Character&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;Character&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">String</span>(results), stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为不是任何泛型 A 类型，都能用 String 拍扁，也不一定能通过其他类型进行拍扁，所以这里把泛型 A 去掉，直接用 Character 代替。但是这样做并不理想，因为 <code>many</code> 解析器从一个泛型解析器，变成了一个只能解析 Character 类型的解析器，变成了 <code>manyCharacter</code>。后面考虑解析这个问题，重新把 <code>many</code> 变成通用的解析器。</p>
<h4 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h4><p>接着实现一个通用的 <code>skip</code> 解析器，它要做的事情很简单，输入什么吃掉什么，返回剩下的，和上面吃掉左边的 <code>discarding</code> 很像，不一样的是 <code>skip</code> 只有一个参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">skip</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((), input)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ((), remainder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 <code>skip</code> 和 <code>spaces</code> 进行组合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">skipSpaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> skip(spaces)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Many1"><a href="#Many1" class="headerlink" title="Many1"></a>Many1</h4><p>前面实现的 <code>digit</code> 解析器，它只能解析个位数，这是没有什么卵用的。相比 <code>digit</code>，更加需要的是一个 <code>number</code> 解析器。一个 <em>number</em> 实际上也是由 <em>many</em> 个 <em>digit</em> 组成。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many(digit())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">number().parse(<span class="string">"123abc"</span>) <span class="comment">// (["1", "2", "3"], "abc")</span></span><br><span class="line">number().parse(<span class="string">"abc"</span>) <span class="comment">// ([], "abc")</span></span><br></pre></td></tr></table></figure>
<p>等等！<code>number().parse(&quot;abc&quot;)</code> 也解析成功了，结果是空数组。这并不是想要的结果，一个 <em>string</em> 可以是空的，<em>space</em> 甚至也可以是空的，但一个 <em>number</em> 不能是空的。所以需要另外一个只是有一个的 <code>many</code>。这其实很常见，比如正则表达式中有 <code>*</code> 和 <code>+</code>，一个 {0, +} 一个是 {1, +}。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">many1</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">A</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 多加一个判断，第一个值必须满足条件</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">A</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (results, stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以正确的 <code>number</code> 解析器就变成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;[<span class="type">Character</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many1(digit())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>number</code> 解析器和 <code>spaces</code> 解析器遇到了同样的问题，<code>number</code> 解析器的结果应该是 <code>Int</code>（暂不考虑浮点数），而不是 <code>[Character]</code>。解决方法可以类似 <code>manyCharacter</code>，但是这显示是很有问题的，抽象抽象抽象！</p>
<p>程序员要有抽象思维，要学会用更高的层次的思维去看待问题，发现不同问题的共同点。<code>[Character]</code> 可以用 <code>String([Character])</code> 变成一个 <code>String</code>。对于 <code>digit</code> character，同样的也是用 <code>String([Character])</code> 拍扁，然后用 <code>Int(String)</code> 得到一个 <code>number</code>。</p>
<p>结合 Swift 的 OOP（面向协议编程），可以定义一个协议，暂且叫做 <code>Combinable</code> :D</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Combinable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Combinable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(<span class="type">String</span>(describing: xs))!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">Combinable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> xs: [Character])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: xs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">many1</span>&lt;A: Combinable&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;Character&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">Character</span>] = []</span><br><span class="line">        <span class="keyword">var</span> stream = input</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> (result, remainder) = x.parse(stream) &#123;</span><br><span class="line">            results.append(result)</span><br><span class="line">            stream = remainder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">A</span>.combine(results), stream)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many1(digit())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> many1(space()) <span class="comment">// 忽略 spaces 可以为空的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上 <code>skipSpaces</code> 还可以用另外一个角度来拆分，上面先解析 <em>many</em> 个空格，然后一次 <em>skip</em> 掉。还可以每次 <em>skip</em> 一个空格，然后进行 <em>many</em> 次。不同的地方是 <code>skip</code> 和 <code>many</code> 两个 parser 的调用次序不一样，甚至还可以定义一个叫做 <code>skipMany</code> 的解析器，这也说明了 <strong>Combinator</strong> 的强大。通过定义一系列基础的 parser，进行不同的排列组合操作，最后覆盖所有的 case。（理想状态</p>
<h4 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h4><p>合并两个 parser 的解析器 <code>zip</code> 的实现也很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zip</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;(<span class="type">A</span>, <span class="type">B</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ((result1, result2), remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Choice"><a href="#Choice" class="headerlink" title="Choice"></a>Choice</h4><p>接下来还需要解析几个简单的一元运算符 <code>+</code> <code>-</code> <code>*</code> <code>/</code>。去掉空格后，两个数中间必须是其中一个运算符那么表达式就是合法的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opt</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> opts = [<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>].<span class="built_in">map</span> &#123; character($<span class="number">0</span>.characters.first!) &#125;</span><br><span class="line">    <span class="keyword">return</span> choice(opts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以叫 one(of:)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice</span>&lt;A, S: Sequence&gt;<span class="params">(<span class="number">_</span> xs: S)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> xs.<span class="built_in">reduce</span>(empty(), &#123; $<span class="number">0</span> &lt;|&gt; $<span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span>&lt;A&gt;<span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>上面利用 Protocol 实现的 <code>number</code> 和 <code>space</code> 解析器其实并不是很优雅，费了很大劲把 <code>many</code> 变得 <del>通用</del>，结果却并不是很 <strong>通用</strong>，因为要求结果的类型必须实现 <code>Combinable</code> 协议。但它做的工作却很少，只是把传入的 <code>Parser&lt;A&gt;</code> 循环解析得到的结果 <code>[A]</code> 在 <code>many</code> <strong>内部</strong> 组合成最终的类型，实现把 <code>Parser&lt;[A]</code> 转换为 <code>Parser&lt;B&gt;</code>。正由于它是在 <code>many</code> 内部做的操作，所以依赖于传入的类型，使得 <code>many</code> 不再那么通用。</p>
<p>再看 <code>func character(_ character: Character) -&gt; Parser&lt;Character&gt;</code> 的定义，假如调用 <code>character(&quot;4&quot;)</code>，那么返回的是一个 <code>Parser&lt;Character&gt;</code> 类型的解析器，这个解析器调用 <code>parse</code> 方法，返回的结果是 <code>Character</code> 类型的值。在解析表达式 <code>4 + 3</code> 的时候，需要将解析到的 <code>4</code> 和 <code>3</code> 当作一个整数然后相加，才能得到最终的结果，所以不想要 <code>Character</code> 类型的值，而是想要 <code>Int</code> 类型的值，那么需要将 <code>Parser&lt;Character&gt;</code> 转换为 <code>Parser&lt;Int&gt;</code> 解析器。</p>
<p>所以，假如能实现一个函数，可以将任意 <code>Parser&lt;A&gt;</code> 转换为 <code>Parser&lt;B&gt;</code> 解析器，就完美了。<code>many</code> 只负责将 <code>Parser&lt;A&gt;</code> 解析得到 <code>Parser&lt;[A]&gt;</code>，然后由 <code>number</code> 自己将 <code>Parser&lt;[A]&gt;</code> 转换为 <code>Parser&lt;Int&gt;</code>。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><p>回忆 Swift 中 Optional 类型中的 map 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt; = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = a.<span class="built_in">map</span> &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>它将一个 <code>Optional&lt;Int&gt;</code> 转换为 <code>Optional&lt;String&gt;</code>，仔细一看，把 <code>Optional</code> 换成 <code>Parser</code>，就是我们所需要的转换解析器的方法。</p>
<p><code>Optional</code> 的函数签名是 <code>func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; U?</code>，所以依葫芦画瓢，我们可以得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;B&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = <span class="keyword">self</span>.parse(input) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">            <span class="keyword">return</span> (transform(result), remainder)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面的 <code>satisfy</code> 和其他函数一样，把 <code>map</code> 方法从结构图内移出来，则得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: @escaping <span class="params">(A)</span></span></span> -&gt; <span class="type">B</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = x.parse(input)<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (f(result), remainder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于值是在 <code>Parser</code> 中包裹着的，想把返回的 <code>Parser&lt;Character</code> 变成 <code>Parser&lt;Int&gt;</code>，需要把 <code>Parser&lt;Character&gt;</code> 解开取出里面<character>的值，然后把它变成<int>类型，然后重现包装起来。对于不同的类型转换，解包重新包装的步骤是一样的，不同的地方是把结果从一种类型变成另一种类型，函数的作用就是把相同的封装起来，把不同做为参赛传进去，所以在 <code>map</code> 函数的实现中，只需要在返回前，给外部将这个结果进行一次转换机会，所以需要一个参赛，能够将解开后得到的值变成另一种类型的值，也就是提供一个函数 <code>(Character) -&gt; Int</code>。</int></character></p>
<p>重新实现 <code>number</code> 和 <code>spaces</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(many1(digit()), &#123; <span class="type">Int</span>(<span class="type">String</span>($<span class="number">0</span>))! &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spaces</span><span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(many(space()), &#123; <span class="type">String</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种不同的结构体 <code>Optional&lt;T&gt;</code> 和 <code>Parser&lt;A&gt;</code>，都可以给它实现一个 <code>map</code> 方法，使得它变成一个不同类型的结构体。而支持这种 <code>map</code> 方法的结构体，我们称把它为 <code>Functor</code>。</p>
<blockquote>
<p>简单来说，所谓的 <code>Functor</code> 就是可以把一个函数应用于一个 <strong>封装过的值</strong> 上，得到一个新的 <strong>封装过的值</strong></p>
</blockquote>
<p><code>Functor</code> 最早出自于代数拓扑，这里说的 <code>Functor</code> 一般是指范畴论（Category Theory）中的 <code>Functor</code>，它被用来描述各种范畴间的关系。更多 Functor 的理解 <a href="http://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">Group Theory and Category Theory</a>。</p>
<h3 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pure</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: A)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123; (x, $<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上前面的 <code>pure</code> 和 <code>discarding</code> 函数就是一种 Applicative。像 <code>discarding</code> 一样有时候只关心这些要解析道字符存在就行了，上面定义的 <code>discarding</code> 解析器作用是忽略第一个 parser 参数的解析结果，同样地，可以定义一个忽略第二个 parser 参数的解析器。比如当解析出现在右边的 symbol 的时候就很有用，<code>discarding2(parser, string(&quot;)&quot;))</code> 的作用就是确保存在闭合的右括号 “)”。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 吃掉右边的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding2</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只保留左边的解析器的结果 result1，没有 result2</span></span><br><span class="line">        <span class="keyword">return</span> (result1, remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 吃掉左边的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">discarding1</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (<span class="number">_</span>, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只保留右边的解析器的结果 result2，没有 result1</span></span><br><span class="line">        <span class="keyword">return</span> (result2, remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个 <code>discarding</code> 函数长的很像，如果有办法把它们抽象一下，把相似的地方提取出来就好了。</p>
<p>对于两个结果，忽略其中一个，实际上很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 忽略 B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">A</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 忽略 A</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">B</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 吃掉左边的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">left</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;B&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">discarding</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> a: A, <span class="number">_</span> b: B)</span></span> -&gt; <span class="type">A</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result1, remainder1) = x.parse(input) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result2, remainder2) = y.parse(remainder1) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (discarding(result1, result2), remainder2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这个函数并没有卵用。</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>观看 <code>map</code> 函数 <code>func map&lt;A, B&gt;(_ x: Parser&lt;A&gt;, _ f: (A) -&gt; B) -&gt; Parser&lt;B&gt;</code></p>
<p>它要求传入两个参数，一个是 <code>Parser&lt;A&gt;</code>，一个是函数 <code>A -&gt; B</code>，第二个参数对标题中的 <strong>Combinator</strong> 并不是很友好，<strong>Parser Combinator</strong> 的思想是组合一系列的 <code>Parser</code> 得到结果。上面定义了有很多小的 parser，比如 <code>func string(_ str: String) -&gt; Parser&lt;String&gt;</code>，函数签名是 <code>(String) -&gt; Parser&lt;String&gt;</code>，由于 <code>map</code> 函数的第二个参数的签名是 <code>(A) -&gt; B</code>，而非 <code>(A) -&gt; Parser&lt;B&gt;</code>，所以假如存在一个与 <code>map</code> 功能相似，但第二个参数的签名是 <code>(A) -&gt; Parser&lt;B&gt;</code>，则能够使得之前定义的很多小的 <code>parser</code> 能够直接作为一个参数，直接得到一个新类型的 <code>Parser</code>，大概这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: <span class="params">(A)</span></span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;</span><br></pre></td></tr></table></figure>
<p>使用的时候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parser = flatMap(stringParser, string(<span class="string">"alex"</span>))</span><br></pre></td></tr></table></figure>
<p>具体实现与 <code>map</code> 也很像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;A, B&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> f: @escaping <span class="params">(A)</span></span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt;) -&gt; <span class="type">Parser</span>&lt;<span class="type">B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> (result, remainder) = x.parse(input)<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(result).parse(remainder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://blessingsoft.com/2017/06/12/group-theory-and-category-theory/">Group Theory and Category Theory</a></p>
<h3 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span>&lt;A&gt;<span class="params">()</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice</span>&lt;A&gt;<span class="params">(<span class="number">_</span> x: Parser&lt;A&gt;, <span class="number">_</span> y: Parser&lt;A&gt;)</span></span> -&gt; <span class="type">Parser</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Parser</span> &#123; input <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> x.parse(input) ?? y.parse(input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Alternative 类似于 <code>Swift Standard Library</code> 中定义的运算符 <code>??</code>，它有两个同类型的参数，第一个参数是偏爱的 <code>parser</code>，第二个参数是默认的 <code>parser</code>。它首先尝试使用第一个 <code>parser</code> 来进行解析，如果成功，则返回。如果不成功，则使用默认的 <code>parser</code> 进行解析。它的返回值类型也是同类型的 <code>Parser</code>。</p>
<p>作用是假如有 Int, String, Bool 三个类型的 <code>parser</code>，而一个 scalar 类型的 <code>parser</code> 只要能够解析 Int, String, Bool 任意一种类型，则算解析成功。换句话说就是 scalar 是 Int, String, Bool 的父集。一种简单的从 <code>Parser&lt;Int&gt;</code>, <code>Parser&lt;String&gt;</code>, <code>Parser&lt;Bool&gt;</code> 三种已有实现的 parser 得到 <code>Parser&lt;Scalar&gt;</code> 的方法是逐个进行 parse，如果成功则马上返回。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scalar = parserInt &lt;|&gt; parserString &lt;|&gt; parserBool</span><br></pre></td></tr></table></figure>
<p>从这个例子看有点 one of 的意思，但实际上更加准确的说法是 choice。</p>
<h3 id="Applicative-amp-Monad"><a href="#Applicative-amp-Monad" class="headerlink" title="Applicative &amp; Monad"></a>Applicative &amp; Monad</h3><p>Applicative 和 Monad 的区别在于：</p>
<p>Applicative 的两个 parser 是相互独立的，组合后的新 parser 是可以静态分析其行为的。而对于 Monad，在不知道输入的情况下，是不能确定其行为，也就是说 Monad 是依赖于计算结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alex</span><span class="params">(<span class="number">_</span> x: Parser&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>) = x.parse(<span class="string">"alex.huo"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> af: <span class="type">Parser</span>&lt;(<span class="type">String</span>) -&gt; <span class="type">String</span>&gt; = pure(id)</span><br><span class="line"><span class="keyword">let</span> ax = string(<span class="string">"alex"</span>)</span><br><span class="line">alex(af &lt;*&gt; ax) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mf: (<span class="type">String</span>) -&gt; <span class="type">Parser</span>&lt;<span class="type">String</span>&gt; = &#123; string($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> mx = string(<span class="string">"alex"</span>)</span><br><span class="line">alex(mx &gt;&gt;- mf) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/hlian/jiffy" target="_blank" rel="noopener">Jiffy</a><br><a href="https://news.realm.io/news/tryswift-yasuhiro-inami-parser-combinator/" target="_blank" rel="noopener">Parser combinators</a><br><a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf" target="_blank" rel="noopener">Monadic Parser Combinators</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blessingsoft.com/2017/05/20/cherry-blessing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xspyhack">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cherry Blessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/cherry-blessing/" itemprop="url">Cherry Blessing</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T20:00:00+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to Cherry Blessing.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Xspyhack">
          <p class="site-author-name" itemprop="name">Xspyhack</p>
           
              <p class="site-description motion-element" itemprop="description">Why join the navy if you can be a pirate?</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xspyhack</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
